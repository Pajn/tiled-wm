/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub unsafe fn as_ptr(&self) -> *const T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut_ptr(&mut self) -> *mut T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
impl<T> ::std::clone::Clone for __IncompleteArrayField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 29;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __FD_ZERO_STOS: &'static [u8; 6usize] = b"stosq\0";
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const __PTHREAD_MUTEX_LOCK_ELISION: u32 = 1;
pub const __PTHREAD_MUTEX_NUSERS_AFTER_KIND: u32 = 0;
pub const __PTHREAD_MUTEX_USE_UNION: u32 = 0;
pub const __PTHREAD_RWLOCK_INT_FLAGS_SHARED: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const _MATH_H: u32 = 1;
pub const _BITS_LIBM_SIMD_DECL_STUBS_H: u32 = 1;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __FP_LOGB0_IS_MIN: u32 = 1;
pub const __FP_LOGBNAN_IS_MIN: u32 = 1;
pub const FP_ILOGB0: i32 = -2147483648;
pub const FP_ILOGBNAN: i32 = -2147483648;
pub const __MATH_DECLARING_DOUBLE: u32 = 1;
pub const __MATH_DECLARING_FLOATN: u32 = 0;
pub const __MATH_DECLARE_LDOUBLE: u32 = 1;
pub const FP_NAN: u32 = 0;
pub const FP_INFINITE: u32 = 1;
pub const FP_ZERO: u32 = 2;
pub const FP_SUBNORMAL: u32 = 3;
pub const FP_NORMAL: u32 = 4;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const math_errhandling: u32 = 3;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const _INTTYPES_H: u32 = 1;
pub const ____gwchar_t_defined: u32 = 1;
pub const __PRI64_PREFIX: &'static [u8; 2usize] = b"l\0";
pub const __PRIPTR_PREFIX: &'static [u8; 2usize] = b"l\0";
pub const PRId8: &'static [u8; 2usize] = b"d\0";
pub const PRId16: &'static [u8; 2usize] = b"d\0";
pub const PRId32: &'static [u8; 2usize] = b"d\0";
pub const PRId64: &'static [u8; 3usize] = b"ld\0";
pub const PRIdLEAST8: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST16: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST32: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST64: &'static [u8; 3usize] = b"ld\0";
pub const PRIdFAST8: &'static [u8; 2usize] = b"d\0";
pub const PRIdFAST16: &'static [u8; 3usize] = b"ld\0";
pub const PRIdFAST32: &'static [u8; 3usize] = b"ld\0";
pub const PRIdFAST64: &'static [u8; 3usize] = b"ld\0";
pub const PRIi8: &'static [u8; 2usize] = b"i\0";
pub const PRIi16: &'static [u8; 2usize] = b"i\0";
pub const PRIi32: &'static [u8; 2usize] = b"i\0";
pub const PRIi64: &'static [u8; 3usize] = b"li\0";
pub const PRIiLEAST8: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST16: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST32: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST64: &'static [u8; 3usize] = b"li\0";
pub const PRIiFAST8: &'static [u8; 2usize] = b"i\0";
pub const PRIiFAST16: &'static [u8; 3usize] = b"li\0";
pub const PRIiFAST32: &'static [u8; 3usize] = b"li\0";
pub const PRIiFAST64: &'static [u8; 3usize] = b"li\0";
pub const PRIo8: &'static [u8; 2usize] = b"o\0";
pub const PRIo16: &'static [u8; 2usize] = b"o\0";
pub const PRIo32: &'static [u8; 2usize] = b"o\0";
pub const PRIo64: &'static [u8; 3usize] = b"lo\0";
pub const PRIoLEAST8: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST16: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST32: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST64: &'static [u8; 3usize] = b"lo\0";
pub const PRIoFAST8: &'static [u8; 2usize] = b"o\0";
pub const PRIoFAST16: &'static [u8; 3usize] = b"lo\0";
pub const PRIoFAST32: &'static [u8; 3usize] = b"lo\0";
pub const PRIoFAST64: &'static [u8; 3usize] = b"lo\0";
pub const PRIu8: &'static [u8; 2usize] = b"u\0";
pub const PRIu16: &'static [u8; 2usize] = b"u\0";
pub const PRIu32: &'static [u8; 2usize] = b"u\0";
pub const PRIu64: &'static [u8; 3usize] = b"lu\0";
pub const PRIuLEAST8: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST16: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST32: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST64: &'static [u8; 3usize] = b"lu\0";
pub const PRIuFAST8: &'static [u8; 2usize] = b"u\0";
pub const PRIuFAST16: &'static [u8; 3usize] = b"lu\0";
pub const PRIuFAST32: &'static [u8; 3usize] = b"lu\0";
pub const PRIuFAST64: &'static [u8; 3usize] = b"lu\0";
pub const PRIx8: &'static [u8; 2usize] = b"x\0";
pub const PRIx16: &'static [u8; 2usize] = b"x\0";
pub const PRIx32: &'static [u8; 2usize] = b"x\0";
pub const PRIx64: &'static [u8; 3usize] = b"lx\0";
pub const PRIxLEAST8: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST16: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST32: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST64: &'static [u8; 3usize] = b"lx\0";
pub const PRIxFAST8: &'static [u8; 2usize] = b"x\0";
pub const PRIxFAST16: &'static [u8; 3usize] = b"lx\0";
pub const PRIxFAST32: &'static [u8; 3usize] = b"lx\0";
pub const PRIxFAST64: &'static [u8; 3usize] = b"lx\0";
pub const PRIX8: &'static [u8; 2usize] = b"X\0";
pub const PRIX16: &'static [u8; 2usize] = b"X\0";
pub const PRIX32: &'static [u8; 2usize] = b"X\0";
pub const PRIX64: &'static [u8; 3usize] = b"lX\0";
pub const PRIXLEAST8: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST16: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST32: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST64: &'static [u8; 3usize] = b"lX\0";
pub const PRIXFAST8: &'static [u8; 2usize] = b"X\0";
pub const PRIXFAST16: &'static [u8; 3usize] = b"lX\0";
pub const PRIXFAST32: &'static [u8; 3usize] = b"lX\0";
pub const PRIXFAST64: &'static [u8; 3usize] = b"lX\0";
pub const PRIdMAX: &'static [u8; 3usize] = b"ld\0";
pub const PRIiMAX: &'static [u8; 3usize] = b"li\0";
pub const PRIoMAX: &'static [u8; 3usize] = b"lo\0";
pub const PRIuMAX: &'static [u8; 3usize] = b"lu\0";
pub const PRIxMAX: &'static [u8; 3usize] = b"lx\0";
pub const PRIXMAX: &'static [u8; 3usize] = b"lX\0";
pub const PRIdPTR: &'static [u8; 3usize] = b"ld\0";
pub const PRIiPTR: &'static [u8; 3usize] = b"li\0";
pub const PRIoPTR: &'static [u8; 3usize] = b"lo\0";
pub const PRIuPTR: &'static [u8; 3usize] = b"lu\0";
pub const PRIxPTR: &'static [u8; 3usize] = b"lx\0";
pub const PRIXPTR: &'static [u8; 3usize] = b"lX\0";
pub const SCNd8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNd16: &'static [u8; 3usize] = b"hd\0";
pub const SCNd32: &'static [u8; 2usize] = b"d\0";
pub const SCNd64: &'static [u8; 3usize] = b"ld\0";
pub const SCNdLEAST8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNdLEAST16: &'static [u8; 3usize] = b"hd\0";
pub const SCNdLEAST32: &'static [u8; 2usize] = b"d\0";
pub const SCNdLEAST64: &'static [u8; 3usize] = b"ld\0";
pub const SCNdFAST8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNdFAST16: &'static [u8; 3usize] = b"ld\0";
pub const SCNdFAST32: &'static [u8; 3usize] = b"ld\0";
pub const SCNdFAST64: &'static [u8; 3usize] = b"ld\0";
pub const SCNi8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNi16: &'static [u8; 3usize] = b"hi\0";
pub const SCNi32: &'static [u8; 2usize] = b"i\0";
pub const SCNi64: &'static [u8; 3usize] = b"li\0";
pub const SCNiLEAST8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNiLEAST16: &'static [u8; 3usize] = b"hi\0";
pub const SCNiLEAST32: &'static [u8; 2usize] = b"i\0";
pub const SCNiLEAST64: &'static [u8; 3usize] = b"li\0";
pub const SCNiFAST8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNiFAST16: &'static [u8; 3usize] = b"li\0";
pub const SCNiFAST32: &'static [u8; 3usize] = b"li\0";
pub const SCNiFAST64: &'static [u8; 3usize] = b"li\0";
pub const SCNu8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNu16: &'static [u8; 3usize] = b"hu\0";
pub const SCNu32: &'static [u8; 2usize] = b"u\0";
pub const SCNu64: &'static [u8; 3usize] = b"lu\0";
pub const SCNuLEAST8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNuLEAST16: &'static [u8; 3usize] = b"hu\0";
pub const SCNuLEAST32: &'static [u8; 2usize] = b"u\0";
pub const SCNuLEAST64: &'static [u8; 3usize] = b"lu\0";
pub const SCNuFAST8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNuFAST16: &'static [u8; 3usize] = b"lu\0";
pub const SCNuFAST32: &'static [u8; 3usize] = b"lu\0";
pub const SCNuFAST64: &'static [u8; 3usize] = b"lu\0";
pub const SCNo8: &'static [u8; 4usize] = b"hho\0";
pub const SCNo16: &'static [u8; 3usize] = b"ho\0";
pub const SCNo32: &'static [u8; 2usize] = b"o\0";
pub const SCNo64: &'static [u8; 3usize] = b"lo\0";
pub const SCNoLEAST8: &'static [u8; 4usize] = b"hho\0";
pub const SCNoLEAST16: &'static [u8; 3usize] = b"ho\0";
pub const SCNoLEAST32: &'static [u8; 2usize] = b"o\0";
pub const SCNoLEAST64: &'static [u8; 3usize] = b"lo\0";
pub const SCNoFAST8: &'static [u8; 4usize] = b"hho\0";
pub const SCNoFAST16: &'static [u8; 3usize] = b"lo\0";
pub const SCNoFAST32: &'static [u8; 3usize] = b"lo\0";
pub const SCNoFAST64: &'static [u8; 3usize] = b"lo\0";
pub const SCNx8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNx16: &'static [u8; 3usize] = b"hx\0";
pub const SCNx32: &'static [u8; 2usize] = b"x\0";
pub const SCNx64: &'static [u8; 3usize] = b"lx\0";
pub const SCNxLEAST8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNxLEAST16: &'static [u8; 3usize] = b"hx\0";
pub const SCNxLEAST32: &'static [u8; 2usize] = b"x\0";
pub const SCNxLEAST64: &'static [u8; 3usize] = b"lx\0";
pub const SCNxFAST8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNxFAST16: &'static [u8; 3usize] = b"lx\0";
pub const SCNxFAST32: &'static [u8; 3usize] = b"lx\0";
pub const SCNxFAST64: &'static [u8; 3usize] = b"lx\0";
pub const SCNdMAX: &'static [u8; 3usize] = b"ld\0";
pub const SCNiMAX: &'static [u8; 3usize] = b"li\0";
pub const SCNoMAX: &'static [u8; 3usize] = b"lo\0";
pub const SCNuMAX: &'static [u8; 3usize] = b"lu\0";
pub const SCNxMAX: &'static [u8; 3usize] = b"lx\0";
pub const SCNdPTR: &'static [u8; 3usize] = b"ld\0";
pub const SCNiPTR: &'static [u8; 3usize] = b"li\0";
pub const SCNoPTR: &'static [u8; 3usize] = b"lo\0";
pub const SCNuPTR: &'static [u8; 3usize] = b"lu\0";
pub const SCNxPTR: &'static [u8; 3usize] = b"lx\0";
pub const __GNUC_VA_LIST: u32 = 1;
pub const WAYLAND_VERSION_MAJOR: u32 = 1;
pub const WAYLAND_VERSION_MINOR: u32 = 16;
pub const WAYLAND_VERSION_MICRO: u32 = 0;
pub const WAYLAND_VERSION: &'static [u8; 7usize] = b"1.16.0\0";
pub const WL_DISPLAY_ERROR: u32 = 0;
pub const WL_DISPLAY_DELETE_ID: u32 = 1;
pub const WL_DISPLAY_ERROR_SINCE_VERSION: u32 = 1;
pub const WL_DISPLAY_DELETE_ID_SINCE_VERSION: u32 = 1;
pub const WL_DISPLAY_SYNC_SINCE_VERSION: u32 = 1;
pub const WL_DISPLAY_GET_REGISTRY_SINCE_VERSION: u32 = 1;
pub const WL_REGISTRY_GLOBAL: u32 = 0;
pub const WL_REGISTRY_GLOBAL_REMOVE: u32 = 1;
pub const WL_REGISTRY_GLOBAL_SINCE_VERSION: u32 = 1;
pub const WL_REGISTRY_GLOBAL_REMOVE_SINCE_VERSION: u32 = 1;
pub const WL_REGISTRY_BIND_SINCE_VERSION: u32 = 1;
pub const WL_CALLBACK_DONE: u32 = 0;
pub const WL_CALLBACK_DONE_SINCE_VERSION: u32 = 1;
pub const WL_COMPOSITOR_CREATE_SURFACE_SINCE_VERSION: u32 = 1;
pub const WL_COMPOSITOR_CREATE_REGION_SINCE_VERSION: u32 = 1;
pub const WL_SHM_POOL_CREATE_BUFFER_SINCE_VERSION: u32 = 1;
pub const WL_SHM_POOL_DESTROY_SINCE_VERSION: u32 = 1;
pub const WL_SHM_POOL_RESIZE_SINCE_VERSION: u32 = 1;
pub const WL_SHM_FORMAT: u32 = 0;
pub const WL_SHM_FORMAT_SINCE_VERSION: u32 = 1;
pub const WL_SHM_CREATE_POOL_SINCE_VERSION: u32 = 1;
pub const WL_BUFFER_RELEASE: u32 = 0;
pub const WL_BUFFER_RELEASE_SINCE_VERSION: u32 = 1;
pub const WL_BUFFER_DESTROY_SINCE_VERSION: u32 = 1;
pub const WL_DATA_OFFER_OFFER: u32 = 0;
pub const WL_DATA_OFFER_SOURCE_ACTIONS: u32 = 1;
pub const WL_DATA_OFFER_ACTION: u32 = 2;
pub const WL_DATA_OFFER_OFFER_SINCE_VERSION: u32 = 1;
pub const WL_DATA_OFFER_SOURCE_ACTIONS_SINCE_VERSION: u32 = 3;
pub const WL_DATA_OFFER_ACTION_SINCE_VERSION: u32 = 3;
pub const WL_DATA_OFFER_ACCEPT_SINCE_VERSION: u32 = 1;
pub const WL_DATA_OFFER_RECEIVE_SINCE_VERSION: u32 = 1;
pub const WL_DATA_OFFER_DESTROY_SINCE_VERSION: u32 = 1;
pub const WL_DATA_OFFER_FINISH_SINCE_VERSION: u32 = 3;
pub const WL_DATA_OFFER_SET_ACTIONS_SINCE_VERSION: u32 = 3;
pub const WL_DATA_SOURCE_TARGET: u32 = 0;
pub const WL_DATA_SOURCE_SEND: u32 = 1;
pub const WL_DATA_SOURCE_CANCELLED: u32 = 2;
pub const WL_DATA_SOURCE_DND_DROP_PERFORMED: u32 = 3;
pub const WL_DATA_SOURCE_DND_FINISHED: u32 = 4;
pub const WL_DATA_SOURCE_ACTION: u32 = 5;
pub const WL_DATA_SOURCE_TARGET_SINCE_VERSION: u32 = 1;
pub const WL_DATA_SOURCE_SEND_SINCE_VERSION: u32 = 1;
pub const WL_DATA_SOURCE_CANCELLED_SINCE_VERSION: u32 = 1;
pub const WL_DATA_SOURCE_DND_DROP_PERFORMED_SINCE_VERSION: u32 = 3;
pub const WL_DATA_SOURCE_DND_FINISHED_SINCE_VERSION: u32 = 3;
pub const WL_DATA_SOURCE_ACTION_SINCE_VERSION: u32 = 3;
pub const WL_DATA_SOURCE_OFFER_SINCE_VERSION: u32 = 1;
pub const WL_DATA_SOURCE_DESTROY_SINCE_VERSION: u32 = 1;
pub const WL_DATA_SOURCE_SET_ACTIONS_SINCE_VERSION: u32 = 3;
pub const WL_DATA_DEVICE_DATA_OFFER: u32 = 0;
pub const WL_DATA_DEVICE_ENTER: u32 = 1;
pub const WL_DATA_DEVICE_LEAVE: u32 = 2;
pub const WL_DATA_DEVICE_MOTION: u32 = 3;
pub const WL_DATA_DEVICE_DROP: u32 = 4;
pub const WL_DATA_DEVICE_SELECTION: u32 = 5;
pub const WL_DATA_DEVICE_DATA_OFFER_SINCE_VERSION: u32 = 1;
pub const WL_DATA_DEVICE_ENTER_SINCE_VERSION: u32 = 1;
pub const WL_DATA_DEVICE_LEAVE_SINCE_VERSION: u32 = 1;
pub const WL_DATA_DEVICE_MOTION_SINCE_VERSION: u32 = 1;
pub const WL_DATA_DEVICE_DROP_SINCE_VERSION: u32 = 1;
pub const WL_DATA_DEVICE_SELECTION_SINCE_VERSION: u32 = 1;
pub const WL_DATA_DEVICE_START_DRAG_SINCE_VERSION: u32 = 1;
pub const WL_DATA_DEVICE_SET_SELECTION_SINCE_VERSION: u32 = 1;
pub const WL_DATA_DEVICE_RELEASE_SINCE_VERSION: u32 = 2;
pub const WL_DATA_DEVICE_MANAGER_CREATE_DATA_SOURCE_SINCE_VERSION: u32 = 1;
pub const WL_DATA_DEVICE_MANAGER_GET_DATA_DEVICE_SINCE_VERSION: u32 = 1;
pub const WL_SHELL_GET_SHELL_SURFACE_SINCE_VERSION: u32 = 1;
pub const WL_SHELL_SURFACE_PING: u32 = 0;
pub const WL_SHELL_SURFACE_CONFIGURE: u32 = 1;
pub const WL_SHELL_SURFACE_POPUP_DONE: u32 = 2;
pub const WL_SHELL_SURFACE_PING_SINCE_VERSION: u32 = 1;
pub const WL_SHELL_SURFACE_CONFIGURE_SINCE_VERSION: u32 = 1;
pub const WL_SHELL_SURFACE_POPUP_DONE_SINCE_VERSION: u32 = 1;
pub const WL_SHELL_SURFACE_PONG_SINCE_VERSION: u32 = 1;
pub const WL_SHELL_SURFACE_MOVE_SINCE_VERSION: u32 = 1;
pub const WL_SHELL_SURFACE_RESIZE_SINCE_VERSION: u32 = 1;
pub const WL_SHELL_SURFACE_SET_TOPLEVEL_SINCE_VERSION: u32 = 1;
pub const WL_SHELL_SURFACE_SET_TRANSIENT_SINCE_VERSION: u32 = 1;
pub const WL_SHELL_SURFACE_SET_FULLSCREEN_SINCE_VERSION: u32 = 1;
pub const WL_SHELL_SURFACE_SET_POPUP_SINCE_VERSION: u32 = 1;
pub const WL_SHELL_SURFACE_SET_MAXIMIZED_SINCE_VERSION: u32 = 1;
pub const WL_SHELL_SURFACE_SET_TITLE_SINCE_VERSION: u32 = 1;
pub const WL_SHELL_SURFACE_SET_CLASS_SINCE_VERSION: u32 = 1;
pub const WL_SURFACE_ENTER: u32 = 0;
pub const WL_SURFACE_LEAVE: u32 = 1;
pub const WL_SURFACE_ENTER_SINCE_VERSION: u32 = 1;
pub const WL_SURFACE_LEAVE_SINCE_VERSION: u32 = 1;
pub const WL_SURFACE_DESTROY_SINCE_VERSION: u32 = 1;
pub const WL_SURFACE_ATTACH_SINCE_VERSION: u32 = 1;
pub const WL_SURFACE_DAMAGE_SINCE_VERSION: u32 = 1;
pub const WL_SURFACE_FRAME_SINCE_VERSION: u32 = 1;
pub const WL_SURFACE_SET_OPAQUE_REGION_SINCE_VERSION: u32 = 1;
pub const WL_SURFACE_SET_INPUT_REGION_SINCE_VERSION: u32 = 1;
pub const WL_SURFACE_COMMIT_SINCE_VERSION: u32 = 1;
pub const WL_SURFACE_SET_BUFFER_TRANSFORM_SINCE_VERSION: u32 = 2;
pub const WL_SURFACE_SET_BUFFER_SCALE_SINCE_VERSION: u32 = 3;
pub const WL_SURFACE_DAMAGE_BUFFER_SINCE_VERSION: u32 = 4;
pub const WL_SEAT_CAPABILITIES: u32 = 0;
pub const WL_SEAT_NAME: u32 = 1;
pub const WL_SEAT_CAPABILITIES_SINCE_VERSION: u32 = 1;
pub const WL_SEAT_NAME_SINCE_VERSION: u32 = 2;
pub const WL_SEAT_GET_POINTER_SINCE_VERSION: u32 = 1;
pub const WL_SEAT_GET_KEYBOARD_SINCE_VERSION: u32 = 1;
pub const WL_SEAT_GET_TOUCH_SINCE_VERSION: u32 = 1;
pub const WL_SEAT_RELEASE_SINCE_VERSION: u32 = 5;
pub const WL_POINTER_AXIS_SOURCE_WHEEL_TILT_SINCE_VERSION: u32 = 6;
pub const WL_POINTER_ENTER: u32 = 0;
pub const WL_POINTER_LEAVE: u32 = 1;
pub const WL_POINTER_MOTION: u32 = 2;
pub const WL_POINTER_BUTTON: u32 = 3;
pub const WL_POINTER_AXIS: u32 = 4;
pub const WL_POINTER_FRAME: u32 = 5;
pub const WL_POINTER_AXIS_SOURCE: u32 = 6;
pub const WL_POINTER_AXIS_STOP: u32 = 7;
pub const WL_POINTER_AXIS_DISCRETE: u32 = 8;
pub const WL_POINTER_ENTER_SINCE_VERSION: u32 = 1;
pub const WL_POINTER_LEAVE_SINCE_VERSION: u32 = 1;
pub const WL_POINTER_MOTION_SINCE_VERSION: u32 = 1;
pub const WL_POINTER_BUTTON_SINCE_VERSION: u32 = 1;
pub const WL_POINTER_AXIS_SINCE_VERSION: u32 = 1;
pub const WL_POINTER_FRAME_SINCE_VERSION: u32 = 5;
pub const WL_POINTER_AXIS_SOURCE_SINCE_VERSION: u32 = 5;
pub const WL_POINTER_AXIS_STOP_SINCE_VERSION: u32 = 5;
pub const WL_POINTER_AXIS_DISCRETE_SINCE_VERSION: u32 = 5;
pub const WL_POINTER_SET_CURSOR_SINCE_VERSION: u32 = 1;
pub const WL_POINTER_RELEASE_SINCE_VERSION: u32 = 3;
pub const WL_KEYBOARD_KEYMAP: u32 = 0;
pub const WL_KEYBOARD_ENTER: u32 = 1;
pub const WL_KEYBOARD_LEAVE: u32 = 2;
pub const WL_KEYBOARD_KEY: u32 = 3;
pub const WL_KEYBOARD_MODIFIERS: u32 = 4;
pub const WL_KEYBOARD_REPEAT_INFO: u32 = 5;
pub const WL_KEYBOARD_KEYMAP_SINCE_VERSION: u32 = 1;
pub const WL_KEYBOARD_ENTER_SINCE_VERSION: u32 = 1;
pub const WL_KEYBOARD_LEAVE_SINCE_VERSION: u32 = 1;
pub const WL_KEYBOARD_KEY_SINCE_VERSION: u32 = 1;
pub const WL_KEYBOARD_MODIFIERS_SINCE_VERSION: u32 = 1;
pub const WL_KEYBOARD_REPEAT_INFO_SINCE_VERSION: u32 = 4;
pub const WL_KEYBOARD_RELEASE_SINCE_VERSION: u32 = 3;
pub const WL_TOUCH_DOWN: u32 = 0;
pub const WL_TOUCH_UP: u32 = 1;
pub const WL_TOUCH_MOTION: u32 = 2;
pub const WL_TOUCH_FRAME: u32 = 3;
pub const WL_TOUCH_CANCEL: u32 = 4;
pub const WL_TOUCH_SHAPE: u32 = 5;
pub const WL_TOUCH_ORIENTATION: u32 = 6;
pub const WL_TOUCH_DOWN_SINCE_VERSION: u32 = 1;
pub const WL_TOUCH_UP_SINCE_VERSION: u32 = 1;
pub const WL_TOUCH_MOTION_SINCE_VERSION: u32 = 1;
pub const WL_TOUCH_FRAME_SINCE_VERSION: u32 = 1;
pub const WL_TOUCH_CANCEL_SINCE_VERSION: u32 = 1;
pub const WL_TOUCH_SHAPE_SINCE_VERSION: u32 = 6;
pub const WL_TOUCH_ORIENTATION_SINCE_VERSION: u32 = 6;
pub const WL_TOUCH_RELEASE_SINCE_VERSION: u32 = 3;
pub const WL_OUTPUT_GEOMETRY: u32 = 0;
pub const WL_OUTPUT_MODE: u32 = 1;
pub const WL_OUTPUT_DONE: u32 = 2;
pub const WL_OUTPUT_SCALE: u32 = 3;
pub const WL_OUTPUT_GEOMETRY_SINCE_VERSION: u32 = 1;
pub const WL_OUTPUT_MODE_SINCE_VERSION: u32 = 1;
pub const WL_OUTPUT_DONE_SINCE_VERSION: u32 = 2;
pub const WL_OUTPUT_SCALE_SINCE_VERSION: u32 = 2;
pub const WL_OUTPUT_RELEASE_SINCE_VERSION: u32 = 3;
pub const WL_REGION_DESTROY_SINCE_VERSION: u32 = 1;
pub const WL_REGION_ADD_SINCE_VERSION: u32 = 1;
pub const WL_REGION_SUBTRACT_SINCE_VERSION: u32 = 1;
pub const WL_SUBCOMPOSITOR_DESTROY_SINCE_VERSION: u32 = 1;
pub const WL_SUBCOMPOSITOR_GET_SUBSURFACE_SINCE_VERSION: u32 = 1;
pub const WL_SUBSURFACE_DESTROY_SINCE_VERSION: u32 = 1;
pub const WL_SUBSURFACE_SET_POSITION_SINCE_VERSION: u32 = 1;
pub const WL_SUBSURFACE_PLACE_ABOVE_SINCE_VERSION: u32 = 1;
pub const WL_SUBSURFACE_PLACE_BELOW_SINCE_VERSION: u32 = 1;
pub const WL_SUBSURFACE_SET_SYNC_SINCE_VERSION: u32 = 1;
pub const WL_SUBSURFACE_SET_DESYNC_SINCE_VERSION: u32 = 1;
pub const _SYS_SYSMACROS_H: u32 = 1;
pub const _BITS_SYSMACROS_H: u32 = 1;
pub const WLR_HAS_LIBCAP: u32 = 0;
pub const WLR_HAS_SYSTEMD: u32 = 0;
pub const WLR_HAS_ELOGIND: u32 = 0;
pub const WLR_HAS_X11_BACKEND: u32 = 0;
pub const WLR_HAS_RDP_BACKEND: u32 = 0;
pub const WLR_HAS_XWAYLAND: u32 = 0;
pub const WLR_HAS_XCB_ERRORS: u32 = 0;
pub const WLR_HAS_XCB_ICCCM: u32 = 0;
pub const __egl_h_: u32 = 1;
pub const KHRONOS_SUPPORT_INT64: u32 = 1;
pub const KHRONOS_SUPPORT_FLOAT: u32 = 1;
pub const KHRONOS_MAX_ENUM: u32 = 2147483647;
pub const EGL_VERSION_1_0: u32 = 1;
pub const EGL_ALPHA_SIZE: u32 = 12321;
pub const EGL_BAD_ACCESS: u32 = 12290;
pub const EGL_BAD_ALLOC: u32 = 12291;
pub const EGL_BAD_ATTRIBUTE: u32 = 12292;
pub const EGL_BAD_CONFIG: u32 = 12293;
pub const EGL_BAD_CONTEXT: u32 = 12294;
pub const EGL_BAD_CURRENT_SURFACE: u32 = 12295;
pub const EGL_BAD_DISPLAY: u32 = 12296;
pub const EGL_BAD_MATCH: u32 = 12297;
pub const EGL_BAD_NATIVE_PIXMAP: u32 = 12298;
pub const EGL_BAD_NATIVE_WINDOW: u32 = 12299;
pub const EGL_BAD_PARAMETER: u32 = 12300;
pub const EGL_BAD_SURFACE: u32 = 12301;
pub const EGL_BLUE_SIZE: u32 = 12322;
pub const EGL_BUFFER_SIZE: u32 = 12320;
pub const EGL_CONFIG_CAVEAT: u32 = 12327;
pub const EGL_CONFIG_ID: u32 = 12328;
pub const EGL_CORE_NATIVE_ENGINE: u32 = 12379;
pub const EGL_DEPTH_SIZE: u32 = 12325;
pub const EGL_DRAW: u32 = 12377;
pub const EGL_EXTENSIONS: u32 = 12373;
pub const EGL_FALSE: u32 = 0;
pub const EGL_GREEN_SIZE: u32 = 12323;
pub const EGL_HEIGHT: u32 = 12374;
pub const EGL_LARGEST_PBUFFER: u32 = 12376;
pub const EGL_LEVEL: u32 = 12329;
pub const EGL_MAX_PBUFFER_HEIGHT: u32 = 12330;
pub const EGL_MAX_PBUFFER_PIXELS: u32 = 12331;
pub const EGL_MAX_PBUFFER_WIDTH: u32 = 12332;
pub const EGL_NATIVE_RENDERABLE: u32 = 12333;
pub const EGL_NATIVE_VISUAL_ID: u32 = 12334;
pub const EGL_NATIVE_VISUAL_TYPE: u32 = 12335;
pub const EGL_NONE: u32 = 12344;
pub const EGL_NON_CONFORMANT_CONFIG: u32 = 12369;
pub const EGL_NOT_INITIALIZED: u32 = 12289;
pub const EGL_PBUFFER_BIT: u32 = 1;
pub const EGL_PIXMAP_BIT: u32 = 2;
pub const EGL_READ: u32 = 12378;
pub const EGL_RED_SIZE: u32 = 12324;
pub const EGL_SAMPLES: u32 = 12337;
pub const EGL_SAMPLE_BUFFERS: u32 = 12338;
pub const EGL_SLOW_CONFIG: u32 = 12368;
pub const EGL_STENCIL_SIZE: u32 = 12326;
pub const EGL_SUCCESS: u32 = 12288;
pub const EGL_SURFACE_TYPE: u32 = 12339;
pub const EGL_TRANSPARENT_BLUE_VALUE: u32 = 12341;
pub const EGL_TRANSPARENT_GREEN_VALUE: u32 = 12342;
pub const EGL_TRANSPARENT_RED_VALUE: u32 = 12343;
pub const EGL_TRANSPARENT_RGB: u32 = 12370;
pub const EGL_TRANSPARENT_TYPE: u32 = 12340;
pub const EGL_TRUE: u32 = 1;
pub const EGL_VENDOR: u32 = 12371;
pub const EGL_VERSION: u32 = 12372;
pub const EGL_WIDTH: u32 = 12375;
pub const EGL_WINDOW_BIT: u32 = 4;
pub const EGL_VERSION_1_1: u32 = 1;
pub const EGL_BACK_BUFFER: u32 = 12420;
pub const EGL_BIND_TO_TEXTURE_RGB: u32 = 12345;
pub const EGL_BIND_TO_TEXTURE_RGBA: u32 = 12346;
pub const EGL_CONTEXT_LOST: u32 = 12302;
pub const EGL_MIN_SWAP_INTERVAL: u32 = 12347;
pub const EGL_MAX_SWAP_INTERVAL: u32 = 12348;
pub const EGL_MIPMAP_TEXTURE: u32 = 12418;
pub const EGL_MIPMAP_LEVEL: u32 = 12419;
pub const EGL_NO_TEXTURE: u32 = 12380;
pub const EGL_TEXTURE_2D: u32 = 12383;
pub const EGL_TEXTURE_FORMAT: u32 = 12416;
pub const EGL_TEXTURE_RGB: u32 = 12381;
pub const EGL_TEXTURE_RGBA: u32 = 12382;
pub const EGL_TEXTURE_TARGET: u32 = 12417;
pub const EGL_VERSION_1_2: u32 = 1;
pub const EGL_ALPHA_FORMAT: u32 = 12424;
pub const EGL_ALPHA_FORMAT_NONPRE: u32 = 12427;
pub const EGL_ALPHA_FORMAT_PRE: u32 = 12428;
pub const EGL_ALPHA_MASK_SIZE: u32 = 12350;
pub const EGL_BUFFER_PRESERVED: u32 = 12436;
pub const EGL_BUFFER_DESTROYED: u32 = 12437;
pub const EGL_CLIENT_APIS: u32 = 12429;
pub const EGL_COLORSPACE: u32 = 12423;
pub const EGL_COLORSPACE_sRGB: u32 = 12425;
pub const EGL_COLORSPACE_LINEAR: u32 = 12426;
pub const EGL_COLOR_BUFFER_TYPE: u32 = 12351;
pub const EGL_CONTEXT_CLIENT_TYPE: u32 = 12439;
pub const EGL_DISPLAY_SCALING: u32 = 10000;
pub const EGL_HORIZONTAL_RESOLUTION: u32 = 12432;
pub const EGL_LUMINANCE_BUFFER: u32 = 12431;
pub const EGL_LUMINANCE_SIZE: u32 = 12349;
pub const EGL_OPENGL_ES_BIT: u32 = 1;
pub const EGL_OPENVG_BIT: u32 = 2;
pub const EGL_OPENGL_ES_API: u32 = 12448;
pub const EGL_OPENVG_API: u32 = 12449;
pub const EGL_OPENVG_IMAGE: u32 = 12438;
pub const EGL_PIXEL_ASPECT_RATIO: u32 = 12434;
pub const EGL_RENDERABLE_TYPE: u32 = 12352;
pub const EGL_RENDER_BUFFER: u32 = 12422;
pub const EGL_RGB_BUFFER: u32 = 12430;
pub const EGL_SINGLE_BUFFER: u32 = 12421;
pub const EGL_SWAP_BEHAVIOR: u32 = 12435;
pub const EGL_VERTICAL_RESOLUTION: u32 = 12433;
pub const EGL_VERSION_1_3: u32 = 1;
pub const EGL_CONFORMANT: u32 = 12354;
pub const EGL_CONTEXT_CLIENT_VERSION: u32 = 12440;
pub const EGL_MATCH_NATIVE_PIXMAP: u32 = 12353;
pub const EGL_OPENGL_ES2_BIT: u32 = 4;
pub const EGL_VG_ALPHA_FORMAT: u32 = 12424;
pub const EGL_VG_ALPHA_FORMAT_NONPRE: u32 = 12427;
pub const EGL_VG_ALPHA_FORMAT_PRE: u32 = 12428;
pub const EGL_VG_ALPHA_FORMAT_PRE_BIT: u32 = 64;
pub const EGL_VG_COLORSPACE: u32 = 12423;
pub const EGL_VG_COLORSPACE_sRGB: u32 = 12425;
pub const EGL_VG_COLORSPACE_LINEAR: u32 = 12426;
pub const EGL_VG_COLORSPACE_LINEAR_BIT: u32 = 32;
pub const EGL_VERSION_1_4: u32 = 1;
pub const EGL_MULTISAMPLE_RESOLVE_BOX_BIT: u32 = 512;
pub const EGL_MULTISAMPLE_RESOLVE: u32 = 12441;
pub const EGL_MULTISAMPLE_RESOLVE_DEFAULT: u32 = 12442;
pub const EGL_MULTISAMPLE_RESOLVE_BOX: u32 = 12443;
pub const EGL_OPENGL_API: u32 = 12450;
pub const EGL_OPENGL_BIT: u32 = 8;
pub const EGL_SWAP_BEHAVIOR_PRESERVED_BIT: u32 = 1024;
pub const EGL_VERSION_1_5: u32 = 1;
pub const EGL_CONTEXT_MAJOR_VERSION: u32 = 12440;
pub const EGL_CONTEXT_MINOR_VERSION: u32 = 12539;
pub const EGL_CONTEXT_OPENGL_PROFILE_MASK: u32 = 12541;
pub const EGL_CONTEXT_OPENGL_RESET_NOTIFICATION_STRATEGY: u32 = 12733;
pub const EGL_NO_RESET_NOTIFICATION: u32 = 12734;
pub const EGL_LOSE_CONTEXT_ON_RESET: u32 = 12735;
pub const EGL_CONTEXT_OPENGL_CORE_PROFILE_BIT: u32 = 1;
pub const EGL_CONTEXT_OPENGL_COMPATIBILITY_PROFILE_BIT: u32 = 2;
pub const EGL_CONTEXT_OPENGL_DEBUG: u32 = 12720;
pub const EGL_CONTEXT_OPENGL_FORWARD_COMPATIBLE: u32 = 12721;
pub const EGL_CONTEXT_OPENGL_ROBUST_ACCESS: u32 = 12722;
pub const EGL_OPENGL_ES3_BIT: u32 = 64;
pub const EGL_CL_EVENT_HANDLE: u32 = 12444;
pub const EGL_SYNC_CL_EVENT: u32 = 12542;
pub const EGL_SYNC_CL_EVENT_COMPLETE: u32 = 12543;
pub const EGL_SYNC_PRIOR_COMMANDS_COMPLETE: u32 = 12528;
pub const EGL_SYNC_TYPE: u32 = 12535;
pub const EGL_SYNC_STATUS: u32 = 12529;
pub const EGL_SYNC_CONDITION: u32 = 12536;
pub const EGL_SIGNALED: u32 = 12530;
pub const EGL_UNSIGNALED: u32 = 12531;
pub const EGL_SYNC_FLUSH_COMMANDS_BIT: u32 = 1;
pub const EGL_FOREVER: i32 = -1;
pub const EGL_TIMEOUT_EXPIRED: u32 = 12533;
pub const EGL_CONDITION_SATISFIED: u32 = 12534;
pub const EGL_SYNC_FENCE: u32 = 12537;
pub const EGL_GL_COLORSPACE: u32 = 12445;
pub const EGL_GL_COLORSPACE_SRGB: u32 = 12425;
pub const EGL_GL_COLORSPACE_LINEAR: u32 = 12426;
pub const EGL_GL_RENDERBUFFER: u32 = 12473;
pub const EGL_GL_TEXTURE_2D: u32 = 12465;
pub const EGL_GL_TEXTURE_LEVEL: u32 = 12476;
pub const EGL_GL_TEXTURE_3D: u32 = 12466;
pub const EGL_GL_TEXTURE_ZOFFSET: u32 = 12477;
pub const EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_X: u32 = 12467;
pub const EGL_GL_TEXTURE_CUBE_MAP_NEGATIVE_X: u32 = 12468;
pub const EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_Y: u32 = 12469;
pub const EGL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Y: u32 = 12470;
pub const EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_Z: u32 = 12471;
pub const EGL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Z: u32 = 12472;
pub const EGL_IMAGE_PRESERVED: u32 = 12498;
pub const __eglext_h_: u32 = 1;
pub const EGL_EGLEXT_VERSION: u32 = 20190124;
pub const EGL_KHR_cl_event: u32 = 1;
pub const EGL_CL_EVENT_HANDLE_KHR: u32 = 12444;
pub const EGL_SYNC_CL_EVENT_KHR: u32 = 12542;
pub const EGL_SYNC_CL_EVENT_COMPLETE_KHR: u32 = 12543;
pub const EGL_KHR_cl_event2: u32 = 1;
pub const EGL_KHR_client_get_all_proc_addresses: u32 = 1;
pub const EGL_KHR_config_attribs: u32 = 1;
pub const EGL_CONFORMANT_KHR: u32 = 12354;
pub const EGL_VG_COLORSPACE_LINEAR_BIT_KHR: u32 = 32;
pub const EGL_VG_ALPHA_FORMAT_PRE_BIT_KHR: u32 = 64;
pub const EGL_KHR_context_flush_control: u32 = 1;
pub const EGL_CONTEXT_RELEASE_BEHAVIOR_NONE_KHR: u32 = 0;
pub const EGL_CONTEXT_RELEASE_BEHAVIOR_KHR: u32 = 8343;
pub const EGL_CONTEXT_RELEASE_BEHAVIOR_FLUSH_KHR: u32 = 8344;
pub const EGL_KHR_create_context: u32 = 1;
pub const EGL_CONTEXT_MAJOR_VERSION_KHR: u32 = 12440;
pub const EGL_CONTEXT_MINOR_VERSION_KHR: u32 = 12539;
pub const EGL_CONTEXT_FLAGS_KHR: u32 = 12540;
pub const EGL_CONTEXT_OPENGL_PROFILE_MASK_KHR: u32 = 12541;
pub const EGL_CONTEXT_OPENGL_RESET_NOTIFICATION_STRATEGY_KHR: u32 = 12733;
pub const EGL_NO_RESET_NOTIFICATION_KHR: u32 = 12734;
pub const EGL_LOSE_CONTEXT_ON_RESET_KHR: u32 = 12735;
pub const EGL_CONTEXT_OPENGL_DEBUG_BIT_KHR: u32 = 1;
pub const EGL_CONTEXT_OPENGL_FORWARD_COMPATIBLE_BIT_KHR: u32 = 2;
pub const EGL_CONTEXT_OPENGL_ROBUST_ACCESS_BIT_KHR: u32 = 4;
pub const EGL_CONTEXT_OPENGL_CORE_PROFILE_BIT_KHR: u32 = 1;
pub const EGL_CONTEXT_OPENGL_COMPATIBILITY_PROFILE_BIT_KHR: u32 = 2;
pub const EGL_OPENGL_ES3_BIT_KHR: u32 = 64;
pub const EGL_KHR_create_context_no_error: u32 = 1;
pub const EGL_CONTEXT_OPENGL_NO_ERROR_KHR: u32 = 12723;
pub const EGL_KHR_debug: u32 = 1;
pub const EGL_OBJECT_THREAD_KHR: u32 = 13232;
pub const EGL_OBJECT_DISPLAY_KHR: u32 = 13233;
pub const EGL_OBJECT_CONTEXT_KHR: u32 = 13234;
pub const EGL_OBJECT_SURFACE_KHR: u32 = 13235;
pub const EGL_OBJECT_IMAGE_KHR: u32 = 13236;
pub const EGL_OBJECT_SYNC_KHR: u32 = 13237;
pub const EGL_OBJECT_STREAM_KHR: u32 = 13238;
pub const EGL_DEBUG_MSG_CRITICAL_KHR: u32 = 13241;
pub const EGL_DEBUG_MSG_ERROR_KHR: u32 = 13242;
pub const EGL_DEBUG_MSG_WARN_KHR: u32 = 13243;
pub const EGL_DEBUG_MSG_INFO_KHR: u32 = 13244;
pub const EGL_DEBUG_CALLBACK_KHR: u32 = 13240;
pub const EGL_KHR_display_reference: u32 = 1;
pub const EGL_TRACK_REFERENCES_KHR: u32 = 13138;
pub const EGL_KHR_fence_sync: u32 = 1;
pub const EGL_SYNC_PRIOR_COMMANDS_COMPLETE_KHR: u32 = 12528;
pub const EGL_SYNC_CONDITION_KHR: u32 = 12536;
pub const EGL_SYNC_FENCE_KHR: u32 = 12537;
pub const EGL_KHR_get_all_proc_addresses: u32 = 1;
pub const EGL_KHR_gl_colorspace: u32 = 1;
pub const EGL_GL_COLORSPACE_KHR: u32 = 12445;
pub const EGL_GL_COLORSPACE_SRGB_KHR: u32 = 12425;
pub const EGL_GL_COLORSPACE_LINEAR_KHR: u32 = 12426;
pub const EGL_KHR_gl_renderbuffer_image: u32 = 1;
pub const EGL_GL_RENDERBUFFER_KHR: u32 = 12473;
pub const EGL_KHR_gl_texture_2D_image: u32 = 1;
pub const EGL_GL_TEXTURE_2D_KHR: u32 = 12465;
pub const EGL_GL_TEXTURE_LEVEL_KHR: u32 = 12476;
pub const EGL_KHR_gl_texture_3D_image: u32 = 1;
pub const EGL_GL_TEXTURE_3D_KHR: u32 = 12466;
pub const EGL_GL_TEXTURE_ZOFFSET_KHR: u32 = 12477;
pub const EGL_KHR_gl_texture_cubemap_image: u32 = 1;
pub const EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_X_KHR: u32 = 12467;
pub const EGL_GL_TEXTURE_CUBE_MAP_NEGATIVE_X_KHR: u32 = 12468;
pub const EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_Y_KHR: u32 = 12469;
pub const EGL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_KHR: u32 = 12470;
pub const EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_Z_KHR: u32 = 12471;
pub const EGL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_KHR: u32 = 12472;
pub const EGL_KHR_image: u32 = 1;
pub const EGL_NATIVE_PIXMAP_KHR: u32 = 12464;
pub const EGL_KHR_image_base: u32 = 1;
pub const EGL_IMAGE_PRESERVED_KHR: u32 = 12498;
pub const EGL_KHR_image_pixmap: u32 = 1;
pub const EGL_KHR_lock_surface: u32 = 1;
pub const EGL_READ_SURFACE_BIT_KHR: u32 = 1;
pub const EGL_WRITE_SURFACE_BIT_KHR: u32 = 2;
pub const EGL_LOCK_SURFACE_BIT_KHR: u32 = 128;
pub const EGL_OPTIMAL_FORMAT_BIT_KHR: u32 = 256;
pub const EGL_MATCH_FORMAT_KHR: u32 = 12355;
pub const EGL_FORMAT_RGB_565_EXACT_KHR: u32 = 12480;
pub const EGL_FORMAT_RGB_565_KHR: u32 = 12481;
pub const EGL_FORMAT_RGBA_8888_EXACT_KHR: u32 = 12482;
pub const EGL_FORMAT_RGBA_8888_KHR: u32 = 12483;
pub const EGL_MAP_PRESERVE_PIXELS_KHR: u32 = 12484;
pub const EGL_LOCK_USAGE_HINT_KHR: u32 = 12485;
pub const EGL_BITMAP_POINTER_KHR: u32 = 12486;
pub const EGL_BITMAP_PITCH_KHR: u32 = 12487;
pub const EGL_BITMAP_ORIGIN_KHR: u32 = 12488;
pub const EGL_BITMAP_PIXEL_RED_OFFSET_KHR: u32 = 12489;
pub const EGL_BITMAP_PIXEL_GREEN_OFFSET_KHR: u32 = 12490;
pub const EGL_BITMAP_PIXEL_BLUE_OFFSET_KHR: u32 = 12491;
pub const EGL_BITMAP_PIXEL_ALPHA_OFFSET_KHR: u32 = 12492;
pub const EGL_BITMAP_PIXEL_LUMINANCE_OFFSET_KHR: u32 = 12493;
pub const EGL_LOWER_LEFT_KHR: u32 = 12494;
pub const EGL_UPPER_LEFT_KHR: u32 = 12495;
pub const EGL_KHR_lock_surface2: u32 = 1;
pub const EGL_BITMAP_PIXEL_SIZE_KHR: u32 = 12560;
pub const EGL_KHR_lock_surface3: u32 = 1;
pub const EGL_KHR_mutable_render_buffer: u32 = 1;
pub const EGL_MUTABLE_RENDER_BUFFER_BIT_KHR: u32 = 4096;
pub const EGL_KHR_no_config_context: u32 = 1;
pub const EGL_KHR_partial_update: u32 = 1;
pub const EGL_BUFFER_AGE_KHR: u32 = 12605;
pub const EGL_KHR_platform_android: u32 = 1;
pub const EGL_PLATFORM_ANDROID_KHR: u32 = 12609;
pub const EGL_KHR_platform_gbm: u32 = 1;
pub const EGL_PLATFORM_GBM_KHR: u32 = 12759;
pub const EGL_KHR_platform_wayland: u32 = 1;
pub const EGL_PLATFORM_WAYLAND_KHR: u32 = 12760;
pub const EGL_KHR_platform_x11: u32 = 1;
pub const EGL_PLATFORM_X11_KHR: u32 = 12757;
pub const EGL_PLATFORM_X11_SCREEN_KHR: u32 = 12758;
pub const EGL_KHR_reusable_sync: u32 = 1;
pub const EGL_SYNC_STATUS_KHR: u32 = 12529;
pub const EGL_SIGNALED_KHR: u32 = 12530;
pub const EGL_UNSIGNALED_KHR: u32 = 12531;
pub const EGL_TIMEOUT_EXPIRED_KHR: u32 = 12533;
pub const EGL_CONDITION_SATISFIED_KHR: u32 = 12534;
pub const EGL_SYNC_TYPE_KHR: u32 = 12535;
pub const EGL_SYNC_REUSABLE_KHR: u32 = 12538;
pub const EGL_SYNC_FLUSH_COMMANDS_BIT_KHR: u32 = 1;
pub const EGL_FOREVER_KHR: i32 = -1;
pub const EGL_KHR_stream: u32 = 1;
pub const EGL_CONSUMER_LATENCY_USEC_KHR: u32 = 12816;
pub const EGL_PRODUCER_FRAME_KHR: u32 = 12818;
pub const EGL_CONSUMER_FRAME_KHR: u32 = 12819;
pub const EGL_STREAM_STATE_KHR: u32 = 12820;
pub const EGL_STREAM_STATE_CREATED_KHR: u32 = 12821;
pub const EGL_STREAM_STATE_CONNECTING_KHR: u32 = 12822;
pub const EGL_STREAM_STATE_EMPTY_KHR: u32 = 12823;
pub const EGL_STREAM_STATE_NEW_FRAME_AVAILABLE_KHR: u32 = 12824;
pub const EGL_STREAM_STATE_OLD_FRAME_AVAILABLE_KHR: u32 = 12825;
pub const EGL_STREAM_STATE_DISCONNECTED_KHR: u32 = 12826;
pub const EGL_BAD_STREAM_KHR: u32 = 12827;
pub const EGL_BAD_STATE_KHR: u32 = 12828;
pub const EGL_KHR_stream_attrib: u32 = 1;
pub const EGL_KHR_stream_consumer_gltexture: u32 = 1;
pub const EGL_CONSUMER_ACQUIRE_TIMEOUT_USEC_KHR: u32 = 12830;
pub const EGL_KHR_stream_cross_process_fd: u32 = 1;
pub const EGL_KHR_stream_fifo: u32 = 1;
pub const EGL_STREAM_FIFO_LENGTH_KHR: u32 = 12796;
pub const EGL_STREAM_TIME_NOW_KHR: u32 = 12797;
pub const EGL_STREAM_TIME_CONSUMER_KHR: u32 = 12798;
pub const EGL_STREAM_TIME_PRODUCER_KHR: u32 = 12799;
pub const EGL_KHR_stream_producer_aldatalocator: u32 = 1;
pub const EGL_KHR_stream_producer_eglsurface: u32 = 1;
pub const EGL_STREAM_BIT_KHR: u32 = 2048;
pub const EGL_KHR_surfaceless_context: u32 = 1;
pub const EGL_KHR_swap_buffers_with_damage: u32 = 1;
pub const EGL_KHR_vg_parent_image: u32 = 1;
pub const EGL_VG_PARENT_IMAGE_KHR: u32 = 12474;
pub const EGL_KHR_wait_sync: u32 = 1;
pub const EGL_ANDROID_blob_cache: u32 = 1;
pub const EGL_ANDROID_create_native_client_buffer: u32 = 1;
pub const EGL_NATIVE_BUFFER_USAGE_ANDROID: u32 = 12611;
pub const EGL_NATIVE_BUFFER_USAGE_PROTECTED_BIT_ANDROID: u32 = 1;
pub const EGL_NATIVE_BUFFER_USAGE_RENDERBUFFER_BIT_ANDROID: u32 = 2;
pub const EGL_NATIVE_BUFFER_USAGE_TEXTURE_BIT_ANDROID: u32 = 4;
pub const EGL_ANDROID_framebuffer_target: u32 = 1;
pub const EGL_FRAMEBUFFER_TARGET_ANDROID: u32 = 12615;
pub const EGL_ANDROID_front_buffer_auto_refresh: u32 = 1;
pub const EGL_FRONT_BUFFER_AUTO_REFRESH_ANDROID: u32 = 12620;
pub const EGL_ANDROID_get_frame_timestamps: u32 = 1;
pub const EGL_TIMESTAMPS_ANDROID: u32 = 13360;
pub const EGL_COMPOSITE_DEADLINE_ANDROID: u32 = 13361;
pub const EGL_COMPOSITE_INTERVAL_ANDROID: u32 = 13362;
pub const EGL_COMPOSITE_TO_PRESENT_LATENCY_ANDROID: u32 = 13363;
pub const EGL_REQUESTED_PRESENT_TIME_ANDROID: u32 = 13364;
pub const EGL_RENDERING_COMPLETE_TIME_ANDROID: u32 = 13365;
pub const EGL_COMPOSITION_LATCH_TIME_ANDROID: u32 = 13366;
pub const EGL_FIRST_COMPOSITION_START_TIME_ANDROID: u32 = 13367;
pub const EGL_LAST_COMPOSITION_START_TIME_ANDROID: u32 = 13368;
pub const EGL_FIRST_COMPOSITION_GPU_FINISHED_TIME_ANDROID: u32 = 13369;
pub const EGL_DISPLAY_PRESENT_TIME_ANDROID: u32 = 13370;
pub const EGL_DEQUEUE_READY_TIME_ANDROID: u32 = 13371;
pub const EGL_READS_DONE_TIME_ANDROID: u32 = 13372;
pub const EGL_ANDROID_get_native_client_buffer: u32 = 1;
pub const EGL_ANDROID_image_native_buffer: u32 = 1;
pub const EGL_NATIVE_BUFFER_ANDROID: u32 = 12608;
pub const EGL_ANDROID_native_fence_sync: u32 = 1;
pub const EGL_SYNC_NATIVE_FENCE_ANDROID: u32 = 12612;
pub const EGL_SYNC_NATIVE_FENCE_FD_ANDROID: u32 = 12613;
pub const EGL_SYNC_NATIVE_FENCE_SIGNALED_ANDROID: u32 = 12614;
pub const EGL_NO_NATIVE_FENCE_FD_ANDROID: i32 = -1;
pub const EGL_ANDROID_presentation_time: u32 = 1;
pub const EGL_ANDROID_recordable: u32 = 1;
pub const EGL_RECORDABLE_ANDROID: u32 = 12610;
pub const EGL_ANGLE_d3d_share_handle_client_buffer: u32 = 1;
pub const EGL_D3D_TEXTURE_2D_SHARE_HANDLE_ANGLE: u32 = 12800;
pub const EGL_ANGLE_device_d3d: u32 = 1;
pub const EGL_D3D9_DEVICE_ANGLE: u32 = 13216;
pub const EGL_D3D11_DEVICE_ANGLE: u32 = 13217;
pub const EGL_ANGLE_query_surface_pointer: u32 = 1;
pub const EGL_ANGLE_surface_d3d_texture_2d_share_handle: u32 = 1;
pub const EGL_ANGLE_window_fixed_size: u32 = 1;
pub const EGL_FIXED_SIZE_ANGLE: u32 = 12801;
pub const EGL_ARM_implicit_external_sync: u32 = 1;
pub const EGL_SYNC_PRIOR_COMMANDS_IMPLICIT_EXTERNAL_ARM: u32 = 12938;
pub const EGL_ARM_pixmap_multisample_discard: u32 = 1;
pub const EGL_DISCARD_SAMPLES_ARM: u32 = 12934;
pub const EGL_EXT_bind_to_front: u32 = 1;
pub const EGL_FRONT_BUFFER_EXT: u32 = 13412;
pub const EGL_EXT_buffer_age: u32 = 1;
pub const EGL_BUFFER_AGE_EXT: u32 = 12605;
pub const EGL_EXT_client_extensions: u32 = 1;
pub const EGL_EXT_client_sync: u32 = 1;
pub const EGL_SYNC_CLIENT_EXT: u32 = 13156;
pub const EGL_SYNC_CLIENT_SIGNAL_EXT: u32 = 13157;
pub const EGL_EXT_compositor: u32 = 1;
pub const EGL_PRIMARY_COMPOSITOR_CONTEXT_EXT: u32 = 13408;
pub const EGL_EXTERNAL_REF_ID_EXT: u32 = 13409;
pub const EGL_COMPOSITOR_DROP_NEWEST_FRAME_EXT: u32 = 13410;
pub const EGL_COMPOSITOR_KEEP_NEWEST_FRAME_EXT: u32 = 13411;
pub const EGL_EXT_create_context_robustness: u32 = 1;
pub const EGL_CONTEXT_OPENGL_ROBUST_ACCESS_EXT: u32 = 12479;
pub const EGL_CONTEXT_OPENGL_RESET_NOTIFICATION_STRATEGY_EXT: u32 = 12600;
pub const EGL_NO_RESET_NOTIFICATION_EXT: u32 = 12734;
pub const EGL_LOSE_CONTEXT_ON_RESET_EXT: u32 = 12735;
pub const EGL_EXT_device_base: u32 = 1;
pub const EGL_BAD_DEVICE_EXT: u32 = 12843;
pub const EGL_DEVICE_EXT: u32 = 12844;
pub const EGL_EXT_device_drm: u32 = 1;
pub const EGL_DRM_DEVICE_FILE_EXT: u32 = 12851;
pub const EGL_DRM_MASTER_FD_EXT: u32 = 13116;
pub const EGL_EXT_device_enumeration: u32 = 1;
pub const EGL_EXT_device_openwf: u32 = 1;
pub const EGL_OPENWF_DEVICE_ID_EXT: u32 = 12855;
pub const EGL_EXT_device_query: u32 = 1;
pub const EGL_EXT_gl_colorspace_bt2020_linear: u32 = 1;
pub const EGL_GL_COLORSPACE_BT2020_LINEAR_EXT: u32 = 13119;
pub const EGL_EXT_gl_colorspace_bt2020_pq: u32 = 1;
pub const EGL_GL_COLORSPACE_BT2020_PQ_EXT: u32 = 13120;
pub const EGL_EXT_gl_colorspace_display_p3: u32 = 1;
pub const EGL_GL_COLORSPACE_DISPLAY_P3_EXT: u32 = 13155;
pub const EGL_EXT_gl_colorspace_display_p3_linear: u32 = 1;
pub const EGL_GL_COLORSPACE_DISPLAY_P3_LINEAR_EXT: u32 = 13154;
pub const EGL_EXT_gl_colorspace_display_p3_passthrough: u32 = 1;
pub const EGL_GL_COLORSPACE_DISPLAY_P3_PASSTHROUGH_EXT: u32 = 13456;
pub const EGL_EXT_gl_colorspace_scrgb: u32 = 1;
pub const EGL_GL_COLORSPACE_SCRGB_EXT: u32 = 13137;
pub const EGL_EXT_gl_colorspace_scrgb_linear: u32 = 1;
pub const EGL_GL_COLORSPACE_SCRGB_LINEAR_EXT: u32 = 13136;
pub const EGL_EXT_image_dma_buf_import: u32 = 1;
pub const EGL_LINUX_DMA_BUF_EXT: u32 = 12912;
pub const EGL_LINUX_DRM_FOURCC_EXT: u32 = 12913;
pub const EGL_DMA_BUF_PLANE0_FD_EXT: u32 = 12914;
pub const EGL_DMA_BUF_PLANE0_OFFSET_EXT: u32 = 12915;
pub const EGL_DMA_BUF_PLANE0_PITCH_EXT: u32 = 12916;
pub const EGL_DMA_BUF_PLANE1_FD_EXT: u32 = 12917;
pub const EGL_DMA_BUF_PLANE1_OFFSET_EXT: u32 = 12918;
pub const EGL_DMA_BUF_PLANE1_PITCH_EXT: u32 = 12919;
pub const EGL_DMA_BUF_PLANE2_FD_EXT: u32 = 12920;
pub const EGL_DMA_BUF_PLANE2_OFFSET_EXT: u32 = 12921;
pub const EGL_DMA_BUF_PLANE2_PITCH_EXT: u32 = 12922;
pub const EGL_YUV_COLOR_SPACE_HINT_EXT: u32 = 12923;
pub const EGL_SAMPLE_RANGE_HINT_EXT: u32 = 12924;
pub const EGL_YUV_CHROMA_HORIZONTAL_SITING_HINT_EXT: u32 = 12925;
pub const EGL_YUV_CHROMA_VERTICAL_SITING_HINT_EXT: u32 = 12926;
pub const EGL_ITU_REC601_EXT: u32 = 12927;
pub const EGL_ITU_REC709_EXT: u32 = 12928;
pub const EGL_ITU_REC2020_EXT: u32 = 12929;
pub const EGL_YUV_FULL_RANGE_EXT: u32 = 12930;
pub const EGL_YUV_NARROW_RANGE_EXT: u32 = 12931;
pub const EGL_YUV_CHROMA_SITING_0_EXT: u32 = 12932;
pub const EGL_YUV_CHROMA_SITING_0_5_EXT: u32 = 12933;
pub const EGL_EXT_image_dma_buf_import_modifiers: u32 = 1;
pub const EGL_DMA_BUF_PLANE3_FD_EXT: u32 = 13376;
pub const EGL_DMA_BUF_PLANE3_OFFSET_EXT: u32 = 13377;
pub const EGL_DMA_BUF_PLANE3_PITCH_EXT: u32 = 13378;
pub const EGL_DMA_BUF_PLANE0_MODIFIER_LO_EXT: u32 = 13379;
pub const EGL_DMA_BUF_PLANE0_MODIFIER_HI_EXT: u32 = 13380;
pub const EGL_DMA_BUF_PLANE1_MODIFIER_LO_EXT: u32 = 13381;
pub const EGL_DMA_BUF_PLANE1_MODIFIER_HI_EXT: u32 = 13382;
pub const EGL_DMA_BUF_PLANE2_MODIFIER_LO_EXT: u32 = 13383;
pub const EGL_DMA_BUF_PLANE2_MODIFIER_HI_EXT: u32 = 13384;
pub const EGL_DMA_BUF_PLANE3_MODIFIER_LO_EXT: u32 = 13385;
pub const EGL_DMA_BUF_PLANE3_MODIFIER_HI_EXT: u32 = 13386;
pub const EGL_EXT_image_gl_colorspace: u32 = 1;
pub const EGL_GL_COLORSPACE_DEFAULT_EXT: u32 = 12621;
pub const EGL_EXT_image_implicit_sync_control: u32 = 1;
pub const EGL_IMPORT_SYNC_TYPE_EXT: u32 = 13424;
pub const EGL_IMPORT_IMPLICIT_SYNC_EXT: u32 = 13425;
pub const EGL_IMPORT_EXPLICIT_SYNC_EXT: u32 = 13426;
pub const EGL_EXT_multiview_window: u32 = 1;
pub const EGL_MULTIVIEW_VIEW_COUNT_EXT: u32 = 12596;
pub const EGL_EXT_output_base: u32 = 1;
pub const EGL_BAD_OUTPUT_LAYER_EXT: u32 = 12845;
pub const EGL_BAD_OUTPUT_PORT_EXT: u32 = 12846;
pub const EGL_SWAP_INTERVAL_EXT: u32 = 12847;
pub const EGL_EXT_output_drm: u32 = 1;
pub const EGL_DRM_CRTC_EXT: u32 = 12852;
pub const EGL_DRM_PLANE_EXT: u32 = 12853;
pub const EGL_DRM_CONNECTOR_EXT: u32 = 12854;
pub const EGL_EXT_output_openwf: u32 = 1;
pub const EGL_OPENWF_PIPELINE_ID_EXT: u32 = 12856;
pub const EGL_OPENWF_PORT_ID_EXT: u32 = 12857;
pub const EGL_EXT_pixel_format_float: u32 = 1;
pub const EGL_COLOR_COMPONENT_TYPE_EXT: u32 = 13113;
pub const EGL_COLOR_COMPONENT_TYPE_FIXED_EXT: u32 = 13114;
pub const EGL_COLOR_COMPONENT_TYPE_FLOAT_EXT: u32 = 13115;
pub const EGL_EXT_platform_base: u32 = 1;
pub const EGL_EXT_platform_device: u32 = 1;
pub const EGL_PLATFORM_DEVICE_EXT: u32 = 12607;
pub const EGL_EXT_platform_wayland: u32 = 1;
pub const EGL_PLATFORM_WAYLAND_EXT: u32 = 12760;
pub const EGL_EXT_platform_x11: u32 = 1;
pub const EGL_PLATFORM_X11_EXT: u32 = 12757;
pub const EGL_PLATFORM_X11_SCREEN_EXT: u32 = 12758;
pub const EGL_EXT_protected_content: u32 = 1;
pub const EGL_PROTECTED_CONTENT_EXT: u32 = 12992;
pub const EGL_EXT_protected_surface: u32 = 1;
pub const EGL_EXT_stream_consumer_egloutput: u32 = 1;
pub const EGL_EXT_surface_CTA861_3_metadata: u32 = 1;
pub const EGL_CTA861_3_MAX_CONTENT_LIGHT_LEVEL_EXT: u32 = 13152;
pub const EGL_CTA861_3_MAX_FRAME_AVERAGE_LEVEL_EXT: u32 = 13153;
pub const EGL_EXT_surface_SMPTE2086_metadata: u32 = 1;
pub const EGL_SMPTE2086_DISPLAY_PRIMARY_RX_EXT: u32 = 13121;
pub const EGL_SMPTE2086_DISPLAY_PRIMARY_RY_EXT: u32 = 13122;
pub const EGL_SMPTE2086_DISPLAY_PRIMARY_GX_EXT: u32 = 13123;
pub const EGL_SMPTE2086_DISPLAY_PRIMARY_GY_EXT: u32 = 13124;
pub const EGL_SMPTE2086_DISPLAY_PRIMARY_BX_EXT: u32 = 13125;
pub const EGL_SMPTE2086_DISPLAY_PRIMARY_BY_EXT: u32 = 13126;
pub const EGL_SMPTE2086_WHITE_POINT_X_EXT: u32 = 13127;
pub const EGL_SMPTE2086_WHITE_POINT_Y_EXT: u32 = 13128;
pub const EGL_SMPTE2086_MAX_LUMINANCE_EXT: u32 = 13129;
pub const EGL_SMPTE2086_MIN_LUMINANCE_EXT: u32 = 13130;
pub const EGL_METADATA_SCALING_EXT: u32 = 50000;
pub const EGL_EXT_swap_buffers_with_damage: u32 = 1;
pub const EGL_EXT_sync_reuse: u32 = 1;
pub const EGL_EXT_yuv_surface: u32 = 1;
pub const EGL_YUV_ORDER_EXT: u32 = 13057;
pub const EGL_YUV_NUMBER_OF_PLANES_EXT: u32 = 13073;
pub const EGL_YUV_SUBSAMPLE_EXT: u32 = 13074;
pub const EGL_YUV_DEPTH_RANGE_EXT: u32 = 13079;
pub const EGL_YUV_CSC_STANDARD_EXT: u32 = 13066;
pub const EGL_YUV_PLANE_BPP_EXT: u32 = 13082;
pub const EGL_YUV_BUFFER_EXT: u32 = 13056;
pub const EGL_YUV_ORDER_YUV_EXT: u32 = 13058;
pub const EGL_YUV_ORDER_YVU_EXT: u32 = 13059;
pub const EGL_YUV_ORDER_YUYV_EXT: u32 = 13060;
pub const EGL_YUV_ORDER_UYVY_EXT: u32 = 13061;
pub const EGL_YUV_ORDER_YVYU_EXT: u32 = 13062;
pub const EGL_YUV_ORDER_VYUY_EXT: u32 = 13063;
pub const EGL_YUV_ORDER_AYUV_EXT: u32 = 13064;
pub const EGL_YUV_SUBSAMPLE_4_2_0_EXT: u32 = 13075;
pub const EGL_YUV_SUBSAMPLE_4_2_2_EXT: u32 = 13076;
pub const EGL_YUV_SUBSAMPLE_4_4_4_EXT: u32 = 13077;
pub const EGL_YUV_DEPTH_RANGE_LIMITED_EXT: u32 = 13080;
pub const EGL_YUV_DEPTH_RANGE_FULL_EXT: u32 = 13081;
pub const EGL_YUV_CSC_STANDARD_601_EXT: u32 = 13067;
pub const EGL_YUV_CSC_STANDARD_709_EXT: u32 = 13068;
pub const EGL_YUV_CSC_STANDARD_2020_EXT: u32 = 13069;
pub const EGL_YUV_PLANE_BPP_0_EXT: u32 = 13083;
pub const EGL_YUV_PLANE_BPP_8_EXT: u32 = 13084;
pub const EGL_YUV_PLANE_BPP_10_EXT: u32 = 13085;
pub const EGL_HI_clientpixmap: u32 = 1;
pub const EGL_CLIENT_PIXMAP_POINTER_HI: u32 = 36724;
pub const EGL_HI_colorformats: u32 = 1;
pub const EGL_COLOR_FORMAT_HI: u32 = 36720;
pub const EGL_COLOR_RGB_HI: u32 = 36721;
pub const EGL_COLOR_RGBA_HI: u32 = 36722;
pub const EGL_COLOR_ARGB_HI: u32 = 36723;
pub const EGL_IMG_context_priority: u32 = 1;
pub const EGL_CONTEXT_PRIORITY_LEVEL_IMG: u32 = 12544;
pub const EGL_CONTEXT_PRIORITY_HIGH_IMG: u32 = 12545;
pub const EGL_CONTEXT_PRIORITY_MEDIUM_IMG: u32 = 12546;
pub const EGL_CONTEXT_PRIORITY_LOW_IMG: u32 = 12547;
pub const EGL_IMG_image_plane_attribs: u32 = 1;
pub const EGL_NATIVE_BUFFER_MULTIPLANE_SEPARATE_IMG: u32 = 12549;
pub const EGL_NATIVE_BUFFER_PLANE_OFFSET_IMG: u32 = 12550;
pub const EGL_MESA_drm_image: u32 = 1;
pub const EGL_DRM_BUFFER_FORMAT_MESA: u32 = 12752;
pub const EGL_DRM_BUFFER_USE_MESA: u32 = 12753;
pub const EGL_DRM_BUFFER_FORMAT_ARGB32_MESA: u32 = 12754;
pub const EGL_DRM_BUFFER_MESA: u32 = 12755;
pub const EGL_DRM_BUFFER_STRIDE_MESA: u32 = 12756;
pub const EGL_DRM_BUFFER_USE_SCANOUT_MESA: u32 = 1;
pub const EGL_DRM_BUFFER_USE_SHARE_MESA: u32 = 2;
pub const EGL_DRM_BUFFER_USE_CURSOR_MESA: u32 = 4;
pub const EGL_MESA_image_dma_buf_export: u32 = 1;
pub const EGL_MESA_platform_gbm: u32 = 1;
pub const EGL_PLATFORM_GBM_MESA: u32 = 12759;
pub const EGL_MESA_platform_surfaceless: u32 = 1;
pub const EGL_PLATFORM_SURFACELESS_MESA: u32 = 12765;
pub const EGL_MESA_query_driver: u32 = 1;
pub const EGL_NOK_swap_region: u32 = 1;
pub const EGL_NOK_swap_region2: u32 = 1;
pub const EGL_NOK_texture_from_pixmap: u32 = 1;
pub const EGL_Y_INVERTED_NOK: u32 = 12415;
pub const EGL_NV_3dvision_surface: u32 = 1;
pub const EGL_AUTO_STEREO_NV: u32 = 12598;
pub const EGL_NV_context_priority_realtime: u32 = 1;
pub const EGL_CONTEXT_PRIORITY_REALTIME_NV: u32 = 13143;
pub const EGL_NV_coverage_sample: u32 = 1;
pub const EGL_COVERAGE_BUFFERS_NV: u32 = 12512;
pub const EGL_COVERAGE_SAMPLES_NV: u32 = 12513;
pub const EGL_NV_coverage_sample_resolve: u32 = 1;
pub const EGL_COVERAGE_SAMPLE_RESOLVE_NV: u32 = 12593;
pub const EGL_COVERAGE_SAMPLE_RESOLVE_DEFAULT_NV: u32 = 12594;
pub const EGL_COVERAGE_SAMPLE_RESOLVE_NONE_NV: u32 = 12595;
pub const EGL_NV_cuda_event: u32 = 1;
pub const EGL_CUDA_EVENT_HANDLE_NV: u32 = 12859;
pub const EGL_SYNC_CUDA_EVENT_NV: u32 = 12860;
pub const EGL_SYNC_CUDA_EVENT_COMPLETE_NV: u32 = 12861;
pub const EGL_NV_depth_nonlinear: u32 = 1;
pub const EGL_DEPTH_ENCODING_NV: u32 = 12514;
pub const EGL_DEPTH_ENCODING_NONE_NV: u32 = 0;
pub const EGL_DEPTH_ENCODING_NONLINEAR_NV: u32 = 12515;
pub const EGL_NV_device_cuda: u32 = 1;
pub const EGL_CUDA_DEVICE_NV: u32 = 12858;
pub const EGL_NV_native_query: u32 = 1;
pub const EGL_NV_post_convert_rounding: u32 = 1;
pub const EGL_NV_post_sub_buffer: u32 = 1;
pub const EGL_POST_SUB_BUFFER_SUPPORTED_NV: u32 = 12478;
pub const EGL_NV_robustness_video_memory_purge: u32 = 1;
pub const EGL_GENERATE_RESET_ON_VIDEO_MEMORY_PURGE_NV: u32 = 13132;
pub const EGL_NV_stream_consumer_gltexture_yuv: u32 = 1;
pub const EGL_YUV_PLANE0_TEXTURE_UNIT_NV: u32 = 13100;
pub const EGL_YUV_PLANE1_TEXTURE_UNIT_NV: u32 = 13101;
pub const EGL_YUV_PLANE2_TEXTURE_UNIT_NV: u32 = 13102;
pub const EGL_NV_stream_cross_display: u32 = 1;
pub const EGL_STREAM_CROSS_DISPLAY_NV: u32 = 13134;
pub const EGL_NV_stream_cross_object: u32 = 1;
pub const EGL_STREAM_CROSS_OBJECT_NV: u32 = 13133;
pub const EGL_NV_stream_cross_partition: u32 = 1;
pub const EGL_STREAM_CROSS_PARTITION_NV: u32 = 12863;
pub const EGL_NV_stream_cross_process: u32 = 1;
pub const EGL_STREAM_CROSS_PROCESS_NV: u32 = 12869;
pub const EGL_NV_stream_cross_system: u32 = 1;
pub const EGL_STREAM_CROSS_SYSTEM_NV: u32 = 13135;
pub const EGL_NV_stream_fifo_next: u32 = 1;
pub const EGL_PENDING_FRAME_NV: u32 = 13097;
pub const EGL_STREAM_TIME_PENDING_NV: u32 = 13098;
pub const EGL_NV_stream_fifo_synchronous: u32 = 1;
pub const EGL_STREAM_FIFO_SYNCHRONOUS_NV: u32 = 13110;
pub const EGL_NV_stream_flush: u32 = 1;
pub const EGL_NV_stream_frame_limits: u32 = 1;
pub const EGL_PRODUCER_MAX_FRAME_HINT_NV: u32 = 13111;
pub const EGL_CONSUMER_MAX_FRAME_HINT_NV: u32 = 13112;
pub const EGL_NV_stream_metadata: u32 = 1;
pub const EGL_MAX_STREAM_METADATA_BLOCKS_NV: u32 = 12880;
pub const EGL_MAX_STREAM_METADATA_BLOCK_SIZE_NV: u32 = 12881;
pub const EGL_MAX_STREAM_METADATA_TOTAL_SIZE_NV: u32 = 12882;
pub const EGL_PRODUCER_METADATA_NV: u32 = 12883;
pub const EGL_CONSUMER_METADATA_NV: u32 = 12884;
pub const EGL_PENDING_METADATA_NV: u32 = 13096;
pub const EGL_METADATA0_SIZE_NV: u32 = 12885;
pub const EGL_METADATA1_SIZE_NV: u32 = 12886;
pub const EGL_METADATA2_SIZE_NV: u32 = 12887;
pub const EGL_METADATA3_SIZE_NV: u32 = 12888;
pub const EGL_METADATA0_TYPE_NV: u32 = 12889;
pub const EGL_METADATA1_TYPE_NV: u32 = 12890;
pub const EGL_METADATA2_TYPE_NV: u32 = 12891;
pub const EGL_METADATA3_TYPE_NV: u32 = 12892;
pub const EGL_NV_stream_remote: u32 = 1;
pub const EGL_STREAM_STATE_INITIALIZING_NV: u32 = 12864;
pub const EGL_STREAM_TYPE_NV: u32 = 12865;
pub const EGL_STREAM_PROTOCOL_NV: u32 = 12866;
pub const EGL_STREAM_ENDPOINT_NV: u32 = 12867;
pub const EGL_STREAM_LOCAL_NV: u32 = 12868;
pub const EGL_STREAM_PRODUCER_NV: u32 = 12871;
pub const EGL_STREAM_CONSUMER_NV: u32 = 12872;
pub const EGL_STREAM_PROTOCOL_FD_NV: u32 = 12870;
pub const EGL_NV_stream_reset: u32 = 1;
pub const EGL_SUPPORT_RESET_NV: u32 = 13108;
pub const EGL_SUPPORT_REUSE_NV: u32 = 13109;
pub const EGL_NV_stream_socket: u32 = 1;
pub const EGL_STREAM_PROTOCOL_SOCKET_NV: u32 = 12875;
pub const EGL_SOCKET_HANDLE_NV: u32 = 12876;
pub const EGL_SOCKET_TYPE_NV: u32 = 12877;
pub const EGL_NV_stream_socket_inet: u32 = 1;
pub const EGL_SOCKET_TYPE_INET_NV: u32 = 12879;
pub const EGL_NV_stream_socket_unix: u32 = 1;
pub const EGL_SOCKET_TYPE_UNIX_NV: u32 = 12878;
pub const EGL_NV_stream_sync: u32 = 1;
pub const EGL_SYNC_NEW_FRAME_NV: u32 = 12831;
pub const EGL_NV_sync: u32 = 1;
pub const EGL_SYNC_PRIOR_COMMANDS_COMPLETE_NV: u32 = 12518;
pub const EGL_SYNC_STATUS_NV: u32 = 12519;
pub const EGL_SIGNALED_NV: u32 = 12520;
pub const EGL_UNSIGNALED_NV: u32 = 12521;
pub const EGL_SYNC_FLUSH_COMMANDS_BIT_NV: u32 = 1;
pub const EGL_FOREVER_NV: i32 = -1;
pub const EGL_ALREADY_SIGNALED_NV: u32 = 12522;
pub const EGL_TIMEOUT_EXPIRED_NV: u32 = 12523;
pub const EGL_CONDITION_SATISFIED_NV: u32 = 12524;
pub const EGL_SYNC_TYPE_NV: u32 = 12525;
pub const EGL_SYNC_CONDITION_NV: u32 = 12526;
pub const EGL_SYNC_FENCE_NV: u32 = 12527;
pub const EGL_NV_system_time: u32 = 1;
pub const EGL_TIZEN_image_native_buffer: u32 = 1;
pub const EGL_NATIVE_BUFFER_TIZEN: u32 = 12960;
pub const EGL_TIZEN_image_native_surface: u32 = 1;
pub const EGL_NATIVE_SURFACE_TIZEN: u32 = 12961;
pub const EGL_WL_bind_wayland_display: u32 = 1;
pub const EGL_WAYLAND_BUFFER_WL: u32 = 12757;
pub const EGL_WAYLAND_PLANE_WL: u32 = 12758;
pub const EGL_WAYLAND_Y_INVERTED_WL: u32 = 12763;
pub const EGL_TEXTURE_Y_U_V_WL: u32 = 12759;
pub const EGL_TEXTURE_Y_UV_WL: u32 = 12760;
pub const EGL_TEXTURE_Y_XUXV_WL: u32 = 12761;
pub const EGL_TEXTURE_EXTERNAL_WL: u32 = 12762;
pub const EGL_WL_create_wayland_buffer_from_image: u32 = 1;
pub const EGL_MESA_configless_context: u32 = 1;
pub const EGL_MESA_drm_image_formats: u32 = 1;
pub const EGL_DRM_BUFFER_FORMAT_ARGB2101010_MESA: u32 = 12944;
pub const EGL_DRM_BUFFER_FORMAT_ARGB1555_MESA: u32 = 12945;
pub const EGL_DRM_BUFFER_FORMAT_RGB565_MESA: u32 = 12946;
pub const EGL_CHROMIUM_sync_control: u32 = 1;
pub const PIXMAN_VERSION_MAJOR: u32 = 0;
pub const PIXMAN_VERSION_MINOR: u32 = 36;
pub const PIXMAN_VERSION_MICRO: u32 = 0;
pub const PIXMAN_VERSION_STRING: &'static [u8; 7usize] = b"0.36.0\0";
pub const PIXMAN_MAX_INDEXED: u32 = 256;
pub const PIXMAN_TYPE_OTHER: u32 = 0;
pub const PIXMAN_TYPE_A: u32 = 1;
pub const PIXMAN_TYPE_ARGB: u32 = 2;
pub const PIXMAN_TYPE_ABGR: u32 = 3;
pub const PIXMAN_TYPE_COLOR: u32 = 4;
pub const PIXMAN_TYPE_GRAY: u32 = 5;
pub const PIXMAN_TYPE_YUY2: u32 = 6;
pub const PIXMAN_TYPE_YV12: u32 = 7;
pub const PIXMAN_TYPE_BGRA: u32 = 8;
pub const PIXMAN_TYPE_RGBA: u32 = 9;
pub const PIXMAN_TYPE_ARGB_SRGB: u32 = 10;
pub const PIXMAN_TYPE_RGBA_FLOAT: u32 = 11;
pub const WLR_DMABUF_MAX_PLANES: u32 = 4;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __ENUM_IDTYPE_T: u32 = 1;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _ALLOCA_H: u32 = 1;
pub const _STDIO_H: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const XKB_MOD_NAME_SHIFT: &'static [u8; 6usize] = b"Shift\0";
pub const XKB_MOD_NAME_CAPS: &'static [u8; 5usize] = b"Lock\0";
pub const XKB_MOD_NAME_CTRL: &'static [u8; 8usize] = b"Control\0";
pub const XKB_MOD_NAME_ALT: &'static [u8; 5usize] = b"Mod1\0";
pub const XKB_MOD_NAME_NUM: &'static [u8; 5usize] = b"Mod2\0";
pub const XKB_MOD_NAME_LOGO: &'static [u8; 5usize] = b"Mod4\0";
pub const XKB_LED_NAME_CAPS: &'static [u8; 10usize] = b"Caps Lock\0";
pub const XKB_LED_NAME_NUM: &'static [u8; 9usize] = b"Num Lock\0";
pub const XKB_LED_NAME_SCROLL: &'static [u8; 12usize] = b"Scroll Lock\0";
pub const XKB_KEY_NoSymbol: u32 = 0;
pub const XKB_KEY_VoidSymbol: u32 = 16777215;
pub const XKB_KEY_BackSpace: u32 = 65288;
pub const XKB_KEY_Tab: u32 = 65289;
pub const XKB_KEY_Linefeed: u32 = 65290;
pub const XKB_KEY_Clear: u32 = 65291;
pub const XKB_KEY_Return: u32 = 65293;
pub const XKB_KEY_Pause: u32 = 65299;
pub const XKB_KEY_Scroll_Lock: u32 = 65300;
pub const XKB_KEY_Sys_Req: u32 = 65301;
pub const XKB_KEY_Escape: u32 = 65307;
pub const XKB_KEY_Delete: u32 = 65535;
pub const XKB_KEY_Multi_key: u32 = 65312;
pub const XKB_KEY_Codeinput: u32 = 65335;
pub const XKB_KEY_SingleCandidate: u32 = 65340;
pub const XKB_KEY_MultipleCandidate: u32 = 65341;
pub const XKB_KEY_PreviousCandidate: u32 = 65342;
pub const XKB_KEY_Kanji: u32 = 65313;
pub const XKB_KEY_Muhenkan: u32 = 65314;
pub const XKB_KEY_Henkan_Mode: u32 = 65315;
pub const XKB_KEY_Henkan: u32 = 65315;
pub const XKB_KEY_Romaji: u32 = 65316;
pub const XKB_KEY_Hiragana: u32 = 65317;
pub const XKB_KEY_Katakana: u32 = 65318;
pub const XKB_KEY_Hiragana_Katakana: u32 = 65319;
pub const XKB_KEY_Zenkaku: u32 = 65320;
pub const XKB_KEY_Hankaku: u32 = 65321;
pub const XKB_KEY_Zenkaku_Hankaku: u32 = 65322;
pub const XKB_KEY_Touroku: u32 = 65323;
pub const XKB_KEY_Massyo: u32 = 65324;
pub const XKB_KEY_Kana_Lock: u32 = 65325;
pub const XKB_KEY_Kana_Shift: u32 = 65326;
pub const XKB_KEY_Eisu_Shift: u32 = 65327;
pub const XKB_KEY_Eisu_toggle: u32 = 65328;
pub const XKB_KEY_Kanji_Bangou: u32 = 65335;
pub const XKB_KEY_Zen_Koho: u32 = 65341;
pub const XKB_KEY_Mae_Koho: u32 = 65342;
pub const XKB_KEY_Home: u32 = 65360;
pub const XKB_KEY_Left: u32 = 65361;
pub const XKB_KEY_Up: u32 = 65362;
pub const XKB_KEY_Right: u32 = 65363;
pub const XKB_KEY_Down: u32 = 65364;
pub const XKB_KEY_Prior: u32 = 65365;
pub const XKB_KEY_Page_Up: u32 = 65365;
pub const XKB_KEY_Next: u32 = 65366;
pub const XKB_KEY_Page_Down: u32 = 65366;
pub const XKB_KEY_End: u32 = 65367;
pub const XKB_KEY_Begin: u32 = 65368;
pub const XKB_KEY_Select: u32 = 65376;
pub const XKB_KEY_Print: u32 = 65377;
pub const XKB_KEY_Execute: u32 = 65378;
pub const XKB_KEY_Insert: u32 = 65379;
pub const XKB_KEY_Undo: u32 = 65381;
pub const XKB_KEY_Redo: u32 = 65382;
pub const XKB_KEY_Menu: u32 = 65383;
pub const XKB_KEY_Find: u32 = 65384;
pub const XKB_KEY_Cancel: u32 = 65385;
pub const XKB_KEY_Help: u32 = 65386;
pub const XKB_KEY_Break: u32 = 65387;
pub const XKB_KEY_Mode_switch: u32 = 65406;
pub const XKB_KEY_script_switch: u32 = 65406;
pub const XKB_KEY_Num_Lock: u32 = 65407;
pub const XKB_KEY_KP_Space: u32 = 65408;
pub const XKB_KEY_KP_Tab: u32 = 65417;
pub const XKB_KEY_KP_Enter: u32 = 65421;
pub const XKB_KEY_KP_F1: u32 = 65425;
pub const XKB_KEY_KP_F2: u32 = 65426;
pub const XKB_KEY_KP_F3: u32 = 65427;
pub const XKB_KEY_KP_F4: u32 = 65428;
pub const XKB_KEY_KP_Home: u32 = 65429;
pub const XKB_KEY_KP_Left: u32 = 65430;
pub const XKB_KEY_KP_Up: u32 = 65431;
pub const XKB_KEY_KP_Right: u32 = 65432;
pub const XKB_KEY_KP_Down: u32 = 65433;
pub const XKB_KEY_KP_Prior: u32 = 65434;
pub const XKB_KEY_KP_Page_Up: u32 = 65434;
pub const XKB_KEY_KP_Next: u32 = 65435;
pub const XKB_KEY_KP_Page_Down: u32 = 65435;
pub const XKB_KEY_KP_End: u32 = 65436;
pub const XKB_KEY_KP_Begin: u32 = 65437;
pub const XKB_KEY_KP_Insert: u32 = 65438;
pub const XKB_KEY_KP_Delete: u32 = 65439;
pub const XKB_KEY_KP_Equal: u32 = 65469;
pub const XKB_KEY_KP_Multiply: u32 = 65450;
pub const XKB_KEY_KP_Add: u32 = 65451;
pub const XKB_KEY_KP_Separator: u32 = 65452;
pub const XKB_KEY_KP_Subtract: u32 = 65453;
pub const XKB_KEY_KP_Decimal: u32 = 65454;
pub const XKB_KEY_KP_Divide: u32 = 65455;
pub const XKB_KEY_KP_0: u32 = 65456;
pub const XKB_KEY_KP_1: u32 = 65457;
pub const XKB_KEY_KP_2: u32 = 65458;
pub const XKB_KEY_KP_3: u32 = 65459;
pub const XKB_KEY_KP_4: u32 = 65460;
pub const XKB_KEY_KP_5: u32 = 65461;
pub const XKB_KEY_KP_6: u32 = 65462;
pub const XKB_KEY_KP_7: u32 = 65463;
pub const XKB_KEY_KP_8: u32 = 65464;
pub const XKB_KEY_KP_9: u32 = 65465;
pub const XKB_KEY_F1: u32 = 65470;
pub const XKB_KEY_F2: u32 = 65471;
pub const XKB_KEY_F3: u32 = 65472;
pub const XKB_KEY_F4: u32 = 65473;
pub const XKB_KEY_F5: u32 = 65474;
pub const XKB_KEY_F6: u32 = 65475;
pub const XKB_KEY_F7: u32 = 65476;
pub const XKB_KEY_F8: u32 = 65477;
pub const XKB_KEY_F9: u32 = 65478;
pub const XKB_KEY_F10: u32 = 65479;
pub const XKB_KEY_F11: u32 = 65480;
pub const XKB_KEY_L1: u32 = 65480;
pub const XKB_KEY_F12: u32 = 65481;
pub const XKB_KEY_L2: u32 = 65481;
pub const XKB_KEY_F13: u32 = 65482;
pub const XKB_KEY_L3: u32 = 65482;
pub const XKB_KEY_F14: u32 = 65483;
pub const XKB_KEY_L4: u32 = 65483;
pub const XKB_KEY_F15: u32 = 65484;
pub const XKB_KEY_L5: u32 = 65484;
pub const XKB_KEY_F16: u32 = 65485;
pub const XKB_KEY_L6: u32 = 65485;
pub const XKB_KEY_F17: u32 = 65486;
pub const XKB_KEY_L7: u32 = 65486;
pub const XKB_KEY_F18: u32 = 65487;
pub const XKB_KEY_L8: u32 = 65487;
pub const XKB_KEY_F19: u32 = 65488;
pub const XKB_KEY_L9: u32 = 65488;
pub const XKB_KEY_F20: u32 = 65489;
pub const XKB_KEY_L10: u32 = 65489;
pub const XKB_KEY_F21: u32 = 65490;
pub const XKB_KEY_R1: u32 = 65490;
pub const XKB_KEY_F22: u32 = 65491;
pub const XKB_KEY_R2: u32 = 65491;
pub const XKB_KEY_F23: u32 = 65492;
pub const XKB_KEY_R3: u32 = 65492;
pub const XKB_KEY_F24: u32 = 65493;
pub const XKB_KEY_R4: u32 = 65493;
pub const XKB_KEY_F25: u32 = 65494;
pub const XKB_KEY_R5: u32 = 65494;
pub const XKB_KEY_F26: u32 = 65495;
pub const XKB_KEY_R6: u32 = 65495;
pub const XKB_KEY_F27: u32 = 65496;
pub const XKB_KEY_R7: u32 = 65496;
pub const XKB_KEY_F28: u32 = 65497;
pub const XKB_KEY_R8: u32 = 65497;
pub const XKB_KEY_F29: u32 = 65498;
pub const XKB_KEY_R9: u32 = 65498;
pub const XKB_KEY_F30: u32 = 65499;
pub const XKB_KEY_R10: u32 = 65499;
pub const XKB_KEY_F31: u32 = 65500;
pub const XKB_KEY_R11: u32 = 65500;
pub const XKB_KEY_F32: u32 = 65501;
pub const XKB_KEY_R12: u32 = 65501;
pub const XKB_KEY_F33: u32 = 65502;
pub const XKB_KEY_R13: u32 = 65502;
pub const XKB_KEY_F34: u32 = 65503;
pub const XKB_KEY_R14: u32 = 65503;
pub const XKB_KEY_F35: u32 = 65504;
pub const XKB_KEY_R15: u32 = 65504;
pub const XKB_KEY_Shift_L: u32 = 65505;
pub const XKB_KEY_Shift_R: u32 = 65506;
pub const XKB_KEY_Control_L: u32 = 65507;
pub const XKB_KEY_Control_R: u32 = 65508;
pub const XKB_KEY_Caps_Lock: u32 = 65509;
pub const XKB_KEY_Shift_Lock: u32 = 65510;
pub const XKB_KEY_Meta_L: u32 = 65511;
pub const XKB_KEY_Meta_R: u32 = 65512;
pub const XKB_KEY_Alt_L: u32 = 65513;
pub const XKB_KEY_Alt_R: u32 = 65514;
pub const XKB_KEY_Super_L: u32 = 65515;
pub const XKB_KEY_Super_R: u32 = 65516;
pub const XKB_KEY_Hyper_L: u32 = 65517;
pub const XKB_KEY_Hyper_R: u32 = 65518;
pub const XKB_KEY_ISO_Lock: u32 = 65025;
pub const XKB_KEY_ISO_Level2_Latch: u32 = 65026;
pub const XKB_KEY_ISO_Level3_Shift: u32 = 65027;
pub const XKB_KEY_ISO_Level3_Latch: u32 = 65028;
pub const XKB_KEY_ISO_Level3_Lock: u32 = 65029;
pub const XKB_KEY_ISO_Level5_Shift: u32 = 65041;
pub const XKB_KEY_ISO_Level5_Latch: u32 = 65042;
pub const XKB_KEY_ISO_Level5_Lock: u32 = 65043;
pub const XKB_KEY_ISO_Group_Shift: u32 = 65406;
pub const XKB_KEY_ISO_Group_Latch: u32 = 65030;
pub const XKB_KEY_ISO_Group_Lock: u32 = 65031;
pub const XKB_KEY_ISO_Next_Group: u32 = 65032;
pub const XKB_KEY_ISO_Next_Group_Lock: u32 = 65033;
pub const XKB_KEY_ISO_Prev_Group: u32 = 65034;
pub const XKB_KEY_ISO_Prev_Group_Lock: u32 = 65035;
pub const XKB_KEY_ISO_First_Group: u32 = 65036;
pub const XKB_KEY_ISO_First_Group_Lock: u32 = 65037;
pub const XKB_KEY_ISO_Last_Group: u32 = 65038;
pub const XKB_KEY_ISO_Last_Group_Lock: u32 = 65039;
pub const XKB_KEY_ISO_Left_Tab: u32 = 65056;
pub const XKB_KEY_ISO_Move_Line_Up: u32 = 65057;
pub const XKB_KEY_ISO_Move_Line_Down: u32 = 65058;
pub const XKB_KEY_ISO_Partial_Line_Up: u32 = 65059;
pub const XKB_KEY_ISO_Partial_Line_Down: u32 = 65060;
pub const XKB_KEY_ISO_Partial_Space_Left: u32 = 65061;
pub const XKB_KEY_ISO_Partial_Space_Right: u32 = 65062;
pub const XKB_KEY_ISO_Set_Margin_Left: u32 = 65063;
pub const XKB_KEY_ISO_Set_Margin_Right: u32 = 65064;
pub const XKB_KEY_ISO_Release_Margin_Left: u32 = 65065;
pub const XKB_KEY_ISO_Release_Margin_Right: u32 = 65066;
pub const XKB_KEY_ISO_Release_Both_Margins: u32 = 65067;
pub const XKB_KEY_ISO_Fast_Cursor_Left: u32 = 65068;
pub const XKB_KEY_ISO_Fast_Cursor_Right: u32 = 65069;
pub const XKB_KEY_ISO_Fast_Cursor_Up: u32 = 65070;
pub const XKB_KEY_ISO_Fast_Cursor_Down: u32 = 65071;
pub const XKB_KEY_ISO_Continuous_Underline: u32 = 65072;
pub const XKB_KEY_ISO_Discontinuous_Underline: u32 = 65073;
pub const XKB_KEY_ISO_Emphasize: u32 = 65074;
pub const XKB_KEY_ISO_Center_Object: u32 = 65075;
pub const XKB_KEY_ISO_Enter: u32 = 65076;
pub const XKB_KEY_dead_grave: u32 = 65104;
pub const XKB_KEY_dead_acute: u32 = 65105;
pub const XKB_KEY_dead_circumflex: u32 = 65106;
pub const XKB_KEY_dead_tilde: u32 = 65107;
pub const XKB_KEY_dead_perispomeni: u32 = 65107;
pub const XKB_KEY_dead_macron: u32 = 65108;
pub const XKB_KEY_dead_breve: u32 = 65109;
pub const XKB_KEY_dead_abovedot: u32 = 65110;
pub const XKB_KEY_dead_diaeresis: u32 = 65111;
pub const XKB_KEY_dead_abovering: u32 = 65112;
pub const XKB_KEY_dead_doubleacute: u32 = 65113;
pub const XKB_KEY_dead_caron: u32 = 65114;
pub const XKB_KEY_dead_cedilla: u32 = 65115;
pub const XKB_KEY_dead_ogonek: u32 = 65116;
pub const XKB_KEY_dead_iota: u32 = 65117;
pub const XKB_KEY_dead_voiced_sound: u32 = 65118;
pub const XKB_KEY_dead_semivoiced_sound: u32 = 65119;
pub const XKB_KEY_dead_belowdot: u32 = 65120;
pub const XKB_KEY_dead_hook: u32 = 65121;
pub const XKB_KEY_dead_horn: u32 = 65122;
pub const XKB_KEY_dead_stroke: u32 = 65123;
pub const XKB_KEY_dead_abovecomma: u32 = 65124;
pub const XKB_KEY_dead_psili: u32 = 65124;
pub const XKB_KEY_dead_abovereversedcomma: u32 = 65125;
pub const XKB_KEY_dead_dasia: u32 = 65125;
pub const XKB_KEY_dead_doublegrave: u32 = 65126;
pub const XKB_KEY_dead_belowring: u32 = 65127;
pub const XKB_KEY_dead_belowmacron: u32 = 65128;
pub const XKB_KEY_dead_belowcircumflex: u32 = 65129;
pub const XKB_KEY_dead_belowtilde: u32 = 65130;
pub const XKB_KEY_dead_belowbreve: u32 = 65131;
pub const XKB_KEY_dead_belowdiaeresis: u32 = 65132;
pub const XKB_KEY_dead_invertedbreve: u32 = 65133;
pub const XKB_KEY_dead_belowcomma: u32 = 65134;
pub const XKB_KEY_dead_currency: u32 = 65135;
pub const XKB_KEY_dead_lowline: u32 = 65168;
pub const XKB_KEY_dead_aboveverticalline: u32 = 65169;
pub const XKB_KEY_dead_belowverticalline: u32 = 65170;
pub const XKB_KEY_dead_longsolidusoverlay: u32 = 65171;
pub const XKB_KEY_dead_a: u32 = 65152;
pub const XKB_KEY_dead_A: u32 = 65153;
pub const XKB_KEY_dead_e: u32 = 65154;
pub const XKB_KEY_dead_E: u32 = 65155;
pub const XKB_KEY_dead_i: u32 = 65156;
pub const XKB_KEY_dead_I: u32 = 65157;
pub const XKB_KEY_dead_o: u32 = 65158;
pub const XKB_KEY_dead_O: u32 = 65159;
pub const XKB_KEY_dead_u: u32 = 65160;
pub const XKB_KEY_dead_U: u32 = 65161;
pub const XKB_KEY_dead_small_schwa: u32 = 65162;
pub const XKB_KEY_dead_capital_schwa: u32 = 65163;
pub const XKB_KEY_dead_greek: u32 = 65164;
pub const XKB_KEY_First_Virtual_Screen: u32 = 65232;
pub const XKB_KEY_Prev_Virtual_Screen: u32 = 65233;
pub const XKB_KEY_Next_Virtual_Screen: u32 = 65234;
pub const XKB_KEY_Last_Virtual_Screen: u32 = 65236;
pub const XKB_KEY_Terminate_Server: u32 = 65237;
pub const XKB_KEY_AccessX_Enable: u32 = 65136;
pub const XKB_KEY_AccessX_Feedback_Enable: u32 = 65137;
pub const XKB_KEY_RepeatKeys_Enable: u32 = 65138;
pub const XKB_KEY_SlowKeys_Enable: u32 = 65139;
pub const XKB_KEY_BounceKeys_Enable: u32 = 65140;
pub const XKB_KEY_StickyKeys_Enable: u32 = 65141;
pub const XKB_KEY_MouseKeys_Enable: u32 = 65142;
pub const XKB_KEY_MouseKeys_Accel_Enable: u32 = 65143;
pub const XKB_KEY_Overlay1_Enable: u32 = 65144;
pub const XKB_KEY_Overlay2_Enable: u32 = 65145;
pub const XKB_KEY_AudibleBell_Enable: u32 = 65146;
pub const XKB_KEY_Pointer_Left: u32 = 65248;
pub const XKB_KEY_Pointer_Right: u32 = 65249;
pub const XKB_KEY_Pointer_Up: u32 = 65250;
pub const XKB_KEY_Pointer_Down: u32 = 65251;
pub const XKB_KEY_Pointer_UpLeft: u32 = 65252;
pub const XKB_KEY_Pointer_UpRight: u32 = 65253;
pub const XKB_KEY_Pointer_DownLeft: u32 = 65254;
pub const XKB_KEY_Pointer_DownRight: u32 = 65255;
pub const XKB_KEY_Pointer_Button_Dflt: u32 = 65256;
pub const XKB_KEY_Pointer_Button1: u32 = 65257;
pub const XKB_KEY_Pointer_Button2: u32 = 65258;
pub const XKB_KEY_Pointer_Button3: u32 = 65259;
pub const XKB_KEY_Pointer_Button4: u32 = 65260;
pub const XKB_KEY_Pointer_Button5: u32 = 65261;
pub const XKB_KEY_Pointer_DblClick_Dflt: u32 = 65262;
pub const XKB_KEY_Pointer_DblClick1: u32 = 65263;
pub const XKB_KEY_Pointer_DblClick2: u32 = 65264;
pub const XKB_KEY_Pointer_DblClick3: u32 = 65265;
pub const XKB_KEY_Pointer_DblClick4: u32 = 65266;
pub const XKB_KEY_Pointer_DblClick5: u32 = 65267;
pub const XKB_KEY_Pointer_Drag_Dflt: u32 = 65268;
pub const XKB_KEY_Pointer_Drag1: u32 = 65269;
pub const XKB_KEY_Pointer_Drag2: u32 = 65270;
pub const XKB_KEY_Pointer_Drag3: u32 = 65271;
pub const XKB_KEY_Pointer_Drag4: u32 = 65272;
pub const XKB_KEY_Pointer_Drag5: u32 = 65277;
pub const XKB_KEY_Pointer_EnableKeys: u32 = 65273;
pub const XKB_KEY_Pointer_Accelerate: u32 = 65274;
pub const XKB_KEY_Pointer_DfltBtnNext: u32 = 65275;
pub const XKB_KEY_Pointer_DfltBtnPrev: u32 = 65276;
pub const XKB_KEY_ch: u32 = 65184;
pub const XKB_KEY_Ch: u32 = 65185;
pub const XKB_KEY_CH: u32 = 65186;
pub const XKB_KEY_c_h: u32 = 65187;
pub const XKB_KEY_C_h: u32 = 65188;
pub const XKB_KEY_C_H: u32 = 65189;
pub const XKB_KEY_3270_Duplicate: u32 = 64769;
pub const XKB_KEY_3270_FieldMark: u32 = 64770;
pub const XKB_KEY_3270_Right2: u32 = 64771;
pub const XKB_KEY_3270_Left2: u32 = 64772;
pub const XKB_KEY_3270_BackTab: u32 = 64773;
pub const XKB_KEY_3270_EraseEOF: u32 = 64774;
pub const XKB_KEY_3270_EraseInput: u32 = 64775;
pub const XKB_KEY_3270_Reset: u32 = 64776;
pub const XKB_KEY_3270_Quit: u32 = 64777;
pub const XKB_KEY_3270_PA1: u32 = 64778;
pub const XKB_KEY_3270_PA2: u32 = 64779;
pub const XKB_KEY_3270_PA3: u32 = 64780;
pub const XKB_KEY_3270_Test: u32 = 64781;
pub const XKB_KEY_3270_Attn: u32 = 64782;
pub const XKB_KEY_3270_CursorBlink: u32 = 64783;
pub const XKB_KEY_3270_AltCursor: u32 = 64784;
pub const XKB_KEY_3270_KeyClick: u32 = 64785;
pub const XKB_KEY_3270_Jump: u32 = 64786;
pub const XKB_KEY_3270_Ident: u32 = 64787;
pub const XKB_KEY_3270_Rule: u32 = 64788;
pub const XKB_KEY_3270_Copy: u32 = 64789;
pub const XKB_KEY_3270_Play: u32 = 64790;
pub const XKB_KEY_3270_Setup: u32 = 64791;
pub const XKB_KEY_3270_Record: u32 = 64792;
pub const XKB_KEY_3270_ChangeScreen: u32 = 64793;
pub const XKB_KEY_3270_DeleteWord: u32 = 64794;
pub const XKB_KEY_3270_ExSelect: u32 = 64795;
pub const XKB_KEY_3270_CursorSelect: u32 = 64796;
pub const XKB_KEY_3270_PrintScreen: u32 = 64797;
pub const XKB_KEY_3270_Enter: u32 = 64798;
pub const XKB_KEY_space: u32 = 32;
pub const XKB_KEY_exclam: u32 = 33;
pub const XKB_KEY_quotedbl: u32 = 34;
pub const XKB_KEY_numbersign: u32 = 35;
pub const XKB_KEY_dollar: u32 = 36;
pub const XKB_KEY_percent: u32 = 37;
pub const XKB_KEY_ampersand: u32 = 38;
pub const XKB_KEY_apostrophe: u32 = 39;
pub const XKB_KEY_quoteright: u32 = 39;
pub const XKB_KEY_parenleft: u32 = 40;
pub const XKB_KEY_parenright: u32 = 41;
pub const XKB_KEY_asterisk: u32 = 42;
pub const XKB_KEY_plus: u32 = 43;
pub const XKB_KEY_comma: u32 = 44;
pub const XKB_KEY_minus: u32 = 45;
pub const XKB_KEY_period: u32 = 46;
pub const XKB_KEY_slash: u32 = 47;
pub const XKB_KEY_0: u32 = 48;
pub const XKB_KEY_1: u32 = 49;
pub const XKB_KEY_2: u32 = 50;
pub const XKB_KEY_3: u32 = 51;
pub const XKB_KEY_4: u32 = 52;
pub const XKB_KEY_5: u32 = 53;
pub const XKB_KEY_6: u32 = 54;
pub const XKB_KEY_7: u32 = 55;
pub const XKB_KEY_8: u32 = 56;
pub const XKB_KEY_9: u32 = 57;
pub const XKB_KEY_colon: u32 = 58;
pub const XKB_KEY_semicolon: u32 = 59;
pub const XKB_KEY_less: u32 = 60;
pub const XKB_KEY_equal: u32 = 61;
pub const XKB_KEY_greater: u32 = 62;
pub const XKB_KEY_question: u32 = 63;
pub const XKB_KEY_at: u32 = 64;
pub const XKB_KEY_A: u32 = 65;
pub const XKB_KEY_B: u32 = 66;
pub const XKB_KEY_C: u32 = 67;
pub const XKB_KEY_D: u32 = 68;
pub const XKB_KEY_E: u32 = 69;
pub const XKB_KEY_F: u32 = 70;
pub const XKB_KEY_G: u32 = 71;
pub const XKB_KEY_H: u32 = 72;
pub const XKB_KEY_I: u32 = 73;
pub const XKB_KEY_J: u32 = 74;
pub const XKB_KEY_K: u32 = 75;
pub const XKB_KEY_L: u32 = 76;
pub const XKB_KEY_M: u32 = 77;
pub const XKB_KEY_N: u32 = 78;
pub const XKB_KEY_O: u32 = 79;
pub const XKB_KEY_P: u32 = 80;
pub const XKB_KEY_Q: u32 = 81;
pub const XKB_KEY_R: u32 = 82;
pub const XKB_KEY_S: u32 = 83;
pub const XKB_KEY_T: u32 = 84;
pub const XKB_KEY_U: u32 = 85;
pub const XKB_KEY_V: u32 = 86;
pub const XKB_KEY_W: u32 = 87;
pub const XKB_KEY_X: u32 = 88;
pub const XKB_KEY_Y: u32 = 89;
pub const XKB_KEY_Z: u32 = 90;
pub const XKB_KEY_bracketleft: u32 = 91;
pub const XKB_KEY_backslash: u32 = 92;
pub const XKB_KEY_bracketright: u32 = 93;
pub const XKB_KEY_asciicircum: u32 = 94;
pub const XKB_KEY_underscore: u32 = 95;
pub const XKB_KEY_grave: u32 = 96;
pub const XKB_KEY_quoteleft: u32 = 96;
pub const XKB_KEY_a: u32 = 97;
pub const XKB_KEY_b: u32 = 98;
pub const XKB_KEY_c: u32 = 99;
pub const XKB_KEY_d: u32 = 100;
pub const XKB_KEY_e: u32 = 101;
pub const XKB_KEY_f: u32 = 102;
pub const XKB_KEY_g: u32 = 103;
pub const XKB_KEY_h: u32 = 104;
pub const XKB_KEY_i: u32 = 105;
pub const XKB_KEY_j: u32 = 106;
pub const XKB_KEY_k: u32 = 107;
pub const XKB_KEY_l: u32 = 108;
pub const XKB_KEY_m: u32 = 109;
pub const XKB_KEY_n: u32 = 110;
pub const XKB_KEY_o: u32 = 111;
pub const XKB_KEY_p: u32 = 112;
pub const XKB_KEY_q: u32 = 113;
pub const XKB_KEY_r: u32 = 114;
pub const XKB_KEY_s: u32 = 115;
pub const XKB_KEY_t: u32 = 116;
pub const XKB_KEY_u: u32 = 117;
pub const XKB_KEY_v: u32 = 118;
pub const XKB_KEY_w: u32 = 119;
pub const XKB_KEY_x: u32 = 120;
pub const XKB_KEY_y: u32 = 121;
pub const XKB_KEY_z: u32 = 122;
pub const XKB_KEY_braceleft: u32 = 123;
pub const XKB_KEY_bar: u32 = 124;
pub const XKB_KEY_braceright: u32 = 125;
pub const XKB_KEY_asciitilde: u32 = 126;
pub const XKB_KEY_nobreakspace: u32 = 160;
pub const XKB_KEY_exclamdown: u32 = 161;
pub const XKB_KEY_cent: u32 = 162;
pub const XKB_KEY_sterling: u32 = 163;
pub const XKB_KEY_currency: u32 = 164;
pub const XKB_KEY_yen: u32 = 165;
pub const XKB_KEY_brokenbar: u32 = 166;
pub const XKB_KEY_section: u32 = 167;
pub const XKB_KEY_diaeresis: u32 = 168;
pub const XKB_KEY_copyright: u32 = 169;
pub const XKB_KEY_ordfeminine: u32 = 170;
pub const XKB_KEY_guillemotleft: u32 = 171;
pub const XKB_KEY_notsign: u32 = 172;
pub const XKB_KEY_hyphen: u32 = 173;
pub const XKB_KEY_registered: u32 = 174;
pub const XKB_KEY_macron: u32 = 175;
pub const XKB_KEY_degree: u32 = 176;
pub const XKB_KEY_plusminus: u32 = 177;
pub const XKB_KEY_twosuperior: u32 = 178;
pub const XKB_KEY_threesuperior: u32 = 179;
pub const XKB_KEY_acute: u32 = 180;
pub const XKB_KEY_mu: u32 = 181;
pub const XKB_KEY_paragraph: u32 = 182;
pub const XKB_KEY_periodcentered: u32 = 183;
pub const XKB_KEY_cedilla: u32 = 184;
pub const XKB_KEY_onesuperior: u32 = 185;
pub const XKB_KEY_masculine: u32 = 186;
pub const XKB_KEY_guillemotright: u32 = 187;
pub const XKB_KEY_onequarter: u32 = 188;
pub const XKB_KEY_onehalf: u32 = 189;
pub const XKB_KEY_threequarters: u32 = 190;
pub const XKB_KEY_questiondown: u32 = 191;
pub const XKB_KEY_Agrave: u32 = 192;
pub const XKB_KEY_Aacute: u32 = 193;
pub const XKB_KEY_Acircumflex: u32 = 194;
pub const XKB_KEY_Atilde: u32 = 195;
pub const XKB_KEY_Adiaeresis: u32 = 196;
pub const XKB_KEY_Aring: u32 = 197;
pub const XKB_KEY_AE: u32 = 198;
pub const XKB_KEY_Ccedilla: u32 = 199;
pub const XKB_KEY_Egrave: u32 = 200;
pub const XKB_KEY_Eacute: u32 = 201;
pub const XKB_KEY_Ecircumflex: u32 = 202;
pub const XKB_KEY_Ediaeresis: u32 = 203;
pub const XKB_KEY_Igrave: u32 = 204;
pub const XKB_KEY_Iacute: u32 = 205;
pub const XKB_KEY_Icircumflex: u32 = 206;
pub const XKB_KEY_Idiaeresis: u32 = 207;
pub const XKB_KEY_ETH: u32 = 208;
pub const XKB_KEY_Eth: u32 = 208;
pub const XKB_KEY_Ntilde: u32 = 209;
pub const XKB_KEY_Ograve: u32 = 210;
pub const XKB_KEY_Oacute: u32 = 211;
pub const XKB_KEY_Ocircumflex: u32 = 212;
pub const XKB_KEY_Otilde: u32 = 213;
pub const XKB_KEY_Odiaeresis: u32 = 214;
pub const XKB_KEY_multiply: u32 = 215;
pub const XKB_KEY_Oslash: u32 = 216;
pub const XKB_KEY_Ooblique: u32 = 216;
pub const XKB_KEY_Ugrave: u32 = 217;
pub const XKB_KEY_Uacute: u32 = 218;
pub const XKB_KEY_Ucircumflex: u32 = 219;
pub const XKB_KEY_Udiaeresis: u32 = 220;
pub const XKB_KEY_Yacute: u32 = 221;
pub const XKB_KEY_THORN: u32 = 222;
pub const XKB_KEY_Thorn: u32 = 222;
pub const XKB_KEY_ssharp: u32 = 223;
pub const XKB_KEY_agrave: u32 = 224;
pub const XKB_KEY_aacute: u32 = 225;
pub const XKB_KEY_acircumflex: u32 = 226;
pub const XKB_KEY_atilde: u32 = 227;
pub const XKB_KEY_adiaeresis: u32 = 228;
pub const XKB_KEY_aring: u32 = 229;
pub const XKB_KEY_ae: u32 = 230;
pub const XKB_KEY_ccedilla: u32 = 231;
pub const XKB_KEY_egrave: u32 = 232;
pub const XKB_KEY_eacute: u32 = 233;
pub const XKB_KEY_ecircumflex: u32 = 234;
pub const XKB_KEY_ediaeresis: u32 = 235;
pub const XKB_KEY_igrave: u32 = 236;
pub const XKB_KEY_iacute: u32 = 237;
pub const XKB_KEY_icircumflex: u32 = 238;
pub const XKB_KEY_idiaeresis: u32 = 239;
pub const XKB_KEY_eth: u32 = 240;
pub const XKB_KEY_ntilde: u32 = 241;
pub const XKB_KEY_ograve: u32 = 242;
pub const XKB_KEY_oacute: u32 = 243;
pub const XKB_KEY_ocircumflex: u32 = 244;
pub const XKB_KEY_otilde: u32 = 245;
pub const XKB_KEY_odiaeresis: u32 = 246;
pub const XKB_KEY_division: u32 = 247;
pub const XKB_KEY_oslash: u32 = 248;
pub const XKB_KEY_ooblique: u32 = 248;
pub const XKB_KEY_ugrave: u32 = 249;
pub const XKB_KEY_uacute: u32 = 250;
pub const XKB_KEY_ucircumflex: u32 = 251;
pub const XKB_KEY_udiaeresis: u32 = 252;
pub const XKB_KEY_yacute: u32 = 253;
pub const XKB_KEY_thorn: u32 = 254;
pub const XKB_KEY_ydiaeresis: u32 = 255;
pub const XKB_KEY_Aogonek: u32 = 417;
pub const XKB_KEY_breve: u32 = 418;
pub const XKB_KEY_Lstroke: u32 = 419;
pub const XKB_KEY_Lcaron: u32 = 421;
pub const XKB_KEY_Sacute: u32 = 422;
pub const XKB_KEY_Scaron: u32 = 425;
pub const XKB_KEY_Scedilla: u32 = 426;
pub const XKB_KEY_Tcaron: u32 = 427;
pub const XKB_KEY_Zacute: u32 = 428;
pub const XKB_KEY_Zcaron: u32 = 430;
pub const XKB_KEY_Zabovedot: u32 = 431;
pub const XKB_KEY_aogonek: u32 = 433;
pub const XKB_KEY_ogonek: u32 = 434;
pub const XKB_KEY_lstroke: u32 = 435;
pub const XKB_KEY_lcaron: u32 = 437;
pub const XKB_KEY_sacute: u32 = 438;
pub const XKB_KEY_caron: u32 = 439;
pub const XKB_KEY_scaron: u32 = 441;
pub const XKB_KEY_scedilla: u32 = 442;
pub const XKB_KEY_tcaron: u32 = 443;
pub const XKB_KEY_zacute: u32 = 444;
pub const XKB_KEY_doubleacute: u32 = 445;
pub const XKB_KEY_zcaron: u32 = 446;
pub const XKB_KEY_zabovedot: u32 = 447;
pub const XKB_KEY_Racute: u32 = 448;
pub const XKB_KEY_Abreve: u32 = 451;
pub const XKB_KEY_Lacute: u32 = 453;
pub const XKB_KEY_Cacute: u32 = 454;
pub const XKB_KEY_Ccaron: u32 = 456;
pub const XKB_KEY_Eogonek: u32 = 458;
pub const XKB_KEY_Ecaron: u32 = 460;
pub const XKB_KEY_Dcaron: u32 = 463;
pub const XKB_KEY_Dstroke: u32 = 464;
pub const XKB_KEY_Nacute: u32 = 465;
pub const XKB_KEY_Ncaron: u32 = 466;
pub const XKB_KEY_Odoubleacute: u32 = 469;
pub const XKB_KEY_Rcaron: u32 = 472;
pub const XKB_KEY_Uring: u32 = 473;
pub const XKB_KEY_Udoubleacute: u32 = 475;
pub const XKB_KEY_Tcedilla: u32 = 478;
pub const XKB_KEY_racute: u32 = 480;
pub const XKB_KEY_abreve: u32 = 483;
pub const XKB_KEY_lacute: u32 = 485;
pub const XKB_KEY_cacute: u32 = 486;
pub const XKB_KEY_ccaron: u32 = 488;
pub const XKB_KEY_eogonek: u32 = 490;
pub const XKB_KEY_ecaron: u32 = 492;
pub const XKB_KEY_dcaron: u32 = 495;
pub const XKB_KEY_dstroke: u32 = 496;
pub const XKB_KEY_nacute: u32 = 497;
pub const XKB_KEY_ncaron: u32 = 498;
pub const XKB_KEY_odoubleacute: u32 = 501;
pub const XKB_KEY_rcaron: u32 = 504;
pub const XKB_KEY_uring: u32 = 505;
pub const XKB_KEY_udoubleacute: u32 = 507;
pub const XKB_KEY_tcedilla: u32 = 510;
pub const XKB_KEY_abovedot: u32 = 511;
pub const XKB_KEY_Hstroke: u32 = 673;
pub const XKB_KEY_Hcircumflex: u32 = 678;
pub const XKB_KEY_Iabovedot: u32 = 681;
pub const XKB_KEY_Gbreve: u32 = 683;
pub const XKB_KEY_Jcircumflex: u32 = 684;
pub const XKB_KEY_hstroke: u32 = 689;
pub const XKB_KEY_hcircumflex: u32 = 694;
pub const XKB_KEY_idotless: u32 = 697;
pub const XKB_KEY_gbreve: u32 = 699;
pub const XKB_KEY_jcircumflex: u32 = 700;
pub const XKB_KEY_Cabovedot: u32 = 709;
pub const XKB_KEY_Ccircumflex: u32 = 710;
pub const XKB_KEY_Gabovedot: u32 = 725;
pub const XKB_KEY_Gcircumflex: u32 = 728;
pub const XKB_KEY_Ubreve: u32 = 733;
pub const XKB_KEY_Scircumflex: u32 = 734;
pub const XKB_KEY_cabovedot: u32 = 741;
pub const XKB_KEY_ccircumflex: u32 = 742;
pub const XKB_KEY_gabovedot: u32 = 757;
pub const XKB_KEY_gcircumflex: u32 = 760;
pub const XKB_KEY_ubreve: u32 = 765;
pub const XKB_KEY_scircumflex: u32 = 766;
pub const XKB_KEY_kra: u32 = 930;
pub const XKB_KEY_kappa: u32 = 930;
pub const XKB_KEY_Rcedilla: u32 = 931;
pub const XKB_KEY_Itilde: u32 = 933;
pub const XKB_KEY_Lcedilla: u32 = 934;
pub const XKB_KEY_Emacron: u32 = 938;
pub const XKB_KEY_Gcedilla: u32 = 939;
pub const XKB_KEY_Tslash: u32 = 940;
pub const XKB_KEY_rcedilla: u32 = 947;
pub const XKB_KEY_itilde: u32 = 949;
pub const XKB_KEY_lcedilla: u32 = 950;
pub const XKB_KEY_emacron: u32 = 954;
pub const XKB_KEY_gcedilla: u32 = 955;
pub const XKB_KEY_tslash: u32 = 956;
pub const XKB_KEY_ENG: u32 = 957;
pub const XKB_KEY_eng: u32 = 959;
pub const XKB_KEY_Amacron: u32 = 960;
pub const XKB_KEY_Iogonek: u32 = 967;
pub const XKB_KEY_Eabovedot: u32 = 972;
pub const XKB_KEY_Imacron: u32 = 975;
pub const XKB_KEY_Ncedilla: u32 = 977;
pub const XKB_KEY_Omacron: u32 = 978;
pub const XKB_KEY_Kcedilla: u32 = 979;
pub const XKB_KEY_Uogonek: u32 = 985;
pub const XKB_KEY_Utilde: u32 = 989;
pub const XKB_KEY_Umacron: u32 = 990;
pub const XKB_KEY_amacron: u32 = 992;
pub const XKB_KEY_iogonek: u32 = 999;
pub const XKB_KEY_eabovedot: u32 = 1004;
pub const XKB_KEY_imacron: u32 = 1007;
pub const XKB_KEY_ncedilla: u32 = 1009;
pub const XKB_KEY_omacron: u32 = 1010;
pub const XKB_KEY_kcedilla: u32 = 1011;
pub const XKB_KEY_uogonek: u32 = 1017;
pub const XKB_KEY_utilde: u32 = 1021;
pub const XKB_KEY_umacron: u32 = 1022;
pub const XKB_KEY_Wcircumflex: u32 = 16777588;
pub const XKB_KEY_wcircumflex: u32 = 16777589;
pub const XKB_KEY_Ycircumflex: u32 = 16777590;
pub const XKB_KEY_ycircumflex: u32 = 16777591;
pub const XKB_KEY_Babovedot: u32 = 16784898;
pub const XKB_KEY_babovedot: u32 = 16784899;
pub const XKB_KEY_Dabovedot: u32 = 16784906;
pub const XKB_KEY_dabovedot: u32 = 16784907;
pub const XKB_KEY_Fabovedot: u32 = 16784926;
pub const XKB_KEY_fabovedot: u32 = 16784927;
pub const XKB_KEY_Mabovedot: u32 = 16784960;
pub const XKB_KEY_mabovedot: u32 = 16784961;
pub const XKB_KEY_Pabovedot: u32 = 16784982;
pub const XKB_KEY_pabovedot: u32 = 16784983;
pub const XKB_KEY_Sabovedot: u32 = 16784992;
pub const XKB_KEY_sabovedot: u32 = 16784993;
pub const XKB_KEY_Tabovedot: u32 = 16785002;
pub const XKB_KEY_tabovedot: u32 = 16785003;
pub const XKB_KEY_Wgrave: u32 = 16785024;
pub const XKB_KEY_wgrave: u32 = 16785025;
pub const XKB_KEY_Wacute: u32 = 16785026;
pub const XKB_KEY_wacute: u32 = 16785027;
pub const XKB_KEY_Wdiaeresis: u32 = 16785028;
pub const XKB_KEY_wdiaeresis: u32 = 16785029;
pub const XKB_KEY_Ygrave: u32 = 16785138;
pub const XKB_KEY_ygrave: u32 = 16785139;
pub const XKB_KEY_OE: u32 = 5052;
pub const XKB_KEY_oe: u32 = 5053;
pub const XKB_KEY_Ydiaeresis: u32 = 5054;
pub const XKB_KEY_overline: u32 = 1150;
pub const XKB_KEY_kana_fullstop: u32 = 1185;
pub const XKB_KEY_kana_openingbracket: u32 = 1186;
pub const XKB_KEY_kana_closingbracket: u32 = 1187;
pub const XKB_KEY_kana_comma: u32 = 1188;
pub const XKB_KEY_kana_conjunctive: u32 = 1189;
pub const XKB_KEY_kana_middledot: u32 = 1189;
pub const XKB_KEY_kana_WO: u32 = 1190;
pub const XKB_KEY_kana_a: u32 = 1191;
pub const XKB_KEY_kana_i: u32 = 1192;
pub const XKB_KEY_kana_u: u32 = 1193;
pub const XKB_KEY_kana_e: u32 = 1194;
pub const XKB_KEY_kana_o: u32 = 1195;
pub const XKB_KEY_kana_ya: u32 = 1196;
pub const XKB_KEY_kana_yu: u32 = 1197;
pub const XKB_KEY_kana_yo: u32 = 1198;
pub const XKB_KEY_kana_tsu: u32 = 1199;
pub const XKB_KEY_kana_tu: u32 = 1199;
pub const XKB_KEY_prolongedsound: u32 = 1200;
pub const XKB_KEY_kana_A: u32 = 1201;
pub const XKB_KEY_kana_I: u32 = 1202;
pub const XKB_KEY_kana_U: u32 = 1203;
pub const XKB_KEY_kana_E: u32 = 1204;
pub const XKB_KEY_kana_O: u32 = 1205;
pub const XKB_KEY_kana_KA: u32 = 1206;
pub const XKB_KEY_kana_KI: u32 = 1207;
pub const XKB_KEY_kana_KU: u32 = 1208;
pub const XKB_KEY_kana_KE: u32 = 1209;
pub const XKB_KEY_kana_KO: u32 = 1210;
pub const XKB_KEY_kana_SA: u32 = 1211;
pub const XKB_KEY_kana_SHI: u32 = 1212;
pub const XKB_KEY_kana_SU: u32 = 1213;
pub const XKB_KEY_kana_SE: u32 = 1214;
pub const XKB_KEY_kana_SO: u32 = 1215;
pub const XKB_KEY_kana_TA: u32 = 1216;
pub const XKB_KEY_kana_CHI: u32 = 1217;
pub const XKB_KEY_kana_TI: u32 = 1217;
pub const XKB_KEY_kana_TSU: u32 = 1218;
pub const XKB_KEY_kana_TU: u32 = 1218;
pub const XKB_KEY_kana_TE: u32 = 1219;
pub const XKB_KEY_kana_TO: u32 = 1220;
pub const XKB_KEY_kana_NA: u32 = 1221;
pub const XKB_KEY_kana_NI: u32 = 1222;
pub const XKB_KEY_kana_NU: u32 = 1223;
pub const XKB_KEY_kana_NE: u32 = 1224;
pub const XKB_KEY_kana_NO: u32 = 1225;
pub const XKB_KEY_kana_HA: u32 = 1226;
pub const XKB_KEY_kana_HI: u32 = 1227;
pub const XKB_KEY_kana_FU: u32 = 1228;
pub const XKB_KEY_kana_HU: u32 = 1228;
pub const XKB_KEY_kana_HE: u32 = 1229;
pub const XKB_KEY_kana_HO: u32 = 1230;
pub const XKB_KEY_kana_MA: u32 = 1231;
pub const XKB_KEY_kana_MI: u32 = 1232;
pub const XKB_KEY_kana_MU: u32 = 1233;
pub const XKB_KEY_kana_ME: u32 = 1234;
pub const XKB_KEY_kana_MO: u32 = 1235;
pub const XKB_KEY_kana_YA: u32 = 1236;
pub const XKB_KEY_kana_YU: u32 = 1237;
pub const XKB_KEY_kana_YO: u32 = 1238;
pub const XKB_KEY_kana_RA: u32 = 1239;
pub const XKB_KEY_kana_RI: u32 = 1240;
pub const XKB_KEY_kana_RU: u32 = 1241;
pub const XKB_KEY_kana_RE: u32 = 1242;
pub const XKB_KEY_kana_RO: u32 = 1243;
pub const XKB_KEY_kana_WA: u32 = 1244;
pub const XKB_KEY_kana_N: u32 = 1245;
pub const XKB_KEY_voicedsound: u32 = 1246;
pub const XKB_KEY_semivoicedsound: u32 = 1247;
pub const XKB_KEY_kana_switch: u32 = 65406;
pub const XKB_KEY_Farsi_0: u32 = 16778992;
pub const XKB_KEY_Farsi_1: u32 = 16778993;
pub const XKB_KEY_Farsi_2: u32 = 16778994;
pub const XKB_KEY_Farsi_3: u32 = 16778995;
pub const XKB_KEY_Farsi_4: u32 = 16778996;
pub const XKB_KEY_Farsi_5: u32 = 16778997;
pub const XKB_KEY_Farsi_6: u32 = 16778998;
pub const XKB_KEY_Farsi_7: u32 = 16778999;
pub const XKB_KEY_Farsi_8: u32 = 16779000;
pub const XKB_KEY_Farsi_9: u32 = 16779001;
pub const XKB_KEY_Arabic_percent: u32 = 16778858;
pub const XKB_KEY_Arabic_superscript_alef: u32 = 16778864;
pub const XKB_KEY_Arabic_tteh: u32 = 16778873;
pub const XKB_KEY_Arabic_peh: u32 = 16778878;
pub const XKB_KEY_Arabic_tcheh: u32 = 16778886;
pub const XKB_KEY_Arabic_ddal: u32 = 16778888;
pub const XKB_KEY_Arabic_rreh: u32 = 16778897;
pub const XKB_KEY_Arabic_comma: u32 = 1452;
pub const XKB_KEY_Arabic_fullstop: u32 = 16778964;
pub const XKB_KEY_Arabic_0: u32 = 16778848;
pub const XKB_KEY_Arabic_1: u32 = 16778849;
pub const XKB_KEY_Arabic_2: u32 = 16778850;
pub const XKB_KEY_Arabic_3: u32 = 16778851;
pub const XKB_KEY_Arabic_4: u32 = 16778852;
pub const XKB_KEY_Arabic_5: u32 = 16778853;
pub const XKB_KEY_Arabic_6: u32 = 16778854;
pub const XKB_KEY_Arabic_7: u32 = 16778855;
pub const XKB_KEY_Arabic_8: u32 = 16778856;
pub const XKB_KEY_Arabic_9: u32 = 16778857;
pub const XKB_KEY_Arabic_semicolon: u32 = 1467;
pub const XKB_KEY_Arabic_question_mark: u32 = 1471;
pub const XKB_KEY_Arabic_hamza: u32 = 1473;
pub const XKB_KEY_Arabic_maddaonalef: u32 = 1474;
pub const XKB_KEY_Arabic_hamzaonalef: u32 = 1475;
pub const XKB_KEY_Arabic_hamzaonwaw: u32 = 1476;
pub const XKB_KEY_Arabic_hamzaunderalef: u32 = 1477;
pub const XKB_KEY_Arabic_hamzaonyeh: u32 = 1478;
pub const XKB_KEY_Arabic_alef: u32 = 1479;
pub const XKB_KEY_Arabic_beh: u32 = 1480;
pub const XKB_KEY_Arabic_tehmarbuta: u32 = 1481;
pub const XKB_KEY_Arabic_teh: u32 = 1482;
pub const XKB_KEY_Arabic_theh: u32 = 1483;
pub const XKB_KEY_Arabic_jeem: u32 = 1484;
pub const XKB_KEY_Arabic_hah: u32 = 1485;
pub const XKB_KEY_Arabic_khah: u32 = 1486;
pub const XKB_KEY_Arabic_dal: u32 = 1487;
pub const XKB_KEY_Arabic_thal: u32 = 1488;
pub const XKB_KEY_Arabic_ra: u32 = 1489;
pub const XKB_KEY_Arabic_zain: u32 = 1490;
pub const XKB_KEY_Arabic_seen: u32 = 1491;
pub const XKB_KEY_Arabic_sheen: u32 = 1492;
pub const XKB_KEY_Arabic_sad: u32 = 1493;
pub const XKB_KEY_Arabic_dad: u32 = 1494;
pub const XKB_KEY_Arabic_tah: u32 = 1495;
pub const XKB_KEY_Arabic_zah: u32 = 1496;
pub const XKB_KEY_Arabic_ain: u32 = 1497;
pub const XKB_KEY_Arabic_ghain: u32 = 1498;
pub const XKB_KEY_Arabic_tatweel: u32 = 1504;
pub const XKB_KEY_Arabic_feh: u32 = 1505;
pub const XKB_KEY_Arabic_qaf: u32 = 1506;
pub const XKB_KEY_Arabic_kaf: u32 = 1507;
pub const XKB_KEY_Arabic_lam: u32 = 1508;
pub const XKB_KEY_Arabic_meem: u32 = 1509;
pub const XKB_KEY_Arabic_noon: u32 = 1510;
pub const XKB_KEY_Arabic_ha: u32 = 1511;
pub const XKB_KEY_Arabic_heh: u32 = 1511;
pub const XKB_KEY_Arabic_waw: u32 = 1512;
pub const XKB_KEY_Arabic_alefmaksura: u32 = 1513;
pub const XKB_KEY_Arabic_yeh: u32 = 1514;
pub const XKB_KEY_Arabic_fathatan: u32 = 1515;
pub const XKB_KEY_Arabic_dammatan: u32 = 1516;
pub const XKB_KEY_Arabic_kasratan: u32 = 1517;
pub const XKB_KEY_Arabic_fatha: u32 = 1518;
pub const XKB_KEY_Arabic_damma: u32 = 1519;
pub const XKB_KEY_Arabic_kasra: u32 = 1520;
pub const XKB_KEY_Arabic_shadda: u32 = 1521;
pub const XKB_KEY_Arabic_sukun: u32 = 1522;
pub const XKB_KEY_Arabic_madda_above: u32 = 16778835;
pub const XKB_KEY_Arabic_hamza_above: u32 = 16778836;
pub const XKB_KEY_Arabic_hamza_below: u32 = 16778837;
pub const XKB_KEY_Arabic_jeh: u32 = 16778904;
pub const XKB_KEY_Arabic_veh: u32 = 16778916;
pub const XKB_KEY_Arabic_keheh: u32 = 16778921;
pub const XKB_KEY_Arabic_gaf: u32 = 16778927;
pub const XKB_KEY_Arabic_noon_ghunna: u32 = 16778938;
pub const XKB_KEY_Arabic_heh_doachashmee: u32 = 16778942;
pub const XKB_KEY_Farsi_yeh: u32 = 16778956;
pub const XKB_KEY_Arabic_farsi_yeh: u32 = 16778956;
pub const XKB_KEY_Arabic_yeh_baree: u32 = 16778962;
pub const XKB_KEY_Arabic_heh_goal: u32 = 16778945;
pub const XKB_KEY_Arabic_switch: u32 = 65406;
pub const XKB_KEY_Cyrillic_GHE_bar: u32 = 16778386;
pub const XKB_KEY_Cyrillic_ghe_bar: u32 = 16778387;
pub const XKB_KEY_Cyrillic_ZHE_descender: u32 = 16778390;
pub const XKB_KEY_Cyrillic_zhe_descender: u32 = 16778391;
pub const XKB_KEY_Cyrillic_KA_descender: u32 = 16778394;
pub const XKB_KEY_Cyrillic_ka_descender: u32 = 16778395;
pub const XKB_KEY_Cyrillic_KA_vertstroke: u32 = 16778396;
pub const XKB_KEY_Cyrillic_ka_vertstroke: u32 = 16778397;
pub const XKB_KEY_Cyrillic_EN_descender: u32 = 16778402;
pub const XKB_KEY_Cyrillic_en_descender: u32 = 16778403;
pub const XKB_KEY_Cyrillic_U_straight: u32 = 16778414;
pub const XKB_KEY_Cyrillic_u_straight: u32 = 16778415;
pub const XKB_KEY_Cyrillic_U_straight_bar: u32 = 16778416;
pub const XKB_KEY_Cyrillic_u_straight_bar: u32 = 16778417;
pub const XKB_KEY_Cyrillic_HA_descender: u32 = 16778418;
pub const XKB_KEY_Cyrillic_ha_descender: u32 = 16778419;
pub const XKB_KEY_Cyrillic_CHE_descender: u32 = 16778422;
pub const XKB_KEY_Cyrillic_che_descender: u32 = 16778423;
pub const XKB_KEY_Cyrillic_CHE_vertstroke: u32 = 16778424;
pub const XKB_KEY_Cyrillic_che_vertstroke: u32 = 16778425;
pub const XKB_KEY_Cyrillic_SHHA: u32 = 16778426;
pub const XKB_KEY_Cyrillic_shha: u32 = 16778427;
pub const XKB_KEY_Cyrillic_SCHWA: u32 = 16778456;
pub const XKB_KEY_Cyrillic_schwa: u32 = 16778457;
pub const XKB_KEY_Cyrillic_I_macron: u32 = 16778466;
pub const XKB_KEY_Cyrillic_i_macron: u32 = 16778467;
pub const XKB_KEY_Cyrillic_O_bar: u32 = 16778472;
pub const XKB_KEY_Cyrillic_o_bar: u32 = 16778473;
pub const XKB_KEY_Cyrillic_U_macron: u32 = 16778478;
pub const XKB_KEY_Cyrillic_u_macron: u32 = 16778479;
pub const XKB_KEY_Serbian_dje: u32 = 1697;
pub const XKB_KEY_Macedonia_gje: u32 = 1698;
pub const XKB_KEY_Cyrillic_io: u32 = 1699;
pub const XKB_KEY_Ukrainian_ie: u32 = 1700;
pub const XKB_KEY_Ukranian_je: u32 = 1700;
pub const XKB_KEY_Macedonia_dse: u32 = 1701;
pub const XKB_KEY_Ukrainian_i: u32 = 1702;
pub const XKB_KEY_Ukranian_i: u32 = 1702;
pub const XKB_KEY_Ukrainian_yi: u32 = 1703;
pub const XKB_KEY_Ukranian_yi: u32 = 1703;
pub const XKB_KEY_Cyrillic_je: u32 = 1704;
pub const XKB_KEY_Serbian_je: u32 = 1704;
pub const XKB_KEY_Cyrillic_lje: u32 = 1705;
pub const XKB_KEY_Serbian_lje: u32 = 1705;
pub const XKB_KEY_Cyrillic_nje: u32 = 1706;
pub const XKB_KEY_Serbian_nje: u32 = 1706;
pub const XKB_KEY_Serbian_tshe: u32 = 1707;
pub const XKB_KEY_Macedonia_kje: u32 = 1708;
pub const XKB_KEY_Ukrainian_ghe_with_upturn: u32 = 1709;
pub const XKB_KEY_Byelorussian_shortu: u32 = 1710;
pub const XKB_KEY_Cyrillic_dzhe: u32 = 1711;
pub const XKB_KEY_Serbian_dze: u32 = 1711;
pub const XKB_KEY_numerosign: u32 = 1712;
pub const XKB_KEY_Serbian_DJE: u32 = 1713;
pub const XKB_KEY_Macedonia_GJE: u32 = 1714;
pub const XKB_KEY_Cyrillic_IO: u32 = 1715;
pub const XKB_KEY_Ukrainian_IE: u32 = 1716;
pub const XKB_KEY_Ukranian_JE: u32 = 1716;
pub const XKB_KEY_Macedonia_DSE: u32 = 1717;
pub const XKB_KEY_Ukrainian_I: u32 = 1718;
pub const XKB_KEY_Ukranian_I: u32 = 1718;
pub const XKB_KEY_Ukrainian_YI: u32 = 1719;
pub const XKB_KEY_Ukranian_YI: u32 = 1719;
pub const XKB_KEY_Cyrillic_JE: u32 = 1720;
pub const XKB_KEY_Serbian_JE: u32 = 1720;
pub const XKB_KEY_Cyrillic_LJE: u32 = 1721;
pub const XKB_KEY_Serbian_LJE: u32 = 1721;
pub const XKB_KEY_Cyrillic_NJE: u32 = 1722;
pub const XKB_KEY_Serbian_NJE: u32 = 1722;
pub const XKB_KEY_Serbian_TSHE: u32 = 1723;
pub const XKB_KEY_Macedonia_KJE: u32 = 1724;
pub const XKB_KEY_Ukrainian_GHE_WITH_UPTURN: u32 = 1725;
pub const XKB_KEY_Byelorussian_SHORTU: u32 = 1726;
pub const XKB_KEY_Cyrillic_DZHE: u32 = 1727;
pub const XKB_KEY_Serbian_DZE: u32 = 1727;
pub const XKB_KEY_Cyrillic_yu: u32 = 1728;
pub const XKB_KEY_Cyrillic_a: u32 = 1729;
pub const XKB_KEY_Cyrillic_be: u32 = 1730;
pub const XKB_KEY_Cyrillic_tse: u32 = 1731;
pub const XKB_KEY_Cyrillic_de: u32 = 1732;
pub const XKB_KEY_Cyrillic_ie: u32 = 1733;
pub const XKB_KEY_Cyrillic_ef: u32 = 1734;
pub const XKB_KEY_Cyrillic_ghe: u32 = 1735;
pub const XKB_KEY_Cyrillic_ha: u32 = 1736;
pub const XKB_KEY_Cyrillic_i: u32 = 1737;
pub const XKB_KEY_Cyrillic_shorti: u32 = 1738;
pub const XKB_KEY_Cyrillic_ka: u32 = 1739;
pub const XKB_KEY_Cyrillic_el: u32 = 1740;
pub const XKB_KEY_Cyrillic_em: u32 = 1741;
pub const XKB_KEY_Cyrillic_en: u32 = 1742;
pub const XKB_KEY_Cyrillic_o: u32 = 1743;
pub const XKB_KEY_Cyrillic_pe: u32 = 1744;
pub const XKB_KEY_Cyrillic_ya: u32 = 1745;
pub const XKB_KEY_Cyrillic_er: u32 = 1746;
pub const XKB_KEY_Cyrillic_es: u32 = 1747;
pub const XKB_KEY_Cyrillic_te: u32 = 1748;
pub const XKB_KEY_Cyrillic_u: u32 = 1749;
pub const XKB_KEY_Cyrillic_zhe: u32 = 1750;
pub const XKB_KEY_Cyrillic_ve: u32 = 1751;
pub const XKB_KEY_Cyrillic_softsign: u32 = 1752;
pub const XKB_KEY_Cyrillic_yeru: u32 = 1753;
pub const XKB_KEY_Cyrillic_ze: u32 = 1754;
pub const XKB_KEY_Cyrillic_sha: u32 = 1755;
pub const XKB_KEY_Cyrillic_e: u32 = 1756;
pub const XKB_KEY_Cyrillic_shcha: u32 = 1757;
pub const XKB_KEY_Cyrillic_che: u32 = 1758;
pub const XKB_KEY_Cyrillic_hardsign: u32 = 1759;
pub const XKB_KEY_Cyrillic_YU: u32 = 1760;
pub const XKB_KEY_Cyrillic_A: u32 = 1761;
pub const XKB_KEY_Cyrillic_BE: u32 = 1762;
pub const XKB_KEY_Cyrillic_TSE: u32 = 1763;
pub const XKB_KEY_Cyrillic_DE: u32 = 1764;
pub const XKB_KEY_Cyrillic_IE: u32 = 1765;
pub const XKB_KEY_Cyrillic_EF: u32 = 1766;
pub const XKB_KEY_Cyrillic_GHE: u32 = 1767;
pub const XKB_KEY_Cyrillic_HA: u32 = 1768;
pub const XKB_KEY_Cyrillic_I: u32 = 1769;
pub const XKB_KEY_Cyrillic_SHORTI: u32 = 1770;
pub const XKB_KEY_Cyrillic_KA: u32 = 1771;
pub const XKB_KEY_Cyrillic_EL: u32 = 1772;
pub const XKB_KEY_Cyrillic_EM: u32 = 1773;
pub const XKB_KEY_Cyrillic_EN: u32 = 1774;
pub const XKB_KEY_Cyrillic_O: u32 = 1775;
pub const XKB_KEY_Cyrillic_PE: u32 = 1776;
pub const XKB_KEY_Cyrillic_YA: u32 = 1777;
pub const XKB_KEY_Cyrillic_ER: u32 = 1778;
pub const XKB_KEY_Cyrillic_ES: u32 = 1779;
pub const XKB_KEY_Cyrillic_TE: u32 = 1780;
pub const XKB_KEY_Cyrillic_U: u32 = 1781;
pub const XKB_KEY_Cyrillic_ZHE: u32 = 1782;
pub const XKB_KEY_Cyrillic_VE: u32 = 1783;
pub const XKB_KEY_Cyrillic_SOFTSIGN: u32 = 1784;
pub const XKB_KEY_Cyrillic_YERU: u32 = 1785;
pub const XKB_KEY_Cyrillic_ZE: u32 = 1786;
pub const XKB_KEY_Cyrillic_SHA: u32 = 1787;
pub const XKB_KEY_Cyrillic_E: u32 = 1788;
pub const XKB_KEY_Cyrillic_SHCHA: u32 = 1789;
pub const XKB_KEY_Cyrillic_CHE: u32 = 1790;
pub const XKB_KEY_Cyrillic_HARDSIGN: u32 = 1791;
pub const XKB_KEY_Greek_ALPHAaccent: u32 = 1953;
pub const XKB_KEY_Greek_EPSILONaccent: u32 = 1954;
pub const XKB_KEY_Greek_ETAaccent: u32 = 1955;
pub const XKB_KEY_Greek_IOTAaccent: u32 = 1956;
pub const XKB_KEY_Greek_IOTAdieresis: u32 = 1957;
pub const XKB_KEY_Greek_IOTAdiaeresis: u32 = 1957;
pub const XKB_KEY_Greek_OMICRONaccent: u32 = 1959;
pub const XKB_KEY_Greek_UPSILONaccent: u32 = 1960;
pub const XKB_KEY_Greek_UPSILONdieresis: u32 = 1961;
pub const XKB_KEY_Greek_OMEGAaccent: u32 = 1963;
pub const XKB_KEY_Greek_accentdieresis: u32 = 1966;
pub const XKB_KEY_Greek_horizbar: u32 = 1967;
pub const XKB_KEY_Greek_alphaaccent: u32 = 1969;
pub const XKB_KEY_Greek_epsilonaccent: u32 = 1970;
pub const XKB_KEY_Greek_etaaccent: u32 = 1971;
pub const XKB_KEY_Greek_iotaaccent: u32 = 1972;
pub const XKB_KEY_Greek_iotadieresis: u32 = 1973;
pub const XKB_KEY_Greek_iotaaccentdieresis: u32 = 1974;
pub const XKB_KEY_Greek_omicronaccent: u32 = 1975;
pub const XKB_KEY_Greek_upsilonaccent: u32 = 1976;
pub const XKB_KEY_Greek_upsilondieresis: u32 = 1977;
pub const XKB_KEY_Greek_upsilonaccentdieresis: u32 = 1978;
pub const XKB_KEY_Greek_omegaaccent: u32 = 1979;
pub const XKB_KEY_Greek_ALPHA: u32 = 1985;
pub const XKB_KEY_Greek_BETA: u32 = 1986;
pub const XKB_KEY_Greek_GAMMA: u32 = 1987;
pub const XKB_KEY_Greek_DELTA: u32 = 1988;
pub const XKB_KEY_Greek_EPSILON: u32 = 1989;
pub const XKB_KEY_Greek_ZETA: u32 = 1990;
pub const XKB_KEY_Greek_ETA: u32 = 1991;
pub const XKB_KEY_Greek_THETA: u32 = 1992;
pub const XKB_KEY_Greek_IOTA: u32 = 1993;
pub const XKB_KEY_Greek_KAPPA: u32 = 1994;
pub const XKB_KEY_Greek_LAMDA: u32 = 1995;
pub const XKB_KEY_Greek_LAMBDA: u32 = 1995;
pub const XKB_KEY_Greek_MU: u32 = 1996;
pub const XKB_KEY_Greek_NU: u32 = 1997;
pub const XKB_KEY_Greek_XI: u32 = 1998;
pub const XKB_KEY_Greek_OMICRON: u32 = 1999;
pub const XKB_KEY_Greek_PI: u32 = 2000;
pub const XKB_KEY_Greek_RHO: u32 = 2001;
pub const XKB_KEY_Greek_SIGMA: u32 = 2002;
pub const XKB_KEY_Greek_TAU: u32 = 2004;
pub const XKB_KEY_Greek_UPSILON: u32 = 2005;
pub const XKB_KEY_Greek_PHI: u32 = 2006;
pub const XKB_KEY_Greek_CHI: u32 = 2007;
pub const XKB_KEY_Greek_PSI: u32 = 2008;
pub const XKB_KEY_Greek_OMEGA: u32 = 2009;
pub const XKB_KEY_Greek_alpha: u32 = 2017;
pub const XKB_KEY_Greek_beta: u32 = 2018;
pub const XKB_KEY_Greek_gamma: u32 = 2019;
pub const XKB_KEY_Greek_delta: u32 = 2020;
pub const XKB_KEY_Greek_epsilon: u32 = 2021;
pub const XKB_KEY_Greek_zeta: u32 = 2022;
pub const XKB_KEY_Greek_eta: u32 = 2023;
pub const XKB_KEY_Greek_theta: u32 = 2024;
pub const XKB_KEY_Greek_iota: u32 = 2025;
pub const XKB_KEY_Greek_kappa: u32 = 2026;
pub const XKB_KEY_Greek_lamda: u32 = 2027;
pub const XKB_KEY_Greek_lambda: u32 = 2027;
pub const XKB_KEY_Greek_mu: u32 = 2028;
pub const XKB_KEY_Greek_nu: u32 = 2029;
pub const XKB_KEY_Greek_xi: u32 = 2030;
pub const XKB_KEY_Greek_omicron: u32 = 2031;
pub const XKB_KEY_Greek_pi: u32 = 2032;
pub const XKB_KEY_Greek_rho: u32 = 2033;
pub const XKB_KEY_Greek_sigma: u32 = 2034;
pub const XKB_KEY_Greek_finalsmallsigma: u32 = 2035;
pub const XKB_KEY_Greek_tau: u32 = 2036;
pub const XKB_KEY_Greek_upsilon: u32 = 2037;
pub const XKB_KEY_Greek_phi: u32 = 2038;
pub const XKB_KEY_Greek_chi: u32 = 2039;
pub const XKB_KEY_Greek_psi: u32 = 2040;
pub const XKB_KEY_Greek_omega: u32 = 2041;
pub const XKB_KEY_Greek_switch: u32 = 65406;
pub const XKB_KEY_leftradical: u32 = 2209;
pub const XKB_KEY_topleftradical: u32 = 2210;
pub const XKB_KEY_horizconnector: u32 = 2211;
pub const XKB_KEY_topintegral: u32 = 2212;
pub const XKB_KEY_botintegral: u32 = 2213;
pub const XKB_KEY_vertconnector: u32 = 2214;
pub const XKB_KEY_topleftsqbracket: u32 = 2215;
pub const XKB_KEY_botleftsqbracket: u32 = 2216;
pub const XKB_KEY_toprightsqbracket: u32 = 2217;
pub const XKB_KEY_botrightsqbracket: u32 = 2218;
pub const XKB_KEY_topleftparens: u32 = 2219;
pub const XKB_KEY_botleftparens: u32 = 2220;
pub const XKB_KEY_toprightparens: u32 = 2221;
pub const XKB_KEY_botrightparens: u32 = 2222;
pub const XKB_KEY_leftmiddlecurlybrace: u32 = 2223;
pub const XKB_KEY_rightmiddlecurlybrace: u32 = 2224;
pub const XKB_KEY_topleftsummation: u32 = 2225;
pub const XKB_KEY_botleftsummation: u32 = 2226;
pub const XKB_KEY_topvertsummationconnector: u32 = 2227;
pub const XKB_KEY_botvertsummationconnector: u32 = 2228;
pub const XKB_KEY_toprightsummation: u32 = 2229;
pub const XKB_KEY_botrightsummation: u32 = 2230;
pub const XKB_KEY_rightmiddlesummation: u32 = 2231;
pub const XKB_KEY_lessthanequal: u32 = 2236;
pub const XKB_KEY_notequal: u32 = 2237;
pub const XKB_KEY_greaterthanequal: u32 = 2238;
pub const XKB_KEY_integral: u32 = 2239;
pub const XKB_KEY_therefore: u32 = 2240;
pub const XKB_KEY_variation: u32 = 2241;
pub const XKB_KEY_infinity: u32 = 2242;
pub const XKB_KEY_nabla: u32 = 2245;
pub const XKB_KEY_approximate: u32 = 2248;
pub const XKB_KEY_similarequal: u32 = 2249;
pub const XKB_KEY_ifonlyif: u32 = 2253;
pub const XKB_KEY_implies: u32 = 2254;
pub const XKB_KEY_identical: u32 = 2255;
pub const XKB_KEY_radical: u32 = 2262;
pub const XKB_KEY_includedin: u32 = 2266;
pub const XKB_KEY_includes: u32 = 2267;
pub const XKB_KEY_intersection: u32 = 2268;
pub const XKB_KEY_union: u32 = 2269;
pub const XKB_KEY_logicaland: u32 = 2270;
pub const XKB_KEY_logicalor: u32 = 2271;
pub const XKB_KEY_partialderivative: u32 = 2287;
pub const XKB_KEY_function: u32 = 2294;
pub const XKB_KEY_leftarrow: u32 = 2299;
pub const XKB_KEY_uparrow: u32 = 2300;
pub const XKB_KEY_rightarrow: u32 = 2301;
pub const XKB_KEY_downarrow: u32 = 2302;
pub const XKB_KEY_blank: u32 = 2527;
pub const XKB_KEY_soliddiamond: u32 = 2528;
pub const XKB_KEY_checkerboard: u32 = 2529;
pub const XKB_KEY_ht: u32 = 2530;
pub const XKB_KEY_ff: u32 = 2531;
pub const XKB_KEY_cr: u32 = 2532;
pub const XKB_KEY_lf: u32 = 2533;
pub const XKB_KEY_nl: u32 = 2536;
pub const XKB_KEY_vt: u32 = 2537;
pub const XKB_KEY_lowrightcorner: u32 = 2538;
pub const XKB_KEY_uprightcorner: u32 = 2539;
pub const XKB_KEY_upleftcorner: u32 = 2540;
pub const XKB_KEY_lowleftcorner: u32 = 2541;
pub const XKB_KEY_crossinglines: u32 = 2542;
pub const XKB_KEY_horizlinescan1: u32 = 2543;
pub const XKB_KEY_horizlinescan3: u32 = 2544;
pub const XKB_KEY_horizlinescan5: u32 = 2545;
pub const XKB_KEY_horizlinescan7: u32 = 2546;
pub const XKB_KEY_horizlinescan9: u32 = 2547;
pub const XKB_KEY_leftt: u32 = 2548;
pub const XKB_KEY_rightt: u32 = 2549;
pub const XKB_KEY_bott: u32 = 2550;
pub const XKB_KEY_topt: u32 = 2551;
pub const XKB_KEY_vertbar: u32 = 2552;
pub const XKB_KEY_emspace: u32 = 2721;
pub const XKB_KEY_enspace: u32 = 2722;
pub const XKB_KEY_em3space: u32 = 2723;
pub const XKB_KEY_em4space: u32 = 2724;
pub const XKB_KEY_digitspace: u32 = 2725;
pub const XKB_KEY_punctspace: u32 = 2726;
pub const XKB_KEY_thinspace: u32 = 2727;
pub const XKB_KEY_hairspace: u32 = 2728;
pub const XKB_KEY_emdash: u32 = 2729;
pub const XKB_KEY_endash: u32 = 2730;
pub const XKB_KEY_signifblank: u32 = 2732;
pub const XKB_KEY_ellipsis: u32 = 2734;
pub const XKB_KEY_doubbaselinedot: u32 = 2735;
pub const XKB_KEY_onethird: u32 = 2736;
pub const XKB_KEY_twothirds: u32 = 2737;
pub const XKB_KEY_onefifth: u32 = 2738;
pub const XKB_KEY_twofifths: u32 = 2739;
pub const XKB_KEY_threefifths: u32 = 2740;
pub const XKB_KEY_fourfifths: u32 = 2741;
pub const XKB_KEY_onesixth: u32 = 2742;
pub const XKB_KEY_fivesixths: u32 = 2743;
pub const XKB_KEY_careof: u32 = 2744;
pub const XKB_KEY_figdash: u32 = 2747;
pub const XKB_KEY_leftanglebracket: u32 = 2748;
pub const XKB_KEY_decimalpoint: u32 = 2749;
pub const XKB_KEY_rightanglebracket: u32 = 2750;
pub const XKB_KEY_marker: u32 = 2751;
pub const XKB_KEY_oneeighth: u32 = 2755;
pub const XKB_KEY_threeeighths: u32 = 2756;
pub const XKB_KEY_fiveeighths: u32 = 2757;
pub const XKB_KEY_seveneighths: u32 = 2758;
pub const XKB_KEY_trademark: u32 = 2761;
pub const XKB_KEY_signaturemark: u32 = 2762;
pub const XKB_KEY_trademarkincircle: u32 = 2763;
pub const XKB_KEY_leftopentriangle: u32 = 2764;
pub const XKB_KEY_rightopentriangle: u32 = 2765;
pub const XKB_KEY_emopencircle: u32 = 2766;
pub const XKB_KEY_emopenrectangle: u32 = 2767;
pub const XKB_KEY_leftsinglequotemark: u32 = 2768;
pub const XKB_KEY_rightsinglequotemark: u32 = 2769;
pub const XKB_KEY_leftdoublequotemark: u32 = 2770;
pub const XKB_KEY_rightdoublequotemark: u32 = 2771;
pub const XKB_KEY_prescription: u32 = 2772;
pub const XKB_KEY_permille: u32 = 2773;
pub const XKB_KEY_minutes: u32 = 2774;
pub const XKB_KEY_seconds: u32 = 2775;
pub const XKB_KEY_latincross: u32 = 2777;
pub const XKB_KEY_hexagram: u32 = 2778;
pub const XKB_KEY_filledrectbullet: u32 = 2779;
pub const XKB_KEY_filledlefttribullet: u32 = 2780;
pub const XKB_KEY_filledrighttribullet: u32 = 2781;
pub const XKB_KEY_emfilledcircle: u32 = 2782;
pub const XKB_KEY_emfilledrect: u32 = 2783;
pub const XKB_KEY_enopencircbullet: u32 = 2784;
pub const XKB_KEY_enopensquarebullet: u32 = 2785;
pub const XKB_KEY_openrectbullet: u32 = 2786;
pub const XKB_KEY_opentribulletup: u32 = 2787;
pub const XKB_KEY_opentribulletdown: u32 = 2788;
pub const XKB_KEY_openstar: u32 = 2789;
pub const XKB_KEY_enfilledcircbullet: u32 = 2790;
pub const XKB_KEY_enfilledsqbullet: u32 = 2791;
pub const XKB_KEY_filledtribulletup: u32 = 2792;
pub const XKB_KEY_filledtribulletdown: u32 = 2793;
pub const XKB_KEY_leftpointer: u32 = 2794;
pub const XKB_KEY_rightpointer: u32 = 2795;
pub const XKB_KEY_club: u32 = 2796;
pub const XKB_KEY_diamond: u32 = 2797;
pub const XKB_KEY_heart: u32 = 2798;
pub const XKB_KEY_maltesecross: u32 = 2800;
pub const XKB_KEY_dagger: u32 = 2801;
pub const XKB_KEY_doubledagger: u32 = 2802;
pub const XKB_KEY_checkmark: u32 = 2803;
pub const XKB_KEY_ballotcross: u32 = 2804;
pub const XKB_KEY_musicalsharp: u32 = 2805;
pub const XKB_KEY_musicalflat: u32 = 2806;
pub const XKB_KEY_malesymbol: u32 = 2807;
pub const XKB_KEY_femalesymbol: u32 = 2808;
pub const XKB_KEY_telephone: u32 = 2809;
pub const XKB_KEY_telephonerecorder: u32 = 2810;
pub const XKB_KEY_phonographcopyright: u32 = 2811;
pub const XKB_KEY_caret: u32 = 2812;
pub const XKB_KEY_singlelowquotemark: u32 = 2813;
pub const XKB_KEY_doublelowquotemark: u32 = 2814;
pub const XKB_KEY_cursor: u32 = 2815;
pub const XKB_KEY_leftcaret: u32 = 2979;
pub const XKB_KEY_rightcaret: u32 = 2982;
pub const XKB_KEY_downcaret: u32 = 2984;
pub const XKB_KEY_upcaret: u32 = 2985;
pub const XKB_KEY_overbar: u32 = 3008;
pub const XKB_KEY_downtack: u32 = 3010;
pub const XKB_KEY_upshoe: u32 = 3011;
pub const XKB_KEY_downstile: u32 = 3012;
pub const XKB_KEY_underbar: u32 = 3014;
pub const XKB_KEY_jot: u32 = 3018;
pub const XKB_KEY_quad: u32 = 3020;
pub const XKB_KEY_uptack: u32 = 3022;
pub const XKB_KEY_circle: u32 = 3023;
pub const XKB_KEY_upstile: u32 = 3027;
pub const XKB_KEY_downshoe: u32 = 3030;
pub const XKB_KEY_rightshoe: u32 = 3032;
pub const XKB_KEY_leftshoe: u32 = 3034;
pub const XKB_KEY_lefttack: u32 = 3036;
pub const XKB_KEY_righttack: u32 = 3068;
pub const XKB_KEY_hebrew_doublelowline: u32 = 3295;
pub const XKB_KEY_hebrew_aleph: u32 = 3296;
pub const XKB_KEY_hebrew_bet: u32 = 3297;
pub const XKB_KEY_hebrew_beth: u32 = 3297;
pub const XKB_KEY_hebrew_gimel: u32 = 3298;
pub const XKB_KEY_hebrew_gimmel: u32 = 3298;
pub const XKB_KEY_hebrew_dalet: u32 = 3299;
pub const XKB_KEY_hebrew_daleth: u32 = 3299;
pub const XKB_KEY_hebrew_he: u32 = 3300;
pub const XKB_KEY_hebrew_waw: u32 = 3301;
pub const XKB_KEY_hebrew_zain: u32 = 3302;
pub const XKB_KEY_hebrew_zayin: u32 = 3302;
pub const XKB_KEY_hebrew_chet: u32 = 3303;
pub const XKB_KEY_hebrew_het: u32 = 3303;
pub const XKB_KEY_hebrew_tet: u32 = 3304;
pub const XKB_KEY_hebrew_teth: u32 = 3304;
pub const XKB_KEY_hebrew_yod: u32 = 3305;
pub const XKB_KEY_hebrew_finalkaph: u32 = 3306;
pub const XKB_KEY_hebrew_kaph: u32 = 3307;
pub const XKB_KEY_hebrew_lamed: u32 = 3308;
pub const XKB_KEY_hebrew_finalmem: u32 = 3309;
pub const XKB_KEY_hebrew_mem: u32 = 3310;
pub const XKB_KEY_hebrew_finalnun: u32 = 3311;
pub const XKB_KEY_hebrew_nun: u32 = 3312;
pub const XKB_KEY_hebrew_samech: u32 = 3313;
pub const XKB_KEY_hebrew_samekh: u32 = 3313;
pub const XKB_KEY_hebrew_ayin: u32 = 3314;
pub const XKB_KEY_hebrew_finalpe: u32 = 3315;
pub const XKB_KEY_hebrew_pe: u32 = 3316;
pub const XKB_KEY_hebrew_finalzade: u32 = 3317;
pub const XKB_KEY_hebrew_finalzadi: u32 = 3317;
pub const XKB_KEY_hebrew_zade: u32 = 3318;
pub const XKB_KEY_hebrew_zadi: u32 = 3318;
pub const XKB_KEY_hebrew_qoph: u32 = 3319;
pub const XKB_KEY_hebrew_kuf: u32 = 3319;
pub const XKB_KEY_hebrew_resh: u32 = 3320;
pub const XKB_KEY_hebrew_shin: u32 = 3321;
pub const XKB_KEY_hebrew_taw: u32 = 3322;
pub const XKB_KEY_hebrew_taf: u32 = 3322;
pub const XKB_KEY_Hebrew_switch: u32 = 65406;
pub const XKB_KEY_Thai_kokai: u32 = 3489;
pub const XKB_KEY_Thai_khokhai: u32 = 3490;
pub const XKB_KEY_Thai_khokhuat: u32 = 3491;
pub const XKB_KEY_Thai_khokhwai: u32 = 3492;
pub const XKB_KEY_Thai_khokhon: u32 = 3493;
pub const XKB_KEY_Thai_khorakhang: u32 = 3494;
pub const XKB_KEY_Thai_ngongu: u32 = 3495;
pub const XKB_KEY_Thai_chochan: u32 = 3496;
pub const XKB_KEY_Thai_choching: u32 = 3497;
pub const XKB_KEY_Thai_chochang: u32 = 3498;
pub const XKB_KEY_Thai_soso: u32 = 3499;
pub const XKB_KEY_Thai_chochoe: u32 = 3500;
pub const XKB_KEY_Thai_yoying: u32 = 3501;
pub const XKB_KEY_Thai_dochada: u32 = 3502;
pub const XKB_KEY_Thai_topatak: u32 = 3503;
pub const XKB_KEY_Thai_thothan: u32 = 3504;
pub const XKB_KEY_Thai_thonangmontho: u32 = 3505;
pub const XKB_KEY_Thai_thophuthao: u32 = 3506;
pub const XKB_KEY_Thai_nonen: u32 = 3507;
pub const XKB_KEY_Thai_dodek: u32 = 3508;
pub const XKB_KEY_Thai_totao: u32 = 3509;
pub const XKB_KEY_Thai_thothung: u32 = 3510;
pub const XKB_KEY_Thai_thothahan: u32 = 3511;
pub const XKB_KEY_Thai_thothong: u32 = 3512;
pub const XKB_KEY_Thai_nonu: u32 = 3513;
pub const XKB_KEY_Thai_bobaimai: u32 = 3514;
pub const XKB_KEY_Thai_popla: u32 = 3515;
pub const XKB_KEY_Thai_phophung: u32 = 3516;
pub const XKB_KEY_Thai_fofa: u32 = 3517;
pub const XKB_KEY_Thai_phophan: u32 = 3518;
pub const XKB_KEY_Thai_fofan: u32 = 3519;
pub const XKB_KEY_Thai_phosamphao: u32 = 3520;
pub const XKB_KEY_Thai_moma: u32 = 3521;
pub const XKB_KEY_Thai_yoyak: u32 = 3522;
pub const XKB_KEY_Thai_rorua: u32 = 3523;
pub const XKB_KEY_Thai_ru: u32 = 3524;
pub const XKB_KEY_Thai_loling: u32 = 3525;
pub const XKB_KEY_Thai_lu: u32 = 3526;
pub const XKB_KEY_Thai_wowaen: u32 = 3527;
pub const XKB_KEY_Thai_sosala: u32 = 3528;
pub const XKB_KEY_Thai_sorusi: u32 = 3529;
pub const XKB_KEY_Thai_sosua: u32 = 3530;
pub const XKB_KEY_Thai_hohip: u32 = 3531;
pub const XKB_KEY_Thai_lochula: u32 = 3532;
pub const XKB_KEY_Thai_oang: u32 = 3533;
pub const XKB_KEY_Thai_honokhuk: u32 = 3534;
pub const XKB_KEY_Thai_paiyannoi: u32 = 3535;
pub const XKB_KEY_Thai_saraa: u32 = 3536;
pub const XKB_KEY_Thai_maihanakat: u32 = 3537;
pub const XKB_KEY_Thai_saraaa: u32 = 3538;
pub const XKB_KEY_Thai_saraam: u32 = 3539;
pub const XKB_KEY_Thai_sarai: u32 = 3540;
pub const XKB_KEY_Thai_saraii: u32 = 3541;
pub const XKB_KEY_Thai_saraue: u32 = 3542;
pub const XKB_KEY_Thai_sarauee: u32 = 3543;
pub const XKB_KEY_Thai_sarau: u32 = 3544;
pub const XKB_KEY_Thai_sarauu: u32 = 3545;
pub const XKB_KEY_Thai_phinthu: u32 = 3546;
pub const XKB_KEY_Thai_maihanakat_maitho: u32 = 3550;
pub const XKB_KEY_Thai_baht: u32 = 3551;
pub const XKB_KEY_Thai_sarae: u32 = 3552;
pub const XKB_KEY_Thai_saraae: u32 = 3553;
pub const XKB_KEY_Thai_sarao: u32 = 3554;
pub const XKB_KEY_Thai_saraaimaimuan: u32 = 3555;
pub const XKB_KEY_Thai_saraaimaimalai: u32 = 3556;
pub const XKB_KEY_Thai_lakkhangyao: u32 = 3557;
pub const XKB_KEY_Thai_maiyamok: u32 = 3558;
pub const XKB_KEY_Thai_maitaikhu: u32 = 3559;
pub const XKB_KEY_Thai_maiek: u32 = 3560;
pub const XKB_KEY_Thai_maitho: u32 = 3561;
pub const XKB_KEY_Thai_maitri: u32 = 3562;
pub const XKB_KEY_Thai_maichattawa: u32 = 3563;
pub const XKB_KEY_Thai_thanthakhat: u32 = 3564;
pub const XKB_KEY_Thai_nikhahit: u32 = 3565;
pub const XKB_KEY_Thai_leksun: u32 = 3568;
pub const XKB_KEY_Thai_leknung: u32 = 3569;
pub const XKB_KEY_Thai_leksong: u32 = 3570;
pub const XKB_KEY_Thai_leksam: u32 = 3571;
pub const XKB_KEY_Thai_leksi: u32 = 3572;
pub const XKB_KEY_Thai_lekha: u32 = 3573;
pub const XKB_KEY_Thai_lekhok: u32 = 3574;
pub const XKB_KEY_Thai_lekchet: u32 = 3575;
pub const XKB_KEY_Thai_lekpaet: u32 = 3576;
pub const XKB_KEY_Thai_lekkao: u32 = 3577;
pub const XKB_KEY_Hangul: u32 = 65329;
pub const XKB_KEY_Hangul_Start: u32 = 65330;
pub const XKB_KEY_Hangul_End: u32 = 65331;
pub const XKB_KEY_Hangul_Hanja: u32 = 65332;
pub const XKB_KEY_Hangul_Jamo: u32 = 65333;
pub const XKB_KEY_Hangul_Romaja: u32 = 65334;
pub const XKB_KEY_Hangul_Codeinput: u32 = 65335;
pub const XKB_KEY_Hangul_Jeonja: u32 = 65336;
pub const XKB_KEY_Hangul_Banja: u32 = 65337;
pub const XKB_KEY_Hangul_PreHanja: u32 = 65338;
pub const XKB_KEY_Hangul_PostHanja: u32 = 65339;
pub const XKB_KEY_Hangul_SingleCandidate: u32 = 65340;
pub const XKB_KEY_Hangul_MultipleCandidate: u32 = 65341;
pub const XKB_KEY_Hangul_PreviousCandidate: u32 = 65342;
pub const XKB_KEY_Hangul_Special: u32 = 65343;
pub const XKB_KEY_Hangul_switch: u32 = 65406;
pub const XKB_KEY_Hangul_Kiyeog: u32 = 3745;
pub const XKB_KEY_Hangul_SsangKiyeog: u32 = 3746;
pub const XKB_KEY_Hangul_KiyeogSios: u32 = 3747;
pub const XKB_KEY_Hangul_Nieun: u32 = 3748;
pub const XKB_KEY_Hangul_NieunJieuj: u32 = 3749;
pub const XKB_KEY_Hangul_NieunHieuh: u32 = 3750;
pub const XKB_KEY_Hangul_Dikeud: u32 = 3751;
pub const XKB_KEY_Hangul_SsangDikeud: u32 = 3752;
pub const XKB_KEY_Hangul_Rieul: u32 = 3753;
pub const XKB_KEY_Hangul_RieulKiyeog: u32 = 3754;
pub const XKB_KEY_Hangul_RieulMieum: u32 = 3755;
pub const XKB_KEY_Hangul_RieulPieub: u32 = 3756;
pub const XKB_KEY_Hangul_RieulSios: u32 = 3757;
pub const XKB_KEY_Hangul_RieulTieut: u32 = 3758;
pub const XKB_KEY_Hangul_RieulPhieuf: u32 = 3759;
pub const XKB_KEY_Hangul_RieulHieuh: u32 = 3760;
pub const XKB_KEY_Hangul_Mieum: u32 = 3761;
pub const XKB_KEY_Hangul_Pieub: u32 = 3762;
pub const XKB_KEY_Hangul_SsangPieub: u32 = 3763;
pub const XKB_KEY_Hangul_PieubSios: u32 = 3764;
pub const XKB_KEY_Hangul_Sios: u32 = 3765;
pub const XKB_KEY_Hangul_SsangSios: u32 = 3766;
pub const XKB_KEY_Hangul_Ieung: u32 = 3767;
pub const XKB_KEY_Hangul_Jieuj: u32 = 3768;
pub const XKB_KEY_Hangul_SsangJieuj: u32 = 3769;
pub const XKB_KEY_Hangul_Cieuc: u32 = 3770;
pub const XKB_KEY_Hangul_Khieuq: u32 = 3771;
pub const XKB_KEY_Hangul_Tieut: u32 = 3772;
pub const XKB_KEY_Hangul_Phieuf: u32 = 3773;
pub const XKB_KEY_Hangul_Hieuh: u32 = 3774;
pub const XKB_KEY_Hangul_A: u32 = 3775;
pub const XKB_KEY_Hangul_AE: u32 = 3776;
pub const XKB_KEY_Hangul_YA: u32 = 3777;
pub const XKB_KEY_Hangul_YAE: u32 = 3778;
pub const XKB_KEY_Hangul_EO: u32 = 3779;
pub const XKB_KEY_Hangul_E: u32 = 3780;
pub const XKB_KEY_Hangul_YEO: u32 = 3781;
pub const XKB_KEY_Hangul_YE: u32 = 3782;
pub const XKB_KEY_Hangul_O: u32 = 3783;
pub const XKB_KEY_Hangul_WA: u32 = 3784;
pub const XKB_KEY_Hangul_WAE: u32 = 3785;
pub const XKB_KEY_Hangul_OE: u32 = 3786;
pub const XKB_KEY_Hangul_YO: u32 = 3787;
pub const XKB_KEY_Hangul_U: u32 = 3788;
pub const XKB_KEY_Hangul_WEO: u32 = 3789;
pub const XKB_KEY_Hangul_WE: u32 = 3790;
pub const XKB_KEY_Hangul_WI: u32 = 3791;
pub const XKB_KEY_Hangul_YU: u32 = 3792;
pub const XKB_KEY_Hangul_EU: u32 = 3793;
pub const XKB_KEY_Hangul_YI: u32 = 3794;
pub const XKB_KEY_Hangul_I: u32 = 3795;
pub const XKB_KEY_Hangul_J_Kiyeog: u32 = 3796;
pub const XKB_KEY_Hangul_J_SsangKiyeog: u32 = 3797;
pub const XKB_KEY_Hangul_J_KiyeogSios: u32 = 3798;
pub const XKB_KEY_Hangul_J_Nieun: u32 = 3799;
pub const XKB_KEY_Hangul_J_NieunJieuj: u32 = 3800;
pub const XKB_KEY_Hangul_J_NieunHieuh: u32 = 3801;
pub const XKB_KEY_Hangul_J_Dikeud: u32 = 3802;
pub const XKB_KEY_Hangul_J_Rieul: u32 = 3803;
pub const XKB_KEY_Hangul_J_RieulKiyeog: u32 = 3804;
pub const XKB_KEY_Hangul_J_RieulMieum: u32 = 3805;
pub const XKB_KEY_Hangul_J_RieulPieub: u32 = 3806;
pub const XKB_KEY_Hangul_J_RieulSios: u32 = 3807;
pub const XKB_KEY_Hangul_J_RieulTieut: u32 = 3808;
pub const XKB_KEY_Hangul_J_RieulPhieuf: u32 = 3809;
pub const XKB_KEY_Hangul_J_RieulHieuh: u32 = 3810;
pub const XKB_KEY_Hangul_J_Mieum: u32 = 3811;
pub const XKB_KEY_Hangul_J_Pieub: u32 = 3812;
pub const XKB_KEY_Hangul_J_PieubSios: u32 = 3813;
pub const XKB_KEY_Hangul_J_Sios: u32 = 3814;
pub const XKB_KEY_Hangul_J_SsangSios: u32 = 3815;
pub const XKB_KEY_Hangul_J_Ieung: u32 = 3816;
pub const XKB_KEY_Hangul_J_Jieuj: u32 = 3817;
pub const XKB_KEY_Hangul_J_Cieuc: u32 = 3818;
pub const XKB_KEY_Hangul_J_Khieuq: u32 = 3819;
pub const XKB_KEY_Hangul_J_Tieut: u32 = 3820;
pub const XKB_KEY_Hangul_J_Phieuf: u32 = 3821;
pub const XKB_KEY_Hangul_J_Hieuh: u32 = 3822;
pub const XKB_KEY_Hangul_RieulYeorinHieuh: u32 = 3823;
pub const XKB_KEY_Hangul_SunkyeongeumMieum: u32 = 3824;
pub const XKB_KEY_Hangul_SunkyeongeumPieub: u32 = 3825;
pub const XKB_KEY_Hangul_PanSios: u32 = 3826;
pub const XKB_KEY_Hangul_KkogjiDalrinIeung: u32 = 3827;
pub const XKB_KEY_Hangul_SunkyeongeumPhieuf: u32 = 3828;
pub const XKB_KEY_Hangul_YeorinHieuh: u32 = 3829;
pub const XKB_KEY_Hangul_AraeA: u32 = 3830;
pub const XKB_KEY_Hangul_AraeAE: u32 = 3831;
pub const XKB_KEY_Hangul_J_PanSios: u32 = 3832;
pub const XKB_KEY_Hangul_J_KkogjiDalrinIeung: u32 = 3833;
pub const XKB_KEY_Hangul_J_YeorinHieuh: u32 = 3834;
pub const XKB_KEY_Korean_Won: u32 = 3839;
pub const XKB_KEY_Armenian_ligature_ew: u32 = 16778631;
pub const XKB_KEY_Armenian_full_stop: u32 = 16778633;
pub const XKB_KEY_Armenian_verjaket: u32 = 16778633;
pub const XKB_KEY_Armenian_separation_mark: u32 = 16778589;
pub const XKB_KEY_Armenian_but: u32 = 16778589;
pub const XKB_KEY_Armenian_hyphen: u32 = 16778634;
pub const XKB_KEY_Armenian_yentamna: u32 = 16778634;
pub const XKB_KEY_Armenian_exclam: u32 = 16778588;
pub const XKB_KEY_Armenian_amanak: u32 = 16778588;
pub const XKB_KEY_Armenian_accent: u32 = 16778587;
pub const XKB_KEY_Armenian_shesht: u32 = 16778587;
pub const XKB_KEY_Armenian_question: u32 = 16778590;
pub const XKB_KEY_Armenian_paruyk: u32 = 16778590;
pub const XKB_KEY_Armenian_AYB: u32 = 16778545;
pub const XKB_KEY_Armenian_ayb: u32 = 16778593;
pub const XKB_KEY_Armenian_BEN: u32 = 16778546;
pub const XKB_KEY_Armenian_ben: u32 = 16778594;
pub const XKB_KEY_Armenian_GIM: u32 = 16778547;
pub const XKB_KEY_Armenian_gim: u32 = 16778595;
pub const XKB_KEY_Armenian_DA: u32 = 16778548;
pub const XKB_KEY_Armenian_da: u32 = 16778596;
pub const XKB_KEY_Armenian_YECH: u32 = 16778549;
pub const XKB_KEY_Armenian_yech: u32 = 16778597;
pub const XKB_KEY_Armenian_ZA: u32 = 16778550;
pub const XKB_KEY_Armenian_za: u32 = 16778598;
pub const XKB_KEY_Armenian_E: u32 = 16778551;
pub const XKB_KEY_Armenian_e: u32 = 16778599;
pub const XKB_KEY_Armenian_AT: u32 = 16778552;
pub const XKB_KEY_Armenian_at: u32 = 16778600;
pub const XKB_KEY_Armenian_TO: u32 = 16778553;
pub const XKB_KEY_Armenian_to: u32 = 16778601;
pub const XKB_KEY_Armenian_ZHE: u32 = 16778554;
pub const XKB_KEY_Armenian_zhe: u32 = 16778602;
pub const XKB_KEY_Armenian_INI: u32 = 16778555;
pub const XKB_KEY_Armenian_ini: u32 = 16778603;
pub const XKB_KEY_Armenian_LYUN: u32 = 16778556;
pub const XKB_KEY_Armenian_lyun: u32 = 16778604;
pub const XKB_KEY_Armenian_KHE: u32 = 16778557;
pub const XKB_KEY_Armenian_khe: u32 = 16778605;
pub const XKB_KEY_Armenian_TSA: u32 = 16778558;
pub const XKB_KEY_Armenian_tsa: u32 = 16778606;
pub const XKB_KEY_Armenian_KEN: u32 = 16778559;
pub const XKB_KEY_Armenian_ken: u32 = 16778607;
pub const XKB_KEY_Armenian_HO: u32 = 16778560;
pub const XKB_KEY_Armenian_ho: u32 = 16778608;
pub const XKB_KEY_Armenian_DZA: u32 = 16778561;
pub const XKB_KEY_Armenian_dza: u32 = 16778609;
pub const XKB_KEY_Armenian_GHAT: u32 = 16778562;
pub const XKB_KEY_Armenian_ghat: u32 = 16778610;
pub const XKB_KEY_Armenian_TCHE: u32 = 16778563;
pub const XKB_KEY_Armenian_tche: u32 = 16778611;
pub const XKB_KEY_Armenian_MEN: u32 = 16778564;
pub const XKB_KEY_Armenian_men: u32 = 16778612;
pub const XKB_KEY_Armenian_HI: u32 = 16778565;
pub const XKB_KEY_Armenian_hi: u32 = 16778613;
pub const XKB_KEY_Armenian_NU: u32 = 16778566;
pub const XKB_KEY_Armenian_nu: u32 = 16778614;
pub const XKB_KEY_Armenian_SHA: u32 = 16778567;
pub const XKB_KEY_Armenian_sha: u32 = 16778615;
pub const XKB_KEY_Armenian_VO: u32 = 16778568;
pub const XKB_KEY_Armenian_vo: u32 = 16778616;
pub const XKB_KEY_Armenian_CHA: u32 = 16778569;
pub const XKB_KEY_Armenian_cha: u32 = 16778617;
pub const XKB_KEY_Armenian_PE: u32 = 16778570;
pub const XKB_KEY_Armenian_pe: u32 = 16778618;
pub const XKB_KEY_Armenian_JE: u32 = 16778571;
pub const XKB_KEY_Armenian_je: u32 = 16778619;
pub const XKB_KEY_Armenian_RA: u32 = 16778572;
pub const XKB_KEY_Armenian_ra: u32 = 16778620;
pub const XKB_KEY_Armenian_SE: u32 = 16778573;
pub const XKB_KEY_Armenian_se: u32 = 16778621;
pub const XKB_KEY_Armenian_VEV: u32 = 16778574;
pub const XKB_KEY_Armenian_vev: u32 = 16778622;
pub const XKB_KEY_Armenian_TYUN: u32 = 16778575;
pub const XKB_KEY_Armenian_tyun: u32 = 16778623;
pub const XKB_KEY_Armenian_RE: u32 = 16778576;
pub const XKB_KEY_Armenian_re: u32 = 16778624;
pub const XKB_KEY_Armenian_TSO: u32 = 16778577;
pub const XKB_KEY_Armenian_tso: u32 = 16778625;
pub const XKB_KEY_Armenian_VYUN: u32 = 16778578;
pub const XKB_KEY_Armenian_vyun: u32 = 16778626;
pub const XKB_KEY_Armenian_PYUR: u32 = 16778579;
pub const XKB_KEY_Armenian_pyur: u32 = 16778627;
pub const XKB_KEY_Armenian_KE: u32 = 16778580;
pub const XKB_KEY_Armenian_ke: u32 = 16778628;
pub const XKB_KEY_Armenian_O: u32 = 16778581;
pub const XKB_KEY_Armenian_o: u32 = 16778629;
pub const XKB_KEY_Armenian_FE: u32 = 16778582;
pub const XKB_KEY_Armenian_fe: u32 = 16778630;
pub const XKB_KEY_Armenian_apostrophe: u32 = 16778586;
pub const XKB_KEY_Georgian_an: u32 = 16781520;
pub const XKB_KEY_Georgian_ban: u32 = 16781521;
pub const XKB_KEY_Georgian_gan: u32 = 16781522;
pub const XKB_KEY_Georgian_don: u32 = 16781523;
pub const XKB_KEY_Georgian_en: u32 = 16781524;
pub const XKB_KEY_Georgian_vin: u32 = 16781525;
pub const XKB_KEY_Georgian_zen: u32 = 16781526;
pub const XKB_KEY_Georgian_tan: u32 = 16781527;
pub const XKB_KEY_Georgian_in: u32 = 16781528;
pub const XKB_KEY_Georgian_kan: u32 = 16781529;
pub const XKB_KEY_Georgian_las: u32 = 16781530;
pub const XKB_KEY_Georgian_man: u32 = 16781531;
pub const XKB_KEY_Georgian_nar: u32 = 16781532;
pub const XKB_KEY_Georgian_on: u32 = 16781533;
pub const XKB_KEY_Georgian_par: u32 = 16781534;
pub const XKB_KEY_Georgian_zhar: u32 = 16781535;
pub const XKB_KEY_Georgian_rae: u32 = 16781536;
pub const XKB_KEY_Georgian_san: u32 = 16781537;
pub const XKB_KEY_Georgian_tar: u32 = 16781538;
pub const XKB_KEY_Georgian_un: u32 = 16781539;
pub const XKB_KEY_Georgian_phar: u32 = 16781540;
pub const XKB_KEY_Georgian_khar: u32 = 16781541;
pub const XKB_KEY_Georgian_ghan: u32 = 16781542;
pub const XKB_KEY_Georgian_qar: u32 = 16781543;
pub const XKB_KEY_Georgian_shin: u32 = 16781544;
pub const XKB_KEY_Georgian_chin: u32 = 16781545;
pub const XKB_KEY_Georgian_can: u32 = 16781546;
pub const XKB_KEY_Georgian_jil: u32 = 16781547;
pub const XKB_KEY_Georgian_cil: u32 = 16781548;
pub const XKB_KEY_Georgian_char: u32 = 16781549;
pub const XKB_KEY_Georgian_xan: u32 = 16781550;
pub const XKB_KEY_Georgian_jhan: u32 = 16781551;
pub const XKB_KEY_Georgian_hae: u32 = 16781552;
pub const XKB_KEY_Georgian_he: u32 = 16781553;
pub const XKB_KEY_Georgian_hie: u32 = 16781554;
pub const XKB_KEY_Georgian_we: u32 = 16781555;
pub const XKB_KEY_Georgian_har: u32 = 16781556;
pub const XKB_KEY_Georgian_hoe: u32 = 16781557;
pub const XKB_KEY_Georgian_fi: u32 = 16781558;
pub const XKB_KEY_Xabovedot: u32 = 16785034;
pub const XKB_KEY_Ibreve: u32 = 16777516;
pub const XKB_KEY_Zstroke: u32 = 16777653;
pub const XKB_KEY_Gcaron: u32 = 16777702;
pub const XKB_KEY_Ocaron: u32 = 16777681;
pub const XKB_KEY_Obarred: u32 = 16777631;
pub const XKB_KEY_xabovedot: u32 = 16785035;
pub const XKB_KEY_ibreve: u32 = 16777517;
pub const XKB_KEY_zstroke: u32 = 16777654;
pub const XKB_KEY_gcaron: u32 = 16777703;
pub const XKB_KEY_ocaron: u32 = 16777682;
pub const XKB_KEY_obarred: u32 = 16777845;
pub const XKB_KEY_SCHWA: u32 = 16777615;
pub const XKB_KEY_schwa: u32 = 16777817;
pub const XKB_KEY_EZH: u32 = 16777655;
pub const XKB_KEY_ezh: u32 = 16777874;
pub const XKB_KEY_Lbelowdot: u32 = 16784950;
pub const XKB_KEY_lbelowdot: u32 = 16784951;
pub const XKB_KEY_Abelowdot: u32 = 16785056;
pub const XKB_KEY_abelowdot: u32 = 16785057;
pub const XKB_KEY_Ahook: u32 = 16785058;
pub const XKB_KEY_ahook: u32 = 16785059;
pub const XKB_KEY_Acircumflexacute: u32 = 16785060;
pub const XKB_KEY_acircumflexacute: u32 = 16785061;
pub const XKB_KEY_Acircumflexgrave: u32 = 16785062;
pub const XKB_KEY_acircumflexgrave: u32 = 16785063;
pub const XKB_KEY_Acircumflexhook: u32 = 16785064;
pub const XKB_KEY_acircumflexhook: u32 = 16785065;
pub const XKB_KEY_Acircumflextilde: u32 = 16785066;
pub const XKB_KEY_acircumflextilde: u32 = 16785067;
pub const XKB_KEY_Acircumflexbelowdot: u32 = 16785068;
pub const XKB_KEY_acircumflexbelowdot: u32 = 16785069;
pub const XKB_KEY_Abreveacute: u32 = 16785070;
pub const XKB_KEY_abreveacute: u32 = 16785071;
pub const XKB_KEY_Abrevegrave: u32 = 16785072;
pub const XKB_KEY_abrevegrave: u32 = 16785073;
pub const XKB_KEY_Abrevehook: u32 = 16785074;
pub const XKB_KEY_abrevehook: u32 = 16785075;
pub const XKB_KEY_Abrevetilde: u32 = 16785076;
pub const XKB_KEY_abrevetilde: u32 = 16785077;
pub const XKB_KEY_Abrevebelowdot: u32 = 16785078;
pub const XKB_KEY_abrevebelowdot: u32 = 16785079;
pub const XKB_KEY_Ebelowdot: u32 = 16785080;
pub const XKB_KEY_ebelowdot: u32 = 16785081;
pub const XKB_KEY_Ehook: u32 = 16785082;
pub const XKB_KEY_ehook: u32 = 16785083;
pub const XKB_KEY_Etilde: u32 = 16785084;
pub const XKB_KEY_etilde: u32 = 16785085;
pub const XKB_KEY_Ecircumflexacute: u32 = 16785086;
pub const XKB_KEY_ecircumflexacute: u32 = 16785087;
pub const XKB_KEY_Ecircumflexgrave: u32 = 16785088;
pub const XKB_KEY_ecircumflexgrave: u32 = 16785089;
pub const XKB_KEY_Ecircumflexhook: u32 = 16785090;
pub const XKB_KEY_ecircumflexhook: u32 = 16785091;
pub const XKB_KEY_Ecircumflextilde: u32 = 16785092;
pub const XKB_KEY_ecircumflextilde: u32 = 16785093;
pub const XKB_KEY_Ecircumflexbelowdot: u32 = 16785094;
pub const XKB_KEY_ecircumflexbelowdot: u32 = 16785095;
pub const XKB_KEY_Ihook: u32 = 16785096;
pub const XKB_KEY_ihook: u32 = 16785097;
pub const XKB_KEY_Ibelowdot: u32 = 16785098;
pub const XKB_KEY_ibelowdot: u32 = 16785099;
pub const XKB_KEY_Obelowdot: u32 = 16785100;
pub const XKB_KEY_obelowdot: u32 = 16785101;
pub const XKB_KEY_Ohook: u32 = 16785102;
pub const XKB_KEY_ohook: u32 = 16785103;
pub const XKB_KEY_Ocircumflexacute: u32 = 16785104;
pub const XKB_KEY_ocircumflexacute: u32 = 16785105;
pub const XKB_KEY_Ocircumflexgrave: u32 = 16785106;
pub const XKB_KEY_ocircumflexgrave: u32 = 16785107;
pub const XKB_KEY_Ocircumflexhook: u32 = 16785108;
pub const XKB_KEY_ocircumflexhook: u32 = 16785109;
pub const XKB_KEY_Ocircumflextilde: u32 = 16785110;
pub const XKB_KEY_ocircumflextilde: u32 = 16785111;
pub const XKB_KEY_Ocircumflexbelowdot: u32 = 16785112;
pub const XKB_KEY_ocircumflexbelowdot: u32 = 16785113;
pub const XKB_KEY_Ohornacute: u32 = 16785114;
pub const XKB_KEY_ohornacute: u32 = 16785115;
pub const XKB_KEY_Ohorngrave: u32 = 16785116;
pub const XKB_KEY_ohorngrave: u32 = 16785117;
pub const XKB_KEY_Ohornhook: u32 = 16785118;
pub const XKB_KEY_ohornhook: u32 = 16785119;
pub const XKB_KEY_Ohorntilde: u32 = 16785120;
pub const XKB_KEY_ohorntilde: u32 = 16785121;
pub const XKB_KEY_Ohornbelowdot: u32 = 16785122;
pub const XKB_KEY_ohornbelowdot: u32 = 16785123;
pub const XKB_KEY_Ubelowdot: u32 = 16785124;
pub const XKB_KEY_ubelowdot: u32 = 16785125;
pub const XKB_KEY_Uhook: u32 = 16785126;
pub const XKB_KEY_uhook: u32 = 16785127;
pub const XKB_KEY_Uhornacute: u32 = 16785128;
pub const XKB_KEY_uhornacute: u32 = 16785129;
pub const XKB_KEY_Uhorngrave: u32 = 16785130;
pub const XKB_KEY_uhorngrave: u32 = 16785131;
pub const XKB_KEY_Uhornhook: u32 = 16785132;
pub const XKB_KEY_uhornhook: u32 = 16785133;
pub const XKB_KEY_Uhorntilde: u32 = 16785134;
pub const XKB_KEY_uhorntilde: u32 = 16785135;
pub const XKB_KEY_Uhornbelowdot: u32 = 16785136;
pub const XKB_KEY_uhornbelowdot: u32 = 16785137;
pub const XKB_KEY_Ybelowdot: u32 = 16785140;
pub const XKB_KEY_ybelowdot: u32 = 16785141;
pub const XKB_KEY_Yhook: u32 = 16785142;
pub const XKB_KEY_yhook: u32 = 16785143;
pub const XKB_KEY_Ytilde: u32 = 16785144;
pub const XKB_KEY_ytilde: u32 = 16785145;
pub const XKB_KEY_Ohorn: u32 = 16777632;
pub const XKB_KEY_ohorn: u32 = 16777633;
pub const XKB_KEY_Uhorn: u32 = 16777647;
pub const XKB_KEY_uhorn: u32 = 16777648;
pub const XKB_KEY_EcuSign: u32 = 16785568;
pub const XKB_KEY_ColonSign: u32 = 16785569;
pub const XKB_KEY_CruzeiroSign: u32 = 16785570;
pub const XKB_KEY_FFrancSign: u32 = 16785571;
pub const XKB_KEY_LiraSign: u32 = 16785572;
pub const XKB_KEY_MillSign: u32 = 16785573;
pub const XKB_KEY_NairaSign: u32 = 16785574;
pub const XKB_KEY_PesetaSign: u32 = 16785575;
pub const XKB_KEY_RupeeSign: u32 = 16785576;
pub const XKB_KEY_WonSign: u32 = 16785577;
pub const XKB_KEY_NewSheqelSign: u32 = 16785578;
pub const XKB_KEY_DongSign: u32 = 16785579;
pub const XKB_KEY_EuroSign: u32 = 8364;
pub const XKB_KEY_zerosuperior: u32 = 16785520;
pub const XKB_KEY_foursuperior: u32 = 16785524;
pub const XKB_KEY_fivesuperior: u32 = 16785525;
pub const XKB_KEY_sixsuperior: u32 = 16785526;
pub const XKB_KEY_sevensuperior: u32 = 16785527;
pub const XKB_KEY_eightsuperior: u32 = 16785528;
pub const XKB_KEY_ninesuperior: u32 = 16785529;
pub const XKB_KEY_zerosubscript: u32 = 16785536;
pub const XKB_KEY_onesubscript: u32 = 16785537;
pub const XKB_KEY_twosubscript: u32 = 16785538;
pub const XKB_KEY_threesubscript: u32 = 16785539;
pub const XKB_KEY_foursubscript: u32 = 16785540;
pub const XKB_KEY_fivesubscript: u32 = 16785541;
pub const XKB_KEY_sixsubscript: u32 = 16785542;
pub const XKB_KEY_sevensubscript: u32 = 16785543;
pub const XKB_KEY_eightsubscript: u32 = 16785544;
pub const XKB_KEY_ninesubscript: u32 = 16785545;
pub const XKB_KEY_partdifferential: u32 = 16785922;
pub const XKB_KEY_emptyset: u32 = 16785925;
pub const XKB_KEY_elementof: u32 = 16785928;
pub const XKB_KEY_notelementof: u32 = 16785929;
pub const XKB_KEY_containsas: u32 = 16785931;
pub const XKB_KEY_squareroot: u32 = 16785946;
pub const XKB_KEY_cuberoot: u32 = 16785947;
pub const XKB_KEY_fourthroot: u32 = 16785948;
pub const XKB_KEY_dintegral: u32 = 16785964;
pub const XKB_KEY_tintegral: u32 = 16785965;
pub const XKB_KEY_because: u32 = 16785973;
pub const XKB_KEY_approxeq: u32 = 16785992;
pub const XKB_KEY_notapproxeq: u32 = 16785991;
pub const XKB_KEY_notidentical: u32 = 16786018;
pub const XKB_KEY_stricteq: u32 = 16786019;
pub const XKB_KEY_braille_dot_1: u32 = 65521;
pub const XKB_KEY_braille_dot_2: u32 = 65522;
pub const XKB_KEY_braille_dot_3: u32 = 65523;
pub const XKB_KEY_braille_dot_4: u32 = 65524;
pub const XKB_KEY_braille_dot_5: u32 = 65525;
pub const XKB_KEY_braille_dot_6: u32 = 65526;
pub const XKB_KEY_braille_dot_7: u32 = 65527;
pub const XKB_KEY_braille_dot_8: u32 = 65528;
pub const XKB_KEY_braille_dot_9: u32 = 65529;
pub const XKB_KEY_braille_dot_10: u32 = 65530;
pub const XKB_KEY_braille_blank: u32 = 16787456;
pub const XKB_KEY_braille_dots_1: u32 = 16787457;
pub const XKB_KEY_braille_dots_2: u32 = 16787458;
pub const XKB_KEY_braille_dots_12: u32 = 16787459;
pub const XKB_KEY_braille_dots_3: u32 = 16787460;
pub const XKB_KEY_braille_dots_13: u32 = 16787461;
pub const XKB_KEY_braille_dots_23: u32 = 16787462;
pub const XKB_KEY_braille_dots_123: u32 = 16787463;
pub const XKB_KEY_braille_dots_4: u32 = 16787464;
pub const XKB_KEY_braille_dots_14: u32 = 16787465;
pub const XKB_KEY_braille_dots_24: u32 = 16787466;
pub const XKB_KEY_braille_dots_124: u32 = 16787467;
pub const XKB_KEY_braille_dots_34: u32 = 16787468;
pub const XKB_KEY_braille_dots_134: u32 = 16787469;
pub const XKB_KEY_braille_dots_234: u32 = 16787470;
pub const XKB_KEY_braille_dots_1234: u32 = 16787471;
pub const XKB_KEY_braille_dots_5: u32 = 16787472;
pub const XKB_KEY_braille_dots_15: u32 = 16787473;
pub const XKB_KEY_braille_dots_25: u32 = 16787474;
pub const XKB_KEY_braille_dots_125: u32 = 16787475;
pub const XKB_KEY_braille_dots_35: u32 = 16787476;
pub const XKB_KEY_braille_dots_135: u32 = 16787477;
pub const XKB_KEY_braille_dots_235: u32 = 16787478;
pub const XKB_KEY_braille_dots_1235: u32 = 16787479;
pub const XKB_KEY_braille_dots_45: u32 = 16787480;
pub const XKB_KEY_braille_dots_145: u32 = 16787481;
pub const XKB_KEY_braille_dots_245: u32 = 16787482;
pub const XKB_KEY_braille_dots_1245: u32 = 16787483;
pub const XKB_KEY_braille_dots_345: u32 = 16787484;
pub const XKB_KEY_braille_dots_1345: u32 = 16787485;
pub const XKB_KEY_braille_dots_2345: u32 = 16787486;
pub const XKB_KEY_braille_dots_12345: u32 = 16787487;
pub const XKB_KEY_braille_dots_6: u32 = 16787488;
pub const XKB_KEY_braille_dots_16: u32 = 16787489;
pub const XKB_KEY_braille_dots_26: u32 = 16787490;
pub const XKB_KEY_braille_dots_126: u32 = 16787491;
pub const XKB_KEY_braille_dots_36: u32 = 16787492;
pub const XKB_KEY_braille_dots_136: u32 = 16787493;
pub const XKB_KEY_braille_dots_236: u32 = 16787494;
pub const XKB_KEY_braille_dots_1236: u32 = 16787495;
pub const XKB_KEY_braille_dots_46: u32 = 16787496;
pub const XKB_KEY_braille_dots_146: u32 = 16787497;
pub const XKB_KEY_braille_dots_246: u32 = 16787498;
pub const XKB_KEY_braille_dots_1246: u32 = 16787499;
pub const XKB_KEY_braille_dots_346: u32 = 16787500;
pub const XKB_KEY_braille_dots_1346: u32 = 16787501;
pub const XKB_KEY_braille_dots_2346: u32 = 16787502;
pub const XKB_KEY_braille_dots_12346: u32 = 16787503;
pub const XKB_KEY_braille_dots_56: u32 = 16787504;
pub const XKB_KEY_braille_dots_156: u32 = 16787505;
pub const XKB_KEY_braille_dots_256: u32 = 16787506;
pub const XKB_KEY_braille_dots_1256: u32 = 16787507;
pub const XKB_KEY_braille_dots_356: u32 = 16787508;
pub const XKB_KEY_braille_dots_1356: u32 = 16787509;
pub const XKB_KEY_braille_dots_2356: u32 = 16787510;
pub const XKB_KEY_braille_dots_12356: u32 = 16787511;
pub const XKB_KEY_braille_dots_456: u32 = 16787512;
pub const XKB_KEY_braille_dots_1456: u32 = 16787513;
pub const XKB_KEY_braille_dots_2456: u32 = 16787514;
pub const XKB_KEY_braille_dots_12456: u32 = 16787515;
pub const XKB_KEY_braille_dots_3456: u32 = 16787516;
pub const XKB_KEY_braille_dots_13456: u32 = 16787517;
pub const XKB_KEY_braille_dots_23456: u32 = 16787518;
pub const XKB_KEY_braille_dots_123456: u32 = 16787519;
pub const XKB_KEY_braille_dots_7: u32 = 16787520;
pub const XKB_KEY_braille_dots_17: u32 = 16787521;
pub const XKB_KEY_braille_dots_27: u32 = 16787522;
pub const XKB_KEY_braille_dots_127: u32 = 16787523;
pub const XKB_KEY_braille_dots_37: u32 = 16787524;
pub const XKB_KEY_braille_dots_137: u32 = 16787525;
pub const XKB_KEY_braille_dots_237: u32 = 16787526;
pub const XKB_KEY_braille_dots_1237: u32 = 16787527;
pub const XKB_KEY_braille_dots_47: u32 = 16787528;
pub const XKB_KEY_braille_dots_147: u32 = 16787529;
pub const XKB_KEY_braille_dots_247: u32 = 16787530;
pub const XKB_KEY_braille_dots_1247: u32 = 16787531;
pub const XKB_KEY_braille_dots_347: u32 = 16787532;
pub const XKB_KEY_braille_dots_1347: u32 = 16787533;
pub const XKB_KEY_braille_dots_2347: u32 = 16787534;
pub const XKB_KEY_braille_dots_12347: u32 = 16787535;
pub const XKB_KEY_braille_dots_57: u32 = 16787536;
pub const XKB_KEY_braille_dots_157: u32 = 16787537;
pub const XKB_KEY_braille_dots_257: u32 = 16787538;
pub const XKB_KEY_braille_dots_1257: u32 = 16787539;
pub const XKB_KEY_braille_dots_357: u32 = 16787540;
pub const XKB_KEY_braille_dots_1357: u32 = 16787541;
pub const XKB_KEY_braille_dots_2357: u32 = 16787542;
pub const XKB_KEY_braille_dots_12357: u32 = 16787543;
pub const XKB_KEY_braille_dots_457: u32 = 16787544;
pub const XKB_KEY_braille_dots_1457: u32 = 16787545;
pub const XKB_KEY_braille_dots_2457: u32 = 16787546;
pub const XKB_KEY_braille_dots_12457: u32 = 16787547;
pub const XKB_KEY_braille_dots_3457: u32 = 16787548;
pub const XKB_KEY_braille_dots_13457: u32 = 16787549;
pub const XKB_KEY_braille_dots_23457: u32 = 16787550;
pub const XKB_KEY_braille_dots_123457: u32 = 16787551;
pub const XKB_KEY_braille_dots_67: u32 = 16787552;
pub const XKB_KEY_braille_dots_167: u32 = 16787553;
pub const XKB_KEY_braille_dots_267: u32 = 16787554;
pub const XKB_KEY_braille_dots_1267: u32 = 16787555;
pub const XKB_KEY_braille_dots_367: u32 = 16787556;
pub const XKB_KEY_braille_dots_1367: u32 = 16787557;
pub const XKB_KEY_braille_dots_2367: u32 = 16787558;
pub const XKB_KEY_braille_dots_12367: u32 = 16787559;
pub const XKB_KEY_braille_dots_467: u32 = 16787560;
pub const XKB_KEY_braille_dots_1467: u32 = 16787561;
pub const XKB_KEY_braille_dots_2467: u32 = 16787562;
pub const XKB_KEY_braille_dots_12467: u32 = 16787563;
pub const XKB_KEY_braille_dots_3467: u32 = 16787564;
pub const XKB_KEY_braille_dots_13467: u32 = 16787565;
pub const XKB_KEY_braille_dots_23467: u32 = 16787566;
pub const XKB_KEY_braille_dots_123467: u32 = 16787567;
pub const XKB_KEY_braille_dots_567: u32 = 16787568;
pub const XKB_KEY_braille_dots_1567: u32 = 16787569;
pub const XKB_KEY_braille_dots_2567: u32 = 16787570;
pub const XKB_KEY_braille_dots_12567: u32 = 16787571;
pub const XKB_KEY_braille_dots_3567: u32 = 16787572;
pub const XKB_KEY_braille_dots_13567: u32 = 16787573;
pub const XKB_KEY_braille_dots_23567: u32 = 16787574;
pub const XKB_KEY_braille_dots_123567: u32 = 16787575;
pub const XKB_KEY_braille_dots_4567: u32 = 16787576;
pub const XKB_KEY_braille_dots_14567: u32 = 16787577;
pub const XKB_KEY_braille_dots_24567: u32 = 16787578;
pub const XKB_KEY_braille_dots_124567: u32 = 16787579;
pub const XKB_KEY_braille_dots_34567: u32 = 16787580;
pub const XKB_KEY_braille_dots_134567: u32 = 16787581;
pub const XKB_KEY_braille_dots_234567: u32 = 16787582;
pub const XKB_KEY_braille_dots_1234567: u32 = 16787583;
pub const XKB_KEY_braille_dots_8: u32 = 16787584;
pub const XKB_KEY_braille_dots_18: u32 = 16787585;
pub const XKB_KEY_braille_dots_28: u32 = 16787586;
pub const XKB_KEY_braille_dots_128: u32 = 16787587;
pub const XKB_KEY_braille_dots_38: u32 = 16787588;
pub const XKB_KEY_braille_dots_138: u32 = 16787589;
pub const XKB_KEY_braille_dots_238: u32 = 16787590;
pub const XKB_KEY_braille_dots_1238: u32 = 16787591;
pub const XKB_KEY_braille_dots_48: u32 = 16787592;
pub const XKB_KEY_braille_dots_148: u32 = 16787593;
pub const XKB_KEY_braille_dots_248: u32 = 16787594;
pub const XKB_KEY_braille_dots_1248: u32 = 16787595;
pub const XKB_KEY_braille_dots_348: u32 = 16787596;
pub const XKB_KEY_braille_dots_1348: u32 = 16787597;
pub const XKB_KEY_braille_dots_2348: u32 = 16787598;
pub const XKB_KEY_braille_dots_12348: u32 = 16787599;
pub const XKB_KEY_braille_dots_58: u32 = 16787600;
pub const XKB_KEY_braille_dots_158: u32 = 16787601;
pub const XKB_KEY_braille_dots_258: u32 = 16787602;
pub const XKB_KEY_braille_dots_1258: u32 = 16787603;
pub const XKB_KEY_braille_dots_358: u32 = 16787604;
pub const XKB_KEY_braille_dots_1358: u32 = 16787605;
pub const XKB_KEY_braille_dots_2358: u32 = 16787606;
pub const XKB_KEY_braille_dots_12358: u32 = 16787607;
pub const XKB_KEY_braille_dots_458: u32 = 16787608;
pub const XKB_KEY_braille_dots_1458: u32 = 16787609;
pub const XKB_KEY_braille_dots_2458: u32 = 16787610;
pub const XKB_KEY_braille_dots_12458: u32 = 16787611;
pub const XKB_KEY_braille_dots_3458: u32 = 16787612;
pub const XKB_KEY_braille_dots_13458: u32 = 16787613;
pub const XKB_KEY_braille_dots_23458: u32 = 16787614;
pub const XKB_KEY_braille_dots_123458: u32 = 16787615;
pub const XKB_KEY_braille_dots_68: u32 = 16787616;
pub const XKB_KEY_braille_dots_168: u32 = 16787617;
pub const XKB_KEY_braille_dots_268: u32 = 16787618;
pub const XKB_KEY_braille_dots_1268: u32 = 16787619;
pub const XKB_KEY_braille_dots_368: u32 = 16787620;
pub const XKB_KEY_braille_dots_1368: u32 = 16787621;
pub const XKB_KEY_braille_dots_2368: u32 = 16787622;
pub const XKB_KEY_braille_dots_12368: u32 = 16787623;
pub const XKB_KEY_braille_dots_468: u32 = 16787624;
pub const XKB_KEY_braille_dots_1468: u32 = 16787625;
pub const XKB_KEY_braille_dots_2468: u32 = 16787626;
pub const XKB_KEY_braille_dots_12468: u32 = 16787627;
pub const XKB_KEY_braille_dots_3468: u32 = 16787628;
pub const XKB_KEY_braille_dots_13468: u32 = 16787629;
pub const XKB_KEY_braille_dots_23468: u32 = 16787630;
pub const XKB_KEY_braille_dots_123468: u32 = 16787631;
pub const XKB_KEY_braille_dots_568: u32 = 16787632;
pub const XKB_KEY_braille_dots_1568: u32 = 16787633;
pub const XKB_KEY_braille_dots_2568: u32 = 16787634;
pub const XKB_KEY_braille_dots_12568: u32 = 16787635;
pub const XKB_KEY_braille_dots_3568: u32 = 16787636;
pub const XKB_KEY_braille_dots_13568: u32 = 16787637;
pub const XKB_KEY_braille_dots_23568: u32 = 16787638;
pub const XKB_KEY_braille_dots_123568: u32 = 16787639;
pub const XKB_KEY_braille_dots_4568: u32 = 16787640;
pub const XKB_KEY_braille_dots_14568: u32 = 16787641;
pub const XKB_KEY_braille_dots_24568: u32 = 16787642;
pub const XKB_KEY_braille_dots_124568: u32 = 16787643;
pub const XKB_KEY_braille_dots_34568: u32 = 16787644;
pub const XKB_KEY_braille_dots_134568: u32 = 16787645;
pub const XKB_KEY_braille_dots_234568: u32 = 16787646;
pub const XKB_KEY_braille_dots_1234568: u32 = 16787647;
pub const XKB_KEY_braille_dots_78: u32 = 16787648;
pub const XKB_KEY_braille_dots_178: u32 = 16787649;
pub const XKB_KEY_braille_dots_278: u32 = 16787650;
pub const XKB_KEY_braille_dots_1278: u32 = 16787651;
pub const XKB_KEY_braille_dots_378: u32 = 16787652;
pub const XKB_KEY_braille_dots_1378: u32 = 16787653;
pub const XKB_KEY_braille_dots_2378: u32 = 16787654;
pub const XKB_KEY_braille_dots_12378: u32 = 16787655;
pub const XKB_KEY_braille_dots_478: u32 = 16787656;
pub const XKB_KEY_braille_dots_1478: u32 = 16787657;
pub const XKB_KEY_braille_dots_2478: u32 = 16787658;
pub const XKB_KEY_braille_dots_12478: u32 = 16787659;
pub const XKB_KEY_braille_dots_3478: u32 = 16787660;
pub const XKB_KEY_braille_dots_13478: u32 = 16787661;
pub const XKB_KEY_braille_dots_23478: u32 = 16787662;
pub const XKB_KEY_braille_dots_123478: u32 = 16787663;
pub const XKB_KEY_braille_dots_578: u32 = 16787664;
pub const XKB_KEY_braille_dots_1578: u32 = 16787665;
pub const XKB_KEY_braille_dots_2578: u32 = 16787666;
pub const XKB_KEY_braille_dots_12578: u32 = 16787667;
pub const XKB_KEY_braille_dots_3578: u32 = 16787668;
pub const XKB_KEY_braille_dots_13578: u32 = 16787669;
pub const XKB_KEY_braille_dots_23578: u32 = 16787670;
pub const XKB_KEY_braille_dots_123578: u32 = 16787671;
pub const XKB_KEY_braille_dots_4578: u32 = 16787672;
pub const XKB_KEY_braille_dots_14578: u32 = 16787673;
pub const XKB_KEY_braille_dots_24578: u32 = 16787674;
pub const XKB_KEY_braille_dots_124578: u32 = 16787675;
pub const XKB_KEY_braille_dots_34578: u32 = 16787676;
pub const XKB_KEY_braille_dots_134578: u32 = 16787677;
pub const XKB_KEY_braille_dots_234578: u32 = 16787678;
pub const XKB_KEY_braille_dots_1234578: u32 = 16787679;
pub const XKB_KEY_braille_dots_678: u32 = 16787680;
pub const XKB_KEY_braille_dots_1678: u32 = 16787681;
pub const XKB_KEY_braille_dots_2678: u32 = 16787682;
pub const XKB_KEY_braille_dots_12678: u32 = 16787683;
pub const XKB_KEY_braille_dots_3678: u32 = 16787684;
pub const XKB_KEY_braille_dots_13678: u32 = 16787685;
pub const XKB_KEY_braille_dots_23678: u32 = 16787686;
pub const XKB_KEY_braille_dots_123678: u32 = 16787687;
pub const XKB_KEY_braille_dots_4678: u32 = 16787688;
pub const XKB_KEY_braille_dots_14678: u32 = 16787689;
pub const XKB_KEY_braille_dots_24678: u32 = 16787690;
pub const XKB_KEY_braille_dots_124678: u32 = 16787691;
pub const XKB_KEY_braille_dots_34678: u32 = 16787692;
pub const XKB_KEY_braille_dots_134678: u32 = 16787693;
pub const XKB_KEY_braille_dots_234678: u32 = 16787694;
pub const XKB_KEY_braille_dots_1234678: u32 = 16787695;
pub const XKB_KEY_braille_dots_5678: u32 = 16787696;
pub const XKB_KEY_braille_dots_15678: u32 = 16787697;
pub const XKB_KEY_braille_dots_25678: u32 = 16787698;
pub const XKB_KEY_braille_dots_125678: u32 = 16787699;
pub const XKB_KEY_braille_dots_35678: u32 = 16787700;
pub const XKB_KEY_braille_dots_135678: u32 = 16787701;
pub const XKB_KEY_braille_dots_235678: u32 = 16787702;
pub const XKB_KEY_braille_dots_1235678: u32 = 16787703;
pub const XKB_KEY_braille_dots_45678: u32 = 16787704;
pub const XKB_KEY_braille_dots_145678: u32 = 16787705;
pub const XKB_KEY_braille_dots_245678: u32 = 16787706;
pub const XKB_KEY_braille_dots_1245678: u32 = 16787707;
pub const XKB_KEY_braille_dots_345678: u32 = 16787708;
pub const XKB_KEY_braille_dots_1345678: u32 = 16787709;
pub const XKB_KEY_braille_dots_2345678: u32 = 16787710;
pub const XKB_KEY_braille_dots_12345678: u32 = 16787711;
pub const XKB_KEY_Sinh_ng: u32 = 16780674;
pub const XKB_KEY_Sinh_h2: u32 = 16780675;
pub const XKB_KEY_Sinh_a: u32 = 16780677;
pub const XKB_KEY_Sinh_aa: u32 = 16780678;
pub const XKB_KEY_Sinh_ae: u32 = 16780679;
pub const XKB_KEY_Sinh_aee: u32 = 16780680;
pub const XKB_KEY_Sinh_i: u32 = 16780681;
pub const XKB_KEY_Sinh_ii: u32 = 16780682;
pub const XKB_KEY_Sinh_u: u32 = 16780683;
pub const XKB_KEY_Sinh_uu: u32 = 16780684;
pub const XKB_KEY_Sinh_ri: u32 = 16780685;
pub const XKB_KEY_Sinh_rii: u32 = 16780686;
pub const XKB_KEY_Sinh_lu: u32 = 16780687;
pub const XKB_KEY_Sinh_luu: u32 = 16780688;
pub const XKB_KEY_Sinh_e: u32 = 16780689;
pub const XKB_KEY_Sinh_ee: u32 = 16780690;
pub const XKB_KEY_Sinh_ai: u32 = 16780691;
pub const XKB_KEY_Sinh_o: u32 = 16780692;
pub const XKB_KEY_Sinh_oo: u32 = 16780693;
pub const XKB_KEY_Sinh_au: u32 = 16780694;
pub const XKB_KEY_Sinh_ka: u32 = 16780698;
pub const XKB_KEY_Sinh_kha: u32 = 16780699;
pub const XKB_KEY_Sinh_ga: u32 = 16780700;
pub const XKB_KEY_Sinh_gha: u32 = 16780701;
pub const XKB_KEY_Sinh_ng2: u32 = 16780702;
pub const XKB_KEY_Sinh_nga: u32 = 16780703;
pub const XKB_KEY_Sinh_ca: u32 = 16780704;
pub const XKB_KEY_Sinh_cha: u32 = 16780705;
pub const XKB_KEY_Sinh_ja: u32 = 16780706;
pub const XKB_KEY_Sinh_jha: u32 = 16780707;
pub const XKB_KEY_Sinh_nya: u32 = 16780708;
pub const XKB_KEY_Sinh_jnya: u32 = 16780709;
pub const XKB_KEY_Sinh_nja: u32 = 16780710;
pub const XKB_KEY_Sinh_tta: u32 = 16780711;
pub const XKB_KEY_Sinh_ttha: u32 = 16780712;
pub const XKB_KEY_Sinh_dda: u32 = 16780713;
pub const XKB_KEY_Sinh_ddha: u32 = 16780714;
pub const XKB_KEY_Sinh_nna: u32 = 16780715;
pub const XKB_KEY_Sinh_ndda: u32 = 16780716;
pub const XKB_KEY_Sinh_tha: u32 = 16780717;
pub const XKB_KEY_Sinh_thha: u32 = 16780718;
pub const XKB_KEY_Sinh_dha: u32 = 16780719;
pub const XKB_KEY_Sinh_dhha: u32 = 16780720;
pub const XKB_KEY_Sinh_na: u32 = 16780721;
pub const XKB_KEY_Sinh_ndha: u32 = 16780723;
pub const XKB_KEY_Sinh_pa: u32 = 16780724;
pub const XKB_KEY_Sinh_pha: u32 = 16780725;
pub const XKB_KEY_Sinh_ba: u32 = 16780726;
pub const XKB_KEY_Sinh_bha: u32 = 16780727;
pub const XKB_KEY_Sinh_ma: u32 = 16780728;
pub const XKB_KEY_Sinh_mba: u32 = 16780729;
pub const XKB_KEY_Sinh_ya: u32 = 16780730;
pub const XKB_KEY_Sinh_ra: u32 = 16780731;
pub const XKB_KEY_Sinh_la: u32 = 16780733;
pub const XKB_KEY_Sinh_va: u32 = 16780736;
pub const XKB_KEY_Sinh_sha: u32 = 16780737;
pub const XKB_KEY_Sinh_ssha: u32 = 16780738;
pub const XKB_KEY_Sinh_sa: u32 = 16780739;
pub const XKB_KEY_Sinh_ha: u32 = 16780740;
pub const XKB_KEY_Sinh_lla: u32 = 16780741;
pub const XKB_KEY_Sinh_fa: u32 = 16780742;
pub const XKB_KEY_Sinh_al: u32 = 16780746;
pub const XKB_KEY_Sinh_aa2: u32 = 16780751;
pub const XKB_KEY_Sinh_ae2: u32 = 16780752;
pub const XKB_KEY_Sinh_aee2: u32 = 16780753;
pub const XKB_KEY_Sinh_i2: u32 = 16780754;
pub const XKB_KEY_Sinh_ii2: u32 = 16780755;
pub const XKB_KEY_Sinh_u2: u32 = 16780756;
pub const XKB_KEY_Sinh_uu2: u32 = 16780758;
pub const XKB_KEY_Sinh_ru2: u32 = 16780760;
pub const XKB_KEY_Sinh_e2: u32 = 16780761;
pub const XKB_KEY_Sinh_ee2: u32 = 16780762;
pub const XKB_KEY_Sinh_ai2: u32 = 16780763;
pub const XKB_KEY_Sinh_o2: u32 = 16780764;
pub const XKB_KEY_Sinh_oo2: u32 = 16780765;
pub const XKB_KEY_Sinh_au2: u32 = 16780766;
pub const XKB_KEY_Sinh_lu2: u32 = 16780767;
pub const XKB_KEY_Sinh_ruu2: u32 = 16780786;
pub const XKB_KEY_Sinh_luu2: u32 = 16780787;
pub const XKB_KEY_Sinh_kunddaliya: u32 = 16780788;
pub const XKB_KEY_XF86ModeLock: u32 = 269025025;
pub const XKB_KEY_XF86MonBrightnessUp: u32 = 269025026;
pub const XKB_KEY_XF86MonBrightnessDown: u32 = 269025027;
pub const XKB_KEY_XF86KbdLightOnOff: u32 = 269025028;
pub const XKB_KEY_XF86KbdBrightnessUp: u32 = 269025029;
pub const XKB_KEY_XF86KbdBrightnessDown: u32 = 269025030;
pub const XKB_KEY_XF86Standby: u32 = 269025040;
pub const XKB_KEY_XF86AudioLowerVolume: u32 = 269025041;
pub const XKB_KEY_XF86AudioMute: u32 = 269025042;
pub const XKB_KEY_XF86AudioRaiseVolume: u32 = 269025043;
pub const XKB_KEY_XF86AudioPlay: u32 = 269025044;
pub const XKB_KEY_XF86AudioStop: u32 = 269025045;
pub const XKB_KEY_XF86AudioPrev: u32 = 269025046;
pub const XKB_KEY_XF86AudioNext: u32 = 269025047;
pub const XKB_KEY_XF86HomePage: u32 = 269025048;
pub const XKB_KEY_XF86Mail: u32 = 269025049;
pub const XKB_KEY_XF86Start: u32 = 269025050;
pub const XKB_KEY_XF86Search: u32 = 269025051;
pub const XKB_KEY_XF86AudioRecord: u32 = 269025052;
pub const XKB_KEY_XF86Calculator: u32 = 269025053;
pub const XKB_KEY_XF86Memo: u32 = 269025054;
pub const XKB_KEY_XF86ToDoList: u32 = 269025055;
pub const XKB_KEY_XF86Calendar: u32 = 269025056;
pub const XKB_KEY_XF86PowerDown: u32 = 269025057;
pub const XKB_KEY_XF86ContrastAdjust: u32 = 269025058;
pub const XKB_KEY_XF86RockerUp: u32 = 269025059;
pub const XKB_KEY_XF86RockerDown: u32 = 269025060;
pub const XKB_KEY_XF86RockerEnter: u32 = 269025061;
pub const XKB_KEY_XF86Back: u32 = 269025062;
pub const XKB_KEY_XF86Forward: u32 = 269025063;
pub const XKB_KEY_XF86Stop: u32 = 269025064;
pub const XKB_KEY_XF86Refresh: u32 = 269025065;
pub const XKB_KEY_XF86PowerOff: u32 = 269025066;
pub const XKB_KEY_XF86WakeUp: u32 = 269025067;
pub const XKB_KEY_XF86Eject: u32 = 269025068;
pub const XKB_KEY_XF86ScreenSaver: u32 = 269025069;
pub const XKB_KEY_XF86WWW: u32 = 269025070;
pub const XKB_KEY_XF86Sleep: u32 = 269025071;
pub const XKB_KEY_XF86Favorites: u32 = 269025072;
pub const XKB_KEY_XF86AudioPause: u32 = 269025073;
pub const XKB_KEY_XF86AudioMedia: u32 = 269025074;
pub const XKB_KEY_XF86MyComputer: u32 = 269025075;
pub const XKB_KEY_XF86VendorHome: u32 = 269025076;
pub const XKB_KEY_XF86LightBulb: u32 = 269025077;
pub const XKB_KEY_XF86Shop: u32 = 269025078;
pub const XKB_KEY_XF86History: u32 = 269025079;
pub const XKB_KEY_XF86OpenURL: u32 = 269025080;
pub const XKB_KEY_XF86AddFavorite: u32 = 269025081;
pub const XKB_KEY_XF86HotLinks: u32 = 269025082;
pub const XKB_KEY_XF86BrightnessAdjust: u32 = 269025083;
pub const XKB_KEY_XF86Finance: u32 = 269025084;
pub const XKB_KEY_XF86Community: u32 = 269025085;
pub const XKB_KEY_XF86AudioRewind: u32 = 269025086;
pub const XKB_KEY_XF86BackForward: u32 = 269025087;
pub const XKB_KEY_XF86Launch0: u32 = 269025088;
pub const XKB_KEY_XF86Launch1: u32 = 269025089;
pub const XKB_KEY_XF86Launch2: u32 = 269025090;
pub const XKB_KEY_XF86Launch3: u32 = 269025091;
pub const XKB_KEY_XF86Launch4: u32 = 269025092;
pub const XKB_KEY_XF86Launch5: u32 = 269025093;
pub const XKB_KEY_XF86Launch6: u32 = 269025094;
pub const XKB_KEY_XF86Launch7: u32 = 269025095;
pub const XKB_KEY_XF86Launch8: u32 = 269025096;
pub const XKB_KEY_XF86Launch9: u32 = 269025097;
pub const XKB_KEY_XF86LaunchA: u32 = 269025098;
pub const XKB_KEY_XF86LaunchB: u32 = 269025099;
pub const XKB_KEY_XF86LaunchC: u32 = 269025100;
pub const XKB_KEY_XF86LaunchD: u32 = 269025101;
pub const XKB_KEY_XF86LaunchE: u32 = 269025102;
pub const XKB_KEY_XF86LaunchF: u32 = 269025103;
pub const XKB_KEY_XF86ApplicationLeft: u32 = 269025104;
pub const XKB_KEY_XF86ApplicationRight: u32 = 269025105;
pub const XKB_KEY_XF86Book: u32 = 269025106;
pub const XKB_KEY_XF86CD: u32 = 269025107;
pub const XKB_KEY_XF86Calculater: u32 = 269025108;
pub const XKB_KEY_XF86Clear: u32 = 269025109;
pub const XKB_KEY_XF86Close: u32 = 269025110;
pub const XKB_KEY_XF86Copy: u32 = 269025111;
pub const XKB_KEY_XF86Cut: u32 = 269025112;
pub const XKB_KEY_XF86Display: u32 = 269025113;
pub const XKB_KEY_XF86DOS: u32 = 269025114;
pub const XKB_KEY_XF86Documents: u32 = 269025115;
pub const XKB_KEY_XF86Excel: u32 = 269025116;
pub const XKB_KEY_XF86Explorer: u32 = 269025117;
pub const XKB_KEY_XF86Game: u32 = 269025118;
pub const XKB_KEY_XF86Go: u32 = 269025119;
pub const XKB_KEY_XF86iTouch: u32 = 269025120;
pub const XKB_KEY_XF86LogOff: u32 = 269025121;
pub const XKB_KEY_XF86Market: u32 = 269025122;
pub const XKB_KEY_XF86Meeting: u32 = 269025123;
pub const XKB_KEY_XF86MenuKB: u32 = 269025125;
pub const XKB_KEY_XF86MenuPB: u32 = 269025126;
pub const XKB_KEY_XF86MySites: u32 = 269025127;
pub const XKB_KEY_XF86New: u32 = 269025128;
pub const XKB_KEY_XF86News: u32 = 269025129;
pub const XKB_KEY_XF86OfficeHome: u32 = 269025130;
pub const XKB_KEY_XF86Open: u32 = 269025131;
pub const XKB_KEY_XF86Option: u32 = 269025132;
pub const XKB_KEY_XF86Paste: u32 = 269025133;
pub const XKB_KEY_XF86Phone: u32 = 269025134;
pub const XKB_KEY_XF86Q: u32 = 269025136;
pub const XKB_KEY_XF86Reply: u32 = 269025138;
pub const XKB_KEY_XF86Reload: u32 = 269025139;
pub const XKB_KEY_XF86RotateWindows: u32 = 269025140;
pub const XKB_KEY_XF86RotationPB: u32 = 269025141;
pub const XKB_KEY_XF86RotationKB: u32 = 269025142;
pub const XKB_KEY_XF86Save: u32 = 269025143;
pub const XKB_KEY_XF86ScrollUp: u32 = 269025144;
pub const XKB_KEY_XF86ScrollDown: u32 = 269025145;
pub const XKB_KEY_XF86ScrollClick: u32 = 269025146;
pub const XKB_KEY_XF86Send: u32 = 269025147;
pub const XKB_KEY_XF86Spell: u32 = 269025148;
pub const XKB_KEY_XF86SplitScreen: u32 = 269025149;
pub const XKB_KEY_XF86Support: u32 = 269025150;
pub const XKB_KEY_XF86TaskPane: u32 = 269025151;
pub const XKB_KEY_XF86Terminal: u32 = 269025152;
pub const XKB_KEY_XF86Tools: u32 = 269025153;
pub const XKB_KEY_XF86Travel: u32 = 269025154;
pub const XKB_KEY_XF86UserPB: u32 = 269025156;
pub const XKB_KEY_XF86User1KB: u32 = 269025157;
pub const XKB_KEY_XF86User2KB: u32 = 269025158;
pub const XKB_KEY_XF86Video: u32 = 269025159;
pub const XKB_KEY_XF86WheelButton: u32 = 269025160;
pub const XKB_KEY_XF86Word: u32 = 269025161;
pub const XKB_KEY_XF86Xfer: u32 = 269025162;
pub const XKB_KEY_XF86ZoomIn: u32 = 269025163;
pub const XKB_KEY_XF86ZoomOut: u32 = 269025164;
pub const XKB_KEY_XF86Away: u32 = 269025165;
pub const XKB_KEY_XF86Messenger: u32 = 269025166;
pub const XKB_KEY_XF86WebCam: u32 = 269025167;
pub const XKB_KEY_XF86MailForward: u32 = 269025168;
pub const XKB_KEY_XF86Pictures: u32 = 269025169;
pub const XKB_KEY_XF86Music: u32 = 269025170;
pub const XKB_KEY_XF86Battery: u32 = 269025171;
pub const XKB_KEY_XF86Bluetooth: u32 = 269025172;
pub const XKB_KEY_XF86WLAN: u32 = 269025173;
pub const XKB_KEY_XF86UWB: u32 = 269025174;
pub const XKB_KEY_XF86AudioForward: u32 = 269025175;
pub const XKB_KEY_XF86AudioRepeat: u32 = 269025176;
pub const XKB_KEY_XF86AudioRandomPlay: u32 = 269025177;
pub const XKB_KEY_XF86Subtitle: u32 = 269025178;
pub const XKB_KEY_XF86AudioCycleTrack: u32 = 269025179;
pub const XKB_KEY_XF86CycleAngle: u32 = 269025180;
pub const XKB_KEY_XF86FrameBack: u32 = 269025181;
pub const XKB_KEY_XF86FrameForward: u32 = 269025182;
pub const XKB_KEY_XF86Time: u32 = 269025183;
pub const XKB_KEY_XF86Select: u32 = 269025184;
pub const XKB_KEY_XF86View: u32 = 269025185;
pub const XKB_KEY_XF86TopMenu: u32 = 269025186;
pub const XKB_KEY_XF86Red: u32 = 269025187;
pub const XKB_KEY_XF86Green: u32 = 269025188;
pub const XKB_KEY_XF86Yellow: u32 = 269025189;
pub const XKB_KEY_XF86Blue: u32 = 269025190;
pub const XKB_KEY_XF86Suspend: u32 = 269025191;
pub const XKB_KEY_XF86Hibernate: u32 = 269025192;
pub const XKB_KEY_XF86TouchpadToggle: u32 = 269025193;
pub const XKB_KEY_XF86TouchpadOn: u32 = 269025200;
pub const XKB_KEY_XF86TouchpadOff: u32 = 269025201;
pub const XKB_KEY_XF86AudioMicMute: u32 = 269025202;
pub const XKB_KEY_XF86Keyboard: u32 = 269025203;
pub const XKB_KEY_XF86WWAN: u32 = 269025204;
pub const XKB_KEY_XF86RFKill: u32 = 269025205;
pub const XKB_KEY_XF86AudioPreset: u32 = 269025206;
pub const XKB_KEY_XF86Switch_VT_1: u32 = 269024769;
pub const XKB_KEY_XF86Switch_VT_2: u32 = 269024770;
pub const XKB_KEY_XF86Switch_VT_3: u32 = 269024771;
pub const XKB_KEY_XF86Switch_VT_4: u32 = 269024772;
pub const XKB_KEY_XF86Switch_VT_5: u32 = 269024773;
pub const XKB_KEY_XF86Switch_VT_6: u32 = 269024774;
pub const XKB_KEY_XF86Switch_VT_7: u32 = 269024775;
pub const XKB_KEY_XF86Switch_VT_8: u32 = 269024776;
pub const XKB_KEY_XF86Switch_VT_9: u32 = 269024777;
pub const XKB_KEY_XF86Switch_VT_10: u32 = 269024778;
pub const XKB_KEY_XF86Switch_VT_11: u32 = 269024779;
pub const XKB_KEY_XF86Switch_VT_12: u32 = 269024780;
pub const XKB_KEY_XF86Ungrab: u32 = 269024800;
pub const XKB_KEY_XF86ClearGrab: u32 = 269024801;
pub const XKB_KEY_XF86Next_VMode: u32 = 269024802;
pub const XKB_KEY_XF86Prev_VMode: u32 = 269024803;
pub const XKB_KEY_XF86LogWindowTree: u32 = 269024804;
pub const XKB_KEY_XF86LogGrabInfo: u32 = 269024805;
pub const XKB_KEY_SunFA_Grave: u32 = 268828416;
pub const XKB_KEY_SunFA_Circum: u32 = 268828417;
pub const XKB_KEY_SunFA_Tilde: u32 = 268828418;
pub const XKB_KEY_SunFA_Acute: u32 = 268828419;
pub const XKB_KEY_SunFA_Diaeresis: u32 = 268828420;
pub const XKB_KEY_SunFA_Cedilla: u32 = 268828421;
pub const XKB_KEY_SunF36: u32 = 268828432;
pub const XKB_KEY_SunF37: u32 = 268828433;
pub const XKB_KEY_SunSys_Req: u32 = 268828512;
pub const XKB_KEY_SunPrint_Screen: u32 = 65377;
pub const XKB_KEY_SunCompose: u32 = 65312;
pub const XKB_KEY_SunAltGraph: u32 = 65406;
pub const XKB_KEY_SunPageUp: u32 = 65365;
pub const XKB_KEY_SunPageDown: u32 = 65366;
pub const XKB_KEY_SunUndo: u32 = 65381;
pub const XKB_KEY_SunAgain: u32 = 65382;
pub const XKB_KEY_SunFind: u32 = 65384;
pub const XKB_KEY_SunStop: u32 = 65385;
pub const XKB_KEY_SunProps: u32 = 268828528;
pub const XKB_KEY_SunFront: u32 = 268828529;
pub const XKB_KEY_SunCopy: u32 = 268828530;
pub const XKB_KEY_SunOpen: u32 = 268828531;
pub const XKB_KEY_SunPaste: u32 = 268828532;
pub const XKB_KEY_SunCut: u32 = 268828533;
pub const XKB_KEY_SunPowerSwitch: u32 = 268828534;
pub const XKB_KEY_SunAudioLowerVolume: u32 = 268828535;
pub const XKB_KEY_SunAudioMute: u32 = 268828536;
pub const XKB_KEY_SunAudioRaiseVolume: u32 = 268828537;
pub const XKB_KEY_SunVideoDegauss: u32 = 268828538;
pub const XKB_KEY_SunVideoLowerBrightness: u32 = 268828539;
pub const XKB_KEY_SunVideoRaiseBrightness: u32 = 268828540;
pub const XKB_KEY_SunPowerSwitchShift: u32 = 268828541;
pub const XKB_KEY_Dring_accent: u32 = 268500656;
pub const XKB_KEY_Dcircumflex_accent: u32 = 268500574;
pub const XKB_KEY_Dcedilla_accent: u32 = 268500524;
pub const XKB_KEY_Dacute_accent: u32 = 268500519;
pub const XKB_KEY_Dgrave_accent: u32 = 268500576;
pub const XKB_KEY_Dtilde: u32 = 268500606;
pub const XKB_KEY_Ddiaeresis: u32 = 268500514;
pub const XKB_KEY_DRemove: u32 = 268500736;
pub const XKB_KEY_hpClearLine: u32 = 268500847;
pub const XKB_KEY_hpInsertLine: u32 = 268500848;
pub const XKB_KEY_hpDeleteLine: u32 = 268500849;
pub const XKB_KEY_hpInsertChar: u32 = 268500850;
pub const XKB_KEY_hpDeleteChar: u32 = 268500851;
pub const XKB_KEY_hpBackTab: u32 = 268500852;
pub const XKB_KEY_hpKP_BackTab: u32 = 268500853;
pub const XKB_KEY_hpModelock1: u32 = 268500808;
pub const XKB_KEY_hpModelock2: u32 = 268500809;
pub const XKB_KEY_hpReset: u32 = 268500844;
pub const XKB_KEY_hpSystem: u32 = 268500845;
pub const XKB_KEY_hpUser: u32 = 268500846;
pub const XKB_KEY_hpmute_acute: u32 = 268435624;
pub const XKB_KEY_hpmute_grave: u32 = 268435625;
pub const XKB_KEY_hpmute_asciicircum: u32 = 268435626;
pub const XKB_KEY_hpmute_diaeresis: u32 = 268435627;
pub const XKB_KEY_hpmute_asciitilde: u32 = 268435628;
pub const XKB_KEY_hplira: u32 = 268435631;
pub const XKB_KEY_hpguilder: u32 = 268435646;
pub const XKB_KEY_hpYdiaeresis: u32 = 268435694;
pub const XKB_KEY_hpIO: u32 = 268435694;
pub const XKB_KEY_hplongminus: u32 = 268435702;
pub const XKB_KEY_hpblock: u32 = 268435708;
pub const XKB_KEY_osfCopy: u32 = 268762882;
pub const XKB_KEY_osfCut: u32 = 268762883;
pub const XKB_KEY_osfPaste: u32 = 268762884;
pub const XKB_KEY_osfBackTab: u32 = 268762887;
pub const XKB_KEY_osfBackSpace: u32 = 268762888;
pub const XKB_KEY_osfClear: u32 = 268762891;
pub const XKB_KEY_osfEscape: u32 = 268762907;
pub const XKB_KEY_osfAddMode: u32 = 268762929;
pub const XKB_KEY_osfPrimaryPaste: u32 = 268762930;
pub const XKB_KEY_osfQuickPaste: u32 = 268762931;
pub const XKB_KEY_osfPageLeft: u32 = 268762944;
pub const XKB_KEY_osfPageUp: u32 = 268762945;
pub const XKB_KEY_osfPageDown: u32 = 268762946;
pub const XKB_KEY_osfPageRight: u32 = 268762947;
pub const XKB_KEY_osfActivate: u32 = 268762948;
pub const XKB_KEY_osfMenuBar: u32 = 268762949;
pub const XKB_KEY_osfLeft: u32 = 268762961;
pub const XKB_KEY_osfUp: u32 = 268762962;
pub const XKB_KEY_osfRight: u32 = 268762963;
pub const XKB_KEY_osfDown: u32 = 268762964;
pub const XKB_KEY_osfEndLine: u32 = 268762967;
pub const XKB_KEY_osfBeginLine: u32 = 268762968;
pub const XKB_KEY_osfEndData: u32 = 268762969;
pub const XKB_KEY_osfBeginData: u32 = 268762970;
pub const XKB_KEY_osfPrevMenu: u32 = 268762971;
pub const XKB_KEY_osfNextMenu: u32 = 268762972;
pub const XKB_KEY_osfPrevField: u32 = 268762973;
pub const XKB_KEY_osfNextField: u32 = 268762974;
pub const XKB_KEY_osfSelect: u32 = 268762976;
pub const XKB_KEY_osfInsert: u32 = 268762979;
pub const XKB_KEY_osfUndo: u32 = 268762981;
pub const XKB_KEY_osfMenu: u32 = 268762983;
pub const XKB_KEY_osfCancel: u32 = 268762985;
pub const XKB_KEY_osfHelp: u32 = 268762986;
pub const XKB_KEY_osfSelectAll: u32 = 268762993;
pub const XKB_KEY_osfDeselectAll: u32 = 268762994;
pub const XKB_KEY_osfReselect: u32 = 268762995;
pub const XKB_KEY_osfExtend: u32 = 268762996;
pub const XKB_KEY_osfRestore: u32 = 268763000;
pub const XKB_KEY_osfDelete: u32 = 268763135;
pub const XKB_KEY_Reset: u32 = 268500844;
pub const XKB_KEY_System: u32 = 268500845;
pub const XKB_KEY_User: u32 = 268500846;
pub const XKB_KEY_ClearLine: u32 = 268500847;
pub const XKB_KEY_InsertLine: u32 = 268500848;
pub const XKB_KEY_DeleteLine: u32 = 268500849;
pub const XKB_KEY_InsertChar: u32 = 268500850;
pub const XKB_KEY_DeleteChar: u32 = 268500851;
pub const XKB_KEY_BackTab: u32 = 268500852;
pub const XKB_KEY_KP_BackTab: u32 = 268500853;
pub const XKB_KEY_Ext16bit_L: u32 = 268500854;
pub const XKB_KEY_Ext16bit_R: u32 = 268500855;
pub const XKB_KEY_mute_acute: u32 = 268435624;
pub const XKB_KEY_mute_grave: u32 = 268435625;
pub const XKB_KEY_mute_asciicircum: u32 = 268435626;
pub const XKB_KEY_mute_diaeresis: u32 = 268435627;
pub const XKB_KEY_mute_asciitilde: u32 = 268435628;
pub const XKB_KEY_lira: u32 = 268435631;
pub const XKB_KEY_guilder: u32 = 268435646;
pub const XKB_KEY_IO: u32 = 268435694;
pub const XKB_KEY_longminus: u32 = 268435702;
pub const XKB_KEY_block: u32 = 268435708;
pub const XKB_KEYCODE_INVALID: u32 = 4294967295;
pub const XKB_LAYOUT_INVALID: u32 = 4294967295;
pub const XKB_LEVEL_INVALID: u32 = 4294967295;
pub const XKB_MOD_INVALID: u32 = 4294967295;
pub const XKB_LED_INVALID: u32 = 4294967295;
pub const XKB_KEYCODE_MAX: u32 = 4294967294;
pub const XKB_GROUP_INVALID: u32 = 4294967295;
pub const WLR_LED_COUNT: u32 = 3;
pub const WLR_MODIFIER_COUNT: u32 = 8;
pub const WLR_KEYBOARD_KEYS_CAP: u32 = 32;
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const WLR_SERIAL_RINGSET_SIZE: u32 = 128;
pub const WLR_POINTER_BUTTONS_CAP: u32 = 16;
pub const ZWLR_LAYER_SHELL_V1_GET_LAYER_SURFACE_SINCE_VERSION: u32 = 1;
pub const ZWLR_LAYER_SURFACE_V1_CONFIGURE: u32 = 0;
pub const ZWLR_LAYER_SURFACE_V1_CLOSED: u32 = 1;
pub const ZWLR_LAYER_SURFACE_V1_CONFIGURE_SINCE_VERSION: u32 = 1;
pub const ZWLR_LAYER_SURFACE_V1_CLOSED_SINCE_VERSION: u32 = 1;
pub const ZWLR_LAYER_SURFACE_V1_SET_SIZE_SINCE_VERSION: u32 = 1;
pub const ZWLR_LAYER_SURFACE_V1_SET_ANCHOR_SINCE_VERSION: u32 = 1;
pub const ZWLR_LAYER_SURFACE_V1_SET_EXCLUSIVE_ZONE_SINCE_VERSION: u32 = 1;
pub const ZWLR_LAYER_SURFACE_V1_SET_MARGIN_SINCE_VERSION: u32 = 1;
pub const ZWLR_LAYER_SURFACE_V1_SET_KEYBOARD_INTERACTIVITY_SINCE_VERSION: u32 = 1;
pub const ZWLR_LAYER_SURFACE_V1_GET_POPUP_SINCE_VERSION: u32 = 1;
pub const ZWLR_LAYER_SURFACE_V1_ACK_CONFIGURE_SINCE_VERSION: u32 = 1;
pub const ZWLR_LAYER_SURFACE_V1_DESTROY_SINCE_VERSION: u32 = 1;
pub const WLR_OUTPUT_DAMAGE_PREVIOUS_LEN: u32 = 2;
pub const XDG_WM_BASE_PING: u32 = 0;
pub const XDG_WM_BASE_PING_SINCE_VERSION: u32 = 1;
pub const XDG_WM_BASE_DESTROY_SINCE_VERSION: u32 = 1;
pub const XDG_WM_BASE_CREATE_POSITIONER_SINCE_VERSION: u32 = 1;
pub const XDG_WM_BASE_GET_XDG_SURFACE_SINCE_VERSION: u32 = 1;
pub const XDG_WM_BASE_PONG_SINCE_VERSION: u32 = 1;
pub const XDG_POSITIONER_DESTROY_SINCE_VERSION: u32 = 1;
pub const XDG_POSITIONER_SET_SIZE_SINCE_VERSION: u32 = 1;
pub const XDG_POSITIONER_SET_ANCHOR_RECT_SINCE_VERSION: u32 = 1;
pub const XDG_POSITIONER_SET_ANCHOR_SINCE_VERSION: u32 = 1;
pub const XDG_POSITIONER_SET_GRAVITY_SINCE_VERSION: u32 = 1;
pub const XDG_POSITIONER_SET_CONSTRAINT_ADJUSTMENT_SINCE_VERSION: u32 = 1;
pub const XDG_POSITIONER_SET_OFFSET_SINCE_VERSION: u32 = 1;
pub const XDG_SURFACE_CONFIGURE: u32 = 0;
pub const XDG_SURFACE_CONFIGURE_SINCE_VERSION: u32 = 1;
pub const XDG_SURFACE_DESTROY_SINCE_VERSION: u32 = 1;
pub const XDG_SURFACE_GET_TOPLEVEL_SINCE_VERSION: u32 = 1;
pub const XDG_SURFACE_GET_POPUP_SINCE_VERSION: u32 = 1;
pub const XDG_SURFACE_SET_WINDOW_GEOMETRY_SINCE_VERSION: u32 = 1;
pub const XDG_SURFACE_ACK_CONFIGURE_SINCE_VERSION: u32 = 1;
pub const XDG_TOPLEVEL_STATE_TILED_LEFT_SINCE_VERSION: u32 = 2;
pub const XDG_TOPLEVEL_STATE_TILED_RIGHT_SINCE_VERSION: u32 = 2;
pub const XDG_TOPLEVEL_STATE_TILED_TOP_SINCE_VERSION: u32 = 2;
pub const XDG_TOPLEVEL_STATE_TILED_BOTTOM_SINCE_VERSION: u32 = 2;
pub const XDG_TOPLEVEL_CONFIGURE: u32 = 0;
pub const XDG_TOPLEVEL_CLOSE: u32 = 1;
pub const XDG_TOPLEVEL_CONFIGURE_SINCE_VERSION: u32 = 1;
pub const XDG_TOPLEVEL_CLOSE_SINCE_VERSION: u32 = 1;
pub const XDG_TOPLEVEL_DESTROY_SINCE_VERSION: u32 = 1;
pub const XDG_TOPLEVEL_SET_PARENT_SINCE_VERSION: u32 = 1;
pub const XDG_TOPLEVEL_SET_TITLE_SINCE_VERSION: u32 = 1;
pub const XDG_TOPLEVEL_SET_APP_ID_SINCE_VERSION: u32 = 1;
pub const XDG_TOPLEVEL_SHOW_WINDOW_MENU_SINCE_VERSION: u32 = 1;
pub const XDG_TOPLEVEL_MOVE_SINCE_VERSION: u32 = 1;
pub const XDG_TOPLEVEL_RESIZE_SINCE_VERSION: u32 = 1;
pub const XDG_TOPLEVEL_SET_MAX_SIZE_SINCE_VERSION: u32 = 1;
pub const XDG_TOPLEVEL_SET_MIN_SIZE_SINCE_VERSION: u32 = 1;
pub const XDG_TOPLEVEL_SET_MAXIMIZED_SINCE_VERSION: u32 = 1;
pub const XDG_TOPLEVEL_UNSET_MAXIMIZED_SINCE_VERSION: u32 = 1;
pub const XDG_TOPLEVEL_SET_FULLSCREEN_SINCE_VERSION: u32 = 1;
pub const XDG_TOPLEVEL_UNSET_FULLSCREEN_SINCE_VERSION: u32 = 1;
pub const XDG_TOPLEVEL_SET_MINIMIZED_SINCE_VERSION: u32 = 1;
pub const XDG_POPUP_CONFIGURE: u32 = 0;
pub const XDG_POPUP_POPUP_DONE: u32 = 1;
pub const XDG_POPUP_CONFIGURE_SINCE_VERSION: u32 = 1;
pub const XDG_POPUP_POPUP_DONE_SINCE_VERSION: u32 = 1;
pub const XDG_POPUP_DESTROY_SINCE_VERSION: u32 = 1;
pub const XDG_POPUP_GRAB_SINCE_VERSION: u32 = 1;
pub const _STRING_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const _ERRNO_H: u32 = 1;
pub const _BITS_ERRNO_H: u32 = 1;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EDEADLK: u32 = 35;
pub const ENAMETOOLONG: u32 = 36;
pub const ENOLCK: u32 = 37;
pub const ENOSYS: u32 = 38;
pub const ENOTEMPTY: u32 = 39;
pub const ELOOP: u32 = 40;
pub const EWOULDBLOCK: u32 = 11;
pub const ENOMSG: u32 = 42;
pub const EIDRM: u32 = 43;
pub const ECHRNG: u32 = 44;
pub const EL2NSYNC: u32 = 45;
pub const EL3HLT: u32 = 46;
pub const EL3RST: u32 = 47;
pub const ELNRNG: u32 = 48;
pub const EUNATCH: u32 = 49;
pub const ENOCSI: u32 = 50;
pub const EL2HLT: u32 = 51;
pub const EBADE: u32 = 52;
pub const EBADR: u32 = 53;
pub const EXFULL: u32 = 54;
pub const ENOANO: u32 = 55;
pub const EBADRQC: u32 = 56;
pub const EBADSLT: u32 = 57;
pub const EDEADLOCK: u32 = 35;
pub const EBFONT: u32 = 59;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENONET: u32 = 64;
pub const ENOPKG: u32 = 65;
pub const EREMOTE: u32 = 66;
pub const ENOLINK: u32 = 67;
pub const EADV: u32 = 68;
pub const ESRMNT: u32 = 69;
pub const ECOMM: u32 = 70;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 72;
pub const EDOTDOT: u32 = 73;
pub const EBADMSG: u32 = 74;
pub const EOVERFLOW: u32 = 75;
pub const ENOTUNIQ: u32 = 76;
pub const EBADFD: u32 = 77;
pub const EREMCHG: u32 = 78;
pub const ELIBACC: u32 = 79;
pub const ELIBBAD: u32 = 80;
pub const ELIBSCN: u32 = 81;
pub const ELIBMAX: u32 = 82;
pub const ELIBEXEC: u32 = 83;
pub const EILSEQ: u32 = 84;
pub const ERESTART: u32 = 85;
pub const ESTRPIPE: u32 = 86;
pub const EUSERS: u32 = 87;
pub const ENOTSOCK: u32 = 88;
pub const EDESTADDRREQ: u32 = 89;
pub const EMSGSIZE: u32 = 90;
pub const EPROTOTYPE: u32 = 91;
pub const ENOPROTOOPT: u32 = 92;
pub const EPROTONOSUPPORT: u32 = 93;
pub const ESOCKTNOSUPPORT: u32 = 94;
pub const EOPNOTSUPP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const EAFNOSUPPORT: u32 = 97;
pub const EADDRINUSE: u32 = 98;
pub const EADDRNOTAVAIL: u32 = 99;
pub const ENETDOWN: u32 = 100;
pub const ENETUNREACH: u32 = 101;
pub const ENETRESET: u32 = 102;
pub const ECONNABORTED: u32 = 103;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EISCONN: u32 = 106;
pub const ENOTCONN: u32 = 107;
pub const ESHUTDOWN: u32 = 108;
pub const ETOOMANYREFS: u32 = 109;
pub const ETIMEDOUT: u32 = 110;
pub const ECONNREFUSED: u32 = 111;
pub const EHOSTDOWN: u32 = 112;
pub const EHOSTUNREACH: u32 = 113;
pub const EALREADY: u32 = 114;
pub const EINPROGRESS: u32 = 115;
pub const ESTALE: u32 = 116;
pub const EUCLEAN: u32 = 117;
pub const ENOTNAM: u32 = 118;
pub const ENAVAIL: u32 = 119;
pub const EISNAM: u32 = 120;
pub const EREMOTEIO: u32 = 121;
pub const EDQUOT: u32 = 122;
pub const ENOMEDIUM: u32 = 123;
pub const EMEDIUMTYPE: u32 = 124;
pub const ECANCELED: u32 = 125;
pub const ENOKEY: u32 = 126;
pub const EKEYEXPIRED: u32 = 127;
pub const EKEYREVOKED: u32 = 128;
pub const EKEYREJECTED: u32 = 129;
pub const EOWNERDEAD: u32 = 130;
pub const ENOTRECOVERABLE: u32 = 131;
pub const ERFKILL: u32 = 132;
pub const EHWPOISON: u32 = 133;
pub const ENOTSUP: u32 = 95;
pub const _SYS_UIO_H: u32 = 1;
pub const __iovec_defined: u32 = 1;
pub const _BITS_UIO_LIM_H: u32 = 1;
pub const __IOV_MAX: u32 = 1024;
pub const UIO_MAXIOV: u32 = 1024;
pub const _PTHREAD_H: u32 = 1;
pub const _SCHED_H: u32 = 1;
pub const _BITS_SCHED_H: u32 = 1;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const _BITS_TYPES_STRUCT_SCHED_PARAM: u32 = 1;
pub const _BITS_CPU_SET_H: u32 = 1;
pub const __CPU_SETSIZE: u32 = 1024;
pub const _BITS_SETJMP_H: u32 = 1;
pub const PTHREAD_ONCE_INIT: u32 = 0;
pub const PTHREAD_BARRIER_SERIAL_THREAD: i32 = -1;
pub const X_PROTOCOL: u32 = 11;
pub const X_PROTOCOL_REVISION: u32 = 0;
pub const X_TCP_PORT: u32 = 6000;
pub const XCB_CONN_ERROR: u32 = 1;
pub const XCB_CONN_CLOSED_EXT_NOTSUPPORTED: u32 = 2;
pub const XCB_CONN_CLOSED_MEM_INSUFFICIENT: u32 = 3;
pub const XCB_CONN_CLOSED_REQ_LEN_EXCEED: u32 = 4;
pub const XCB_CONN_CLOSED_PARSE_ERR: u32 = 5;
pub const XCB_CONN_CLOSED_INVALID_SCREEN: u32 = 6;
pub const XCB_CONN_CLOSED_FDPASSING_FAILED: u32 = 7;
pub const XCB_KEY_PRESS: u32 = 2;
pub const XCB_KEY_RELEASE: u32 = 3;
pub const XCB_BUTTON_PRESS: u32 = 4;
pub const XCB_BUTTON_RELEASE: u32 = 5;
pub const XCB_MOTION_NOTIFY: u32 = 6;
pub const XCB_ENTER_NOTIFY: u32 = 7;
pub const XCB_LEAVE_NOTIFY: u32 = 8;
pub const XCB_FOCUS_IN: u32 = 9;
pub const XCB_FOCUS_OUT: u32 = 10;
pub const XCB_KEYMAP_NOTIFY: u32 = 11;
pub const XCB_EXPOSE: u32 = 12;
pub const XCB_GRAPHICS_EXPOSURE: u32 = 13;
pub const XCB_NO_EXPOSURE: u32 = 14;
pub const XCB_VISIBILITY_NOTIFY: u32 = 15;
pub const XCB_CREATE_NOTIFY: u32 = 16;
pub const XCB_DESTROY_NOTIFY: u32 = 17;
pub const XCB_UNMAP_NOTIFY: u32 = 18;
pub const XCB_MAP_NOTIFY: u32 = 19;
pub const XCB_MAP_REQUEST: u32 = 20;
pub const XCB_REPARENT_NOTIFY: u32 = 21;
pub const XCB_CONFIGURE_NOTIFY: u32 = 22;
pub const XCB_CONFIGURE_REQUEST: u32 = 23;
pub const XCB_GRAVITY_NOTIFY: u32 = 24;
pub const XCB_RESIZE_REQUEST: u32 = 25;
pub const XCB_CIRCULATE_NOTIFY: u32 = 26;
pub const XCB_CIRCULATE_REQUEST: u32 = 27;
pub const XCB_PROPERTY_NOTIFY: u32 = 28;
pub const XCB_SELECTION_CLEAR: u32 = 29;
pub const XCB_SELECTION_REQUEST: u32 = 30;
pub const XCB_SELECTION_NOTIFY: u32 = 31;
pub const XCB_COLORMAP_NOTIFY: u32 = 32;
pub const XCB_CLIENT_MESSAGE: u32 = 33;
pub const XCB_MAPPING_NOTIFY: u32 = 34;
pub const XCB_GE_GENERIC: u32 = 35;
pub const XCB_REQUEST: u32 = 1;
pub const XCB_VALUE: u32 = 2;
pub const XCB_WINDOW: u32 = 3;
pub const XCB_PIXMAP: u32 = 4;
pub const XCB_ATOM: u32 = 5;
pub const XCB_CURSOR: u32 = 6;
pub const XCB_FONT: u32 = 7;
pub const XCB_MATCH: u32 = 8;
pub const XCB_DRAWABLE: u32 = 9;
pub const XCB_ACCESS: u32 = 10;
pub const XCB_ALLOC: u32 = 11;
pub const XCB_COLORMAP: u32 = 12;
pub const XCB_G_CONTEXT: u32 = 13;
pub const XCB_ID_CHOICE: u32 = 14;
pub const XCB_NAME: u32 = 15;
pub const XCB_LENGTH: u32 = 16;
pub const XCB_IMPLEMENTATION: u32 = 17;
pub const XCB_CREATE_WINDOW: u32 = 1;
pub const XCB_CHANGE_WINDOW_ATTRIBUTES: u32 = 2;
pub const XCB_GET_WINDOW_ATTRIBUTES: u32 = 3;
pub const XCB_DESTROY_WINDOW: u32 = 4;
pub const XCB_DESTROY_SUBWINDOWS: u32 = 5;
pub const XCB_CHANGE_SAVE_SET: u32 = 6;
pub const XCB_REPARENT_WINDOW: u32 = 7;
pub const XCB_MAP_WINDOW: u32 = 8;
pub const XCB_MAP_SUBWINDOWS: u32 = 9;
pub const XCB_UNMAP_WINDOW: u32 = 10;
pub const XCB_UNMAP_SUBWINDOWS: u32 = 11;
pub const XCB_CONFIGURE_WINDOW: u32 = 12;
pub const XCB_CIRCULATE_WINDOW: u32 = 13;
pub const XCB_GET_GEOMETRY: u32 = 14;
pub const XCB_QUERY_TREE: u32 = 15;
pub const XCB_INTERN_ATOM: u32 = 16;
pub const XCB_GET_ATOM_NAME: u32 = 17;
pub const XCB_CHANGE_PROPERTY: u32 = 18;
pub const XCB_DELETE_PROPERTY: u32 = 19;
pub const XCB_GET_PROPERTY: u32 = 20;
pub const XCB_LIST_PROPERTIES: u32 = 21;
pub const XCB_SET_SELECTION_OWNER: u32 = 22;
pub const XCB_GET_SELECTION_OWNER: u32 = 23;
pub const XCB_CONVERT_SELECTION: u32 = 24;
pub const XCB_SEND_EVENT: u32 = 25;
pub const XCB_GRAB_POINTER: u32 = 26;
pub const XCB_UNGRAB_POINTER: u32 = 27;
pub const XCB_GRAB_BUTTON: u32 = 28;
pub const XCB_UNGRAB_BUTTON: u32 = 29;
pub const XCB_CHANGE_ACTIVE_POINTER_GRAB: u32 = 30;
pub const XCB_GRAB_KEYBOARD: u32 = 31;
pub const XCB_UNGRAB_KEYBOARD: u32 = 32;
pub const XCB_GRAB_KEY: u32 = 33;
pub const XCB_UNGRAB_KEY: u32 = 34;
pub const XCB_ALLOW_EVENTS: u32 = 35;
pub const XCB_GRAB_SERVER: u32 = 36;
pub const XCB_UNGRAB_SERVER: u32 = 37;
pub const XCB_QUERY_POINTER: u32 = 38;
pub const XCB_GET_MOTION_EVENTS: u32 = 39;
pub const XCB_TRANSLATE_COORDINATES: u32 = 40;
pub const XCB_WARP_POINTER: u32 = 41;
pub const XCB_SET_INPUT_FOCUS: u32 = 42;
pub const XCB_GET_INPUT_FOCUS: u32 = 43;
pub const XCB_QUERY_KEYMAP: u32 = 44;
pub const XCB_OPEN_FONT: u32 = 45;
pub const XCB_CLOSE_FONT: u32 = 46;
pub const XCB_QUERY_FONT: u32 = 47;
pub const XCB_QUERY_TEXT_EXTENTS: u32 = 48;
pub const XCB_LIST_FONTS: u32 = 49;
pub const XCB_LIST_FONTS_WITH_INFO: u32 = 50;
pub const XCB_SET_FONT_PATH: u32 = 51;
pub const XCB_GET_FONT_PATH: u32 = 52;
pub const XCB_CREATE_PIXMAP: u32 = 53;
pub const XCB_FREE_PIXMAP: u32 = 54;
pub const XCB_CREATE_GC: u32 = 55;
pub const XCB_CHANGE_GC: u32 = 56;
pub const XCB_COPY_GC: u32 = 57;
pub const XCB_SET_DASHES: u32 = 58;
pub const XCB_SET_CLIP_RECTANGLES: u32 = 59;
pub const XCB_FREE_GC: u32 = 60;
pub const XCB_CLEAR_AREA: u32 = 61;
pub const XCB_COPY_AREA: u32 = 62;
pub const XCB_COPY_PLANE: u32 = 63;
pub const XCB_POLY_POINT: u32 = 64;
pub const XCB_POLY_LINE: u32 = 65;
pub const XCB_POLY_SEGMENT: u32 = 66;
pub const XCB_POLY_RECTANGLE: u32 = 67;
pub const XCB_POLY_ARC: u32 = 68;
pub const XCB_FILL_POLY: u32 = 69;
pub const XCB_POLY_FILL_RECTANGLE: u32 = 70;
pub const XCB_POLY_FILL_ARC: u32 = 71;
pub const XCB_PUT_IMAGE: u32 = 72;
pub const XCB_GET_IMAGE: u32 = 73;
pub const XCB_POLY_TEXT_8: u32 = 74;
pub const XCB_POLY_TEXT_16: u32 = 75;
pub const XCB_IMAGE_TEXT_8: u32 = 76;
pub const XCB_IMAGE_TEXT_16: u32 = 77;
pub const XCB_CREATE_COLORMAP: u32 = 78;
pub const XCB_FREE_COLORMAP: u32 = 79;
pub const XCB_COPY_COLORMAP_AND_FREE: u32 = 80;
pub const XCB_INSTALL_COLORMAP: u32 = 81;
pub const XCB_UNINSTALL_COLORMAP: u32 = 82;
pub const XCB_LIST_INSTALLED_COLORMAPS: u32 = 83;
pub const XCB_ALLOC_COLOR: u32 = 84;
pub const XCB_ALLOC_NAMED_COLOR: u32 = 85;
pub const XCB_ALLOC_COLOR_CELLS: u32 = 86;
pub const XCB_ALLOC_COLOR_PLANES: u32 = 87;
pub const XCB_FREE_COLORS: u32 = 88;
pub const XCB_STORE_COLORS: u32 = 89;
pub const XCB_STORE_NAMED_COLOR: u32 = 90;
pub const XCB_QUERY_COLORS: u32 = 91;
pub const XCB_LOOKUP_COLOR: u32 = 92;
pub const XCB_CREATE_CURSOR: u32 = 93;
pub const XCB_CREATE_GLYPH_CURSOR: u32 = 94;
pub const XCB_FREE_CURSOR: u32 = 95;
pub const XCB_RECOLOR_CURSOR: u32 = 96;
pub const XCB_QUERY_BEST_SIZE: u32 = 97;
pub const XCB_QUERY_EXTENSION: u32 = 98;
pub const XCB_LIST_EXTENSIONS: u32 = 99;
pub const XCB_CHANGE_KEYBOARD_MAPPING: u32 = 100;
pub const XCB_GET_KEYBOARD_MAPPING: u32 = 101;
pub const XCB_CHANGE_KEYBOARD_CONTROL: u32 = 102;
pub const XCB_GET_KEYBOARD_CONTROL: u32 = 103;
pub const XCB_BELL: u32 = 104;
pub const XCB_CHANGE_POINTER_CONTROL: u32 = 105;
pub const XCB_GET_POINTER_CONTROL: u32 = 106;
pub const XCB_SET_SCREEN_SAVER: u32 = 107;
pub const XCB_GET_SCREEN_SAVER: u32 = 108;
pub const XCB_CHANGE_HOSTS: u32 = 109;
pub const XCB_LIST_HOSTS: u32 = 110;
pub const XCB_SET_ACCESS_CONTROL: u32 = 111;
pub const XCB_SET_CLOSE_DOWN_MODE: u32 = 112;
pub const XCB_KILL_CLIENT: u32 = 113;
pub const XCB_ROTATE_PROPERTIES: u32 = 114;
pub const XCB_FORCE_SCREEN_SAVER: u32 = 115;
pub const XCB_SET_POINTER_MAPPING: u32 = 116;
pub const XCB_GET_POINTER_MAPPING: u32 = 117;
pub const XCB_SET_MODIFIER_MAPPING: u32 = 118;
pub const XCB_GET_MODIFIER_MAPPING: u32 = 119;
pub const XCB_NO_OPERATION: u32 = 127;
pub const XCB_NONE: u32 = 0;
pub const XCB_COPY_FROM_PARENT: u32 = 0;
pub const XCB_CURRENT_TIME: u32 = 0;
pub const XCB_NO_SYMBOL: u32 = 0;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulong;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigset_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fd_set>())).__fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__readers as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__wrphase_futex as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers_futex as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad3 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad4 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__cur_writer as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__shared as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__rwelision as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad1 as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad2 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__nusers as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__kind as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__spins as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__elision as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
    pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: ::std::os::raw::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq32)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: ::std::os::raw::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start32 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start32)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_refs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g1_orig_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__wrefs as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_signals as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 6usize],
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    pub fn __fpclassify(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbit(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isinf(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finite(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnan(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iseqsig(__x: f64, __y: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignaling(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acos(__x: f64) -> f64;
}
extern "C" {
    pub fn __acos(__x: f64) -> f64;
}
extern "C" {
    pub fn asin(__x: f64) -> f64;
}
extern "C" {
    pub fn __asin(__x: f64) -> f64;
}
extern "C" {
    pub fn atan(__x: f64) -> f64;
}
extern "C" {
    pub fn __atan(__x: f64) -> f64;
}
extern "C" {
    pub fn atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn __atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn cos(__x: f64) -> f64;
}
extern "C" {
    pub fn __cos(__x: f64) -> f64;
}
extern "C" {
    pub fn sin(__x: f64) -> f64;
}
extern "C" {
    pub fn __sin(__x: f64) -> f64;
}
extern "C" {
    pub fn tan(__x: f64) -> f64;
}
extern "C" {
    pub fn __tan(__x: f64) -> f64;
}
extern "C" {
    pub fn cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn exp(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp(__x: f64) -> f64;
}
extern "C" {
    pub fn frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn log(__x: f64) -> f64;
}
extern "C" {
    pub fn __log(__x: f64) -> f64;
}
extern "C" {
    pub fn log10(__x: f64) -> f64;
}
extern "C" {
    pub fn __log10(__x: f64) -> f64;
}
extern "C" {
    pub fn modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn __modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn __expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn __log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn logb(__x: f64) -> f64;
}
extern "C" {
    pub fn __logb(__x: f64) -> f64;
}
extern "C" {
    pub fn exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn log2(__x: f64) -> f64;
}
extern "C" {
    pub fn __log2(__x: f64) -> f64;
}
extern "C" {
    pub fn pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn __ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn __fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn floor(__x: f64) -> f64;
}
extern "C" {
    pub fn __floor(__x: f64) -> f64;
}
extern "C" {
    pub fn fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn isinf(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finite(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn significand(__x: f64) -> f64;
}
extern "C" {
    pub fn __significand(__x: f64) -> f64;
}
extern "C" {
    pub fn copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn __nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn isnan(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn rint(__x: f64) -> f64;
}
extern "C" {
    pub fn __rint(__x: f64) -> f64;
}
extern "C" {
    pub fn nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nexttoward(__x: f64, __y: u128) -> f64;
}
extern "C" {
    pub fn __nexttoward(__x: f64, __y: u128) -> f64;
}
extern "C" {
    pub fn remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ilogb(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogb(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn __scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn __nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn round(__x: f64) -> f64;
}
extern "C" {
    pub fn __round(__x: f64) -> f64;
}
extern "C" {
    pub fn trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn __trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn lrint(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrint(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lround(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lround(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llround(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llround(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn __fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __fpclassifyf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbitf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isinff(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finitef(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnanf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iseqsigf(__x: f32, __y: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignalingf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn __atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn expf(__x: f32) -> f32;
}
extern "C" {
    pub fn __expf(__x: f32) -> f32;
}
extern "C" {
    pub fn frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn logf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logf(__x: f32) -> f32;
}
extern "C" {
    pub fn log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn __modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn __expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn __log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn __ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn __fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn __floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn isinff(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finitef(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn __significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn __nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn isnanf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nexttowardf(__x: f32, __y: u128) -> f32;
}
extern "C" {
    pub fn __nexttowardf(__x: f32, __y: u128) -> f32;
}
extern "C" {
    pub fn remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn __scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn __roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn __truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn lrintf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrintf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lroundf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lroundf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn __fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn __scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn __fpclassifyl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbitl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isinfl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finitel(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnanl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iseqsigl(__x: u128, __y: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignalingl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acosl(__x: u128) -> u128;
}
extern "C" {
    pub fn __acosl(__x: u128) -> u128;
}
extern "C" {
    pub fn asinl(__x: u128) -> u128;
}
extern "C" {
    pub fn __asinl(__x: u128) -> u128;
}
extern "C" {
    pub fn atanl(__x: u128) -> u128;
}
extern "C" {
    pub fn __atanl(__x: u128) -> u128;
}
extern "C" {
    pub fn atan2l(__y: u128, __x: u128) -> u128;
}
extern "C" {
    pub fn __atan2l(__y: u128, __x: u128) -> u128;
}
extern "C" {
    pub fn cosl(__x: u128) -> u128;
}
extern "C" {
    pub fn __cosl(__x: u128) -> u128;
}
extern "C" {
    pub fn sinl(__x: u128) -> u128;
}
extern "C" {
    pub fn __sinl(__x: u128) -> u128;
}
extern "C" {
    pub fn tanl(__x: u128) -> u128;
}
extern "C" {
    pub fn __tanl(__x: u128) -> u128;
}
extern "C" {
    pub fn coshl(__x: u128) -> u128;
}
extern "C" {
    pub fn __coshl(__x: u128) -> u128;
}
extern "C" {
    pub fn sinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __sinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn tanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __tanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn acoshl(__x: u128) -> u128;
}
extern "C" {
    pub fn __acoshl(__x: u128) -> u128;
}
extern "C" {
    pub fn asinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __asinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn atanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __atanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn expl(__x: u128) -> u128;
}
extern "C" {
    pub fn __expl(__x: u128) -> u128;
}
extern "C" {
    pub fn frexpl(__x: u128, __exponent: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __frexpl(__x: u128, __exponent: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn ldexpl(__x: u128, __exponent: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __ldexpl(__x: u128, __exponent: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn logl(__x: u128) -> u128;
}
extern "C" {
    pub fn __logl(__x: u128) -> u128;
}
extern "C" {
    pub fn log10l(__x: u128) -> u128;
}
extern "C" {
    pub fn __log10l(__x: u128) -> u128;
}
extern "C" {
    pub fn modfl(__x: u128, __iptr: *mut u128) -> u128;
}
extern "C" {
    pub fn __modfl(__x: u128, __iptr: *mut u128) -> u128;
}
extern "C" {
    pub fn expm1l(__x: u128) -> u128;
}
extern "C" {
    pub fn __expm1l(__x: u128) -> u128;
}
extern "C" {
    pub fn log1pl(__x: u128) -> u128;
}
extern "C" {
    pub fn __log1pl(__x: u128) -> u128;
}
extern "C" {
    pub fn logbl(__x: u128) -> u128;
}
extern "C" {
    pub fn __logbl(__x: u128) -> u128;
}
extern "C" {
    pub fn exp2l(__x: u128) -> u128;
}
extern "C" {
    pub fn __exp2l(__x: u128) -> u128;
}
extern "C" {
    pub fn log2l(__x: u128) -> u128;
}
extern "C" {
    pub fn __log2l(__x: u128) -> u128;
}
extern "C" {
    pub fn powl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __powl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn sqrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn __sqrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn hypotl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __hypotl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn cbrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn __cbrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn ceill(__x: u128) -> u128;
}
extern "C" {
    pub fn __ceill(__x: u128) -> u128;
}
extern "C" {
    pub fn fabsl(__x: u128) -> u128;
}
extern "C" {
    pub fn __fabsl(__x: u128) -> u128;
}
extern "C" {
    pub fn floorl(__x: u128) -> u128;
}
extern "C" {
    pub fn __floorl(__x: u128) -> u128;
}
extern "C" {
    pub fn fmodl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fmodl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn isinfl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finitel(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dreml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __dreml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn significandl(__x: u128) -> u128;
}
extern "C" {
    pub fn __significandl(__x: u128) -> u128;
}
extern "C" {
    pub fn copysignl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __copysignl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn nanl(__tagb: *const ::std::os::raw::c_char) -> u128;
}
extern "C" {
    pub fn __nanl(__tagb: *const ::std::os::raw::c_char) -> u128;
}
extern "C" {
    pub fn isnanl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __j0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn j1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __j1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn jnl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn __jnl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn y0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __y0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn y1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __y1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn ynl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn __ynl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn erfl(arg1: u128) -> u128;
}
extern "C" {
    pub fn __erfl(arg1: u128) -> u128;
}
extern "C" {
    pub fn erfcl(arg1: u128) -> u128;
}
extern "C" {
    pub fn __erfcl(arg1: u128) -> u128;
}
extern "C" {
    pub fn lgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn __lgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn tgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn __tgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn gammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn __gammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn lgammal_r(arg1: u128, __signgamp: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __lgammal_r(arg1: u128, __signgamp: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn rintl(__x: u128) -> u128;
}
extern "C" {
    pub fn __rintl(__x: u128) -> u128;
}
extern "C" {
    pub fn nextafterl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __nextafterl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn nexttowardl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __nexttowardl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn remainderl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __remainderl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn scalbnl(__x: u128, __n: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __scalbnl(__x: u128, __n: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn ilogbl(__x: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogbl(__x: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalblnl(__x: u128, __n: ::std::os::raw::c_long) -> u128;
}
extern "C" {
    pub fn __scalblnl(__x: u128, __n: ::std::os::raw::c_long) -> u128;
}
extern "C" {
    pub fn nearbyintl(__x: u128) -> u128;
}
extern "C" {
    pub fn __nearbyintl(__x: u128) -> u128;
}
extern "C" {
    pub fn roundl(__x: u128) -> u128;
}
extern "C" {
    pub fn __roundl(__x: u128) -> u128;
}
extern "C" {
    pub fn truncl(__x: u128) -> u128;
}
extern "C" {
    pub fn __truncl(__x: u128) -> u128;
}
extern "C" {
    pub fn remquol(__x: u128, __y: u128, __quo: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __remquol(__x: u128, __y: u128, __quo: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn lrintl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrintl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrintl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lroundl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lroundl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llroundl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llroundl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdiml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fdiml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn fmaxl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fmaxl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn fminl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fminl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn fmal(__x: u128, __y: u128, __z: u128) -> u128;
}
extern "C" {
    pub fn __fmal(__x: u128, __y: u128, __z: u128) -> u128;
}
extern "C" {
    pub fn scalbl(__x: u128, __n: u128) -> u128;
}
extern "C" {
    pub fn __scalbl(__x: u128, __n: u128) -> u128;
}
extern "C" {
    pub static mut signgam: ::std::os::raw::c_int;
}
pub mod _bindgen_ty_1 {
    pub type Type = u32;
    pub const FP_NAN: Type = 0;
    pub const FP_INFINITE: Type = 1;
    pub const FP_ZERO: Type = 2;
    pub const FP_SUBNORMAL: Type = 3;
    pub const FP_NORMAL: Type = 4;
}
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type __gwchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    assert_eq!(
        ::std::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imaxdiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imaxdiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_message {
    pub name: *const ::std::os::raw::c_char,
    pub signature: *const ::std::os::raw::c_char,
    pub types: *mut *const wl_interface,
}
#[test]
fn bindgen_test_layout_wl_message() {
    assert_eq!(
        ::std::mem::size_of::<wl_message>(),
        24usize,
        concat!("Size of: ", stringify!(wl_message))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_message>(),
        8usize,
        concat!("Alignment of ", stringify!(wl_message))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_message>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_message),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_message>())).signature as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_message),
            "::",
            stringify!(signature)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_message>())).types as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_message),
            "::",
            stringify!(types)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_interface {
    pub name: *const ::std::os::raw::c_char,
    pub version: ::std::os::raw::c_int,
    pub method_count: ::std::os::raw::c_int,
    pub methods: *const wl_message,
    pub event_count: ::std::os::raw::c_int,
    pub events: *const wl_message,
}
#[test]
fn bindgen_test_layout_wl_interface() {
    assert_eq!(
        ::std::mem::size_of::<wl_interface>(),
        40usize,
        concat!("Size of: ", stringify!(wl_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(wl_interface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_interface>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_interface),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_interface>())).version as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_interface),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_interface>())).method_count as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_interface),
            "::",
            stringify!(method_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_interface>())).methods as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_interface),
            "::",
            stringify!(methods)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_interface>())).event_count as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_interface),
            "::",
            stringify!(event_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_interface>())).events as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_interface),
            "::",
            stringify!(events)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_list {
    pub prev: *mut wl_list,
    pub next: *mut wl_list,
}
#[test]
fn bindgen_test_layout_wl_list() {
    assert_eq!(
        ::std::mem::size_of::<wl_list>(),
        16usize,
        concat!("Size of: ", stringify!(wl_list))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_list>(),
        8usize,
        concat!("Alignment of ", stringify!(wl_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_list>())).prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_list),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_list>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_list),
            "::",
            stringify!(next)
        )
    );
}
extern "C" {
    pub fn wl_list_init(list: *mut wl_list);
}
extern "C" {
    pub fn wl_list_insert(list: *mut wl_list, elm: *mut wl_list);
}
extern "C" {
    pub fn wl_list_remove(elm: *mut wl_list);
}
extern "C" {
    pub fn wl_list_length(list: *const wl_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wl_list_empty(list: *const wl_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wl_list_insert_list(list: *mut wl_list, other: *mut wl_list);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_array {
    pub size: usize,
    pub alloc: usize,
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_wl_array() {
    assert_eq!(
        ::std::mem::size_of::<wl_array>(),
        24usize,
        concat!("Size of: ", stringify!(wl_array))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_array>(),
        8usize,
        concat!("Alignment of ", stringify!(wl_array))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_array>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_array),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_array>())).alloc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_array),
            "::",
            stringify!(alloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_array>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_array),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    pub fn wl_array_init(array: *mut wl_array);
}
extern "C" {
    pub fn wl_array_release(array: *mut wl_array);
}
extern "C" {
    pub fn wl_array_add(array: *mut wl_array, size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn wl_array_copy(array: *mut wl_array, source: *mut wl_array) -> ::std::os::raw::c_int;
}
pub type wl_fixed_t = i32;
#[repr(C)]
#[derive(Copy, Clone)]
pub union wl_argument {
    pub i: i32,
    pub u: u32,
    pub f: wl_fixed_t,
    pub s: *const ::std::os::raw::c_char,
    pub o: *mut wl_object,
    pub n: u32,
    pub a: *mut wl_array,
    pub h: i32,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_wl_argument() {
    assert_eq!(
        ::std::mem::size_of::<wl_argument>(),
        8usize,
        concat!("Size of: ", stringify!(wl_argument))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_argument>(),
        8usize,
        concat!("Alignment of ", stringify!(wl_argument))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_argument>())).i as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_argument),
            "::",
            stringify!(i)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_argument>())).u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_argument),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_argument>())).f as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_argument),
            "::",
            stringify!(f)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_argument>())).s as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_argument),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_argument>())).o as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_argument),
            "::",
            stringify!(o)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_argument>())).n as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_argument),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_argument>())).a as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_argument),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_argument>())).h as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_argument),
            "::",
            stringify!(h)
        )
    );
}
pub type wl_dispatcher_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: u32,
        arg4: *const wl_message,
        arg5: *mut wl_argument,
    ) -> ::std::os::raw::c_int,
>;
pub type wl_log_func_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char, arg2: *mut __va_list_tag),
>;
pub mod wl_iterator_result {
    pub type Type = u32;
    pub const WL_ITERATOR_STOP: Type = 0;
    pub const WL_ITERATOR_CONTINUE: Type = 1;
}
pub mod _bindgen_ty_2 {
    pub type Type = u32;
    pub const WL_EVENT_READABLE: Type = 1;
    pub const WL_EVENT_WRITABLE: Type = 2;
    pub const WL_EVENT_HANGUP: Type = 4;
    pub const WL_EVENT_ERROR: Type = 8;
}
pub type wl_event_loop_fd_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        fd: ::std::os::raw::c_int,
        mask: u32,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type wl_event_loop_timer_func_t = ::std::option::Option<
    unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
pub type wl_event_loop_signal_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        signal_number: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type wl_event_loop_idle_func_t =
    ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_event_loop {
    _unused: [u8; 0],
}
extern "C" {
    pub fn wl_event_loop_create() -> *mut wl_event_loop;
}
extern "C" {
    pub fn wl_event_loop_destroy(loop_: *mut wl_event_loop);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_event_source {
    _unused: [u8; 0],
}
extern "C" {
    pub fn wl_event_loop_add_fd(
        loop_: *mut wl_event_loop,
        fd: ::std::os::raw::c_int,
        mask: u32,
        func: wl_event_loop_fd_func_t,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut wl_event_source;
}
extern "C" {
    pub fn wl_event_source_fd_update(
        source: *mut wl_event_source,
        mask: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wl_event_loop_add_timer(
        loop_: *mut wl_event_loop,
        func: wl_event_loop_timer_func_t,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut wl_event_source;
}
extern "C" {
    pub fn wl_event_loop_add_signal(
        loop_: *mut wl_event_loop,
        signal_number: ::std::os::raw::c_int,
        func: wl_event_loop_signal_func_t,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut wl_event_source;
}
extern "C" {
    pub fn wl_event_source_timer_update(
        source: *mut wl_event_source,
        ms_delay: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wl_event_source_remove(source: *mut wl_event_source) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wl_event_source_check(source: *mut wl_event_source);
}
extern "C" {
    pub fn wl_event_loop_dispatch(
        loop_: *mut wl_event_loop,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wl_event_loop_dispatch_idle(loop_: *mut wl_event_loop);
}
extern "C" {
    pub fn wl_event_loop_add_idle(
        loop_: *mut wl_event_loop,
        func: wl_event_loop_idle_func_t,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut wl_event_source;
}
extern "C" {
    pub fn wl_event_loop_get_fd(loop_: *mut wl_event_loop) -> ::std::os::raw::c_int;
}
pub type wl_notify_func_t = ::std::option::Option<
    unsafe extern "C" fn(listener: *mut wl_listener, data: *mut ::std::os::raw::c_void),
>;
extern "C" {
    pub fn wl_event_loop_add_destroy_listener(
        loop_: *mut wl_event_loop,
        listener: *mut wl_listener,
    );
}
extern "C" {
    pub fn wl_event_loop_get_destroy_listener(
        loop_: *mut wl_event_loop,
        notify: wl_notify_func_t,
    ) -> *mut wl_listener;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_display {
    _unused: [u8; 0],
}
extern "C" {
    pub fn wl_display_create() -> *mut wl_display;
}
extern "C" {
    pub fn wl_display_destroy(display: *mut wl_display);
}
extern "C" {
    pub fn wl_display_get_event_loop(display: *mut wl_display) -> *mut wl_event_loop;
}
extern "C" {
    pub fn wl_display_add_socket(
        display: *mut wl_display,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wl_display_add_socket_auto(display: *mut wl_display) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn wl_display_add_socket_fd(
        display: *mut wl_display,
        sock_fd: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wl_display_terminate(display: *mut wl_display);
}
extern "C" {
    pub fn wl_display_run(display: *mut wl_display);
}
extern "C" {
    pub fn wl_display_flush_clients(display: *mut wl_display);
}
extern "C" {
    pub fn wl_display_destroy_clients(display: *mut wl_display);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_client {
    _unused: [u8; 0],
}
pub type wl_global_bind_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        client: *mut wl_client,
        data: *mut ::std::os::raw::c_void,
        version: u32,
        id: u32,
    ),
>;
extern "C" {
    pub fn wl_display_get_serial(display: *mut wl_display) -> u32;
}
extern "C" {
    pub fn wl_display_next_serial(display: *mut wl_display) -> u32;
}
extern "C" {
    pub fn wl_display_add_destroy_listener(display: *mut wl_display, listener: *mut wl_listener);
}
extern "C" {
    pub fn wl_display_add_client_created_listener(
        display: *mut wl_display,
        listener: *mut wl_listener,
    );
}
extern "C" {
    pub fn wl_display_get_destroy_listener(
        display: *mut wl_display,
        notify: wl_notify_func_t,
    ) -> *mut wl_listener;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_global {
    _unused: [u8; 0],
}
extern "C" {
    pub fn wl_global_create(
        display: *mut wl_display,
        interface: *const wl_interface,
        version: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
        bind: wl_global_bind_func_t,
    ) -> *mut wl_global;
}
extern "C" {
    pub fn wl_global_destroy(global: *mut wl_global);
}
pub type wl_display_global_filter_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        client: *const wl_client,
        global: *const wl_global,
        data: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
extern "C" {
    pub fn wl_display_set_global_filter(
        display: *mut wl_display,
        filter: wl_display_global_filter_func_t,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn wl_global_get_interface(global: *const wl_global) -> *const wl_interface;
}
extern "C" {
    pub fn wl_global_get_user_data(global: *const wl_global) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn wl_client_create(display: *mut wl_display, fd: ::std::os::raw::c_int) -> *mut wl_client;
}
extern "C" {
    pub fn wl_display_get_client_list(display: *mut wl_display) -> *mut wl_list;
}
extern "C" {
    pub fn wl_client_get_link(client: *mut wl_client) -> *mut wl_list;
}
extern "C" {
    pub fn wl_client_from_link(link: *mut wl_list) -> *mut wl_client;
}
extern "C" {
    pub fn wl_client_destroy(client: *mut wl_client);
}
extern "C" {
    pub fn wl_client_flush(client: *mut wl_client);
}
extern "C" {
    pub fn wl_client_get_credentials(
        client: *mut wl_client,
        pid: *mut pid_t,
        uid: *mut uid_t,
        gid: *mut gid_t,
    );
}
extern "C" {
    pub fn wl_client_get_fd(client: *mut wl_client) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wl_client_add_destroy_listener(client: *mut wl_client, listener: *mut wl_listener);
}
extern "C" {
    pub fn wl_client_get_destroy_listener(
        client: *mut wl_client,
        notify: wl_notify_func_t,
    ) -> *mut wl_listener;
}
extern "C" {
    pub fn wl_client_get_object(client: *mut wl_client, id: u32) -> *mut wl_resource;
}
extern "C" {
    pub fn wl_client_post_no_memory(client: *mut wl_client);
}
extern "C" {
    pub fn wl_client_add_resource_created_listener(
        client: *mut wl_client,
        listener: *mut wl_listener,
    );
}
pub type wl_client_for_each_resource_iterator_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        resource: *mut wl_resource,
        user_data: *mut ::std::os::raw::c_void,
    ) -> wl_iterator_result::Type,
>;
extern "C" {
    pub fn wl_client_for_each_resource(
        client: *mut wl_client,
        iterator: wl_client_for_each_resource_iterator_func_t,
        user_data: *mut ::std::os::raw::c_void,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_listener {
    pub link: wl_list,
    pub notify: wl_notify_func_t,
}
#[test]
fn bindgen_test_layout_wl_listener() {
    assert_eq!(
        ::std::mem::size_of::<wl_listener>(),
        24usize,
        concat!("Size of: ", stringify!(wl_listener))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_listener>(),
        8usize,
        concat!("Alignment of ", stringify!(wl_listener))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_listener>())).link as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_listener),
            "::",
            stringify!(link)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_listener>())).notify as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_listener),
            "::",
            stringify!(notify)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_signal {
    pub listener_list: wl_list,
}
#[test]
fn bindgen_test_layout_wl_signal() {
    assert_eq!(
        ::std::mem::size_of::<wl_signal>(),
        16usize,
        concat!("Size of: ", stringify!(wl_signal))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_signal>(),
        8usize,
        concat!("Alignment of ", stringify!(wl_signal))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_signal>())).listener_list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_signal),
            "::",
            stringify!(listener_list)
        )
    );
}
pub type wl_resource_destroy_func_t =
    ::std::option::Option<unsafe extern "C" fn(resource: *mut wl_resource)>;
extern "C" {
    pub fn wl_resource_post_event(resource: *mut wl_resource, opcode: u32, ...);
}
extern "C" {
    pub fn wl_resource_post_event_array(
        resource: *mut wl_resource,
        opcode: u32,
        args: *mut wl_argument,
    );
}
extern "C" {
    pub fn wl_resource_queue_event(resource: *mut wl_resource, opcode: u32, ...);
}
extern "C" {
    pub fn wl_resource_queue_event_array(
        resource: *mut wl_resource,
        opcode: u32,
        args: *mut wl_argument,
    );
}
extern "C" {
    pub fn wl_resource_post_error(
        resource: *mut wl_resource,
        code: u32,
        msg: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn wl_resource_post_no_memory(resource: *mut wl_resource);
}
extern "C" {
    pub fn wl_client_get_display(client: *mut wl_client) -> *mut wl_display;
}
extern "C" {
    pub fn wl_resource_create(
        client: *mut wl_client,
        interface: *const wl_interface,
        version: ::std::os::raw::c_int,
        id: u32,
    ) -> *mut wl_resource;
}
extern "C" {
    pub fn wl_resource_set_implementation(
        resource: *mut wl_resource,
        implementation: *const ::std::os::raw::c_void,
        data: *mut ::std::os::raw::c_void,
        destroy: wl_resource_destroy_func_t,
    );
}
extern "C" {
    pub fn wl_resource_set_dispatcher(
        resource: *mut wl_resource,
        dispatcher: wl_dispatcher_func_t,
        implementation: *const ::std::os::raw::c_void,
        data: *mut ::std::os::raw::c_void,
        destroy: wl_resource_destroy_func_t,
    );
}
extern "C" {
    pub fn wl_resource_destroy(resource: *mut wl_resource);
}
extern "C" {
    pub fn wl_resource_get_id(resource: *mut wl_resource) -> u32;
}
extern "C" {
    pub fn wl_resource_get_link(resource: *mut wl_resource) -> *mut wl_list;
}
extern "C" {
    pub fn wl_resource_from_link(resource: *mut wl_list) -> *mut wl_resource;
}
extern "C" {
    pub fn wl_resource_find_for_client(
        list: *mut wl_list,
        client: *mut wl_client,
    ) -> *mut wl_resource;
}
extern "C" {
    pub fn wl_resource_get_client(resource: *mut wl_resource) -> *mut wl_client;
}
extern "C" {
    pub fn wl_resource_set_user_data(resource: *mut wl_resource, data: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn wl_resource_get_user_data(resource: *mut wl_resource) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn wl_resource_get_version(resource: *mut wl_resource) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wl_resource_set_destructor(
        resource: *mut wl_resource,
        destroy: wl_resource_destroy_func_t,
    );
}
extern "C" {
    pub fn wl_resource_instance_of(
        resource: *mut wl_resource,
        interface: *const wl_interface,
        implementation: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wl_resource_get_class(resource: *mut wl_resource) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn wl_resource_add_destroy_listener(resource: *mut wl_resource, listener: *mut wl_listener);
}
extern "C" {
    pub fn wl_resource_get_destroy_listener(
        resource: *mut wl_resource,
        notify: wl_notify_func_t,
    ) -> *mut wl_listener;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_shm_buffer {
    _unused: [u8; 0],
}
extern "C" {
    pub fn wl_shm_buffer_get(resource: *mut wl_resource) -> *mut wl_shm_buffer;
}
extern "C" {
    pub fn wl_shm_buffer_begin_access(buffer: *mut wl_shm_buffer);
}
extern "C" {
    pub fn wl_shm_buffer_end_access(buffer: *mut wl_shm_buffer);
}
extern "C" {
    pub fn wl_shm_buffer_get_data(buffer: *mut wl_shm_buffer) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn wl_shm_buffer_get_stride(buffer: *mut wl_shm_buffer) -> i32;
}
extern "C" {
    pub fn wl_shm_buffer_get_format(buffer: *mut wl_shm_buffer) -> u32;
}
extern "C" {
    pub fn wl_shm_buffer_get_width(buffer: *mut wl_shm_buffer) -> i32;
}
extern "C" {
    pub fn wl_shm_buffer_get_height(buffer: *mut wl_shm_buffer) -> i32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_shm_pool {
    _unused: [u8; 0],
}
extern "C" {
    pub fn wl_shm_buffer_ref_pool(buffer: *mut wl_shm_buffer) -> *mut wl_shm_pool;
}
extern "C" {
    pub fn wl_shm_pool_unref(pool: *mut wl_shm_pool);
}
extern "C" {
    pub fn wl_display_init_shm(display: *mut wl_display) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wl_display_add_shm_format(display: *mut wl_display, format: u32) -> *mut u32;
}
extern "C" {
    pub fn wl_shm_buffer_create(
        client: *mut wl_client,
        id: u32,
        width: i32,
        height: i32,
        stride: i32,
        format: u32,
    ) -> *mut wl_shm_buffer;
}
extern "C" {
    pub fn wl_log_set_handler_server(handler: wl_log_func_t);
}
pub mod wl_protocol_logger_type {
    pub type Type = u32;
    pub const WL_PROTOCOL_LOGGER_REQUEST: Type = 0;
    pub const WL_PROTOCOL_LOGGER_EVENT: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_protocol_logger_message {
    pub resource: *mut wl_resource,
    pub message_opcode: ::std::os::raw::c_int,
    pub message: *const wl_message,
    pub arguments_count: ::std::os::raw::c_int,
    pub arguments: *const wl_argument,
}
#[test]
fn bindgen_test_layout_wl_protocol_logger_message() {
    assert_eq!(
        ::std::mem::size_of::<wl_protocol_logger_message>(),
        40usize,
        concat!("Size of: ", stringify!(wl_protocol_logger_message))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_protocol_logger_message>(),
        8usize,
        concat!("Alignment of ", stringify!(wl_protocol_logger_message))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_protocol_logger_message>())).resource as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_protocol_logger_message),
            "::",
            stringify!(resource)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_protocol_logger_message>())).message_opcode as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_protocol_logger_message),
            "::",
            stringify!(message_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_protocol_logger_message>())).message as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_protocol_logger_message),
            "::",
            stringify!(message)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_protocol_logger_message>())).arguments_count as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_protocol_logger_message),
            "::",
            stringify!(arguments_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_protocol_logger_message>())).arguments as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_protocol_logger_message),
            "::",
            stringify!(arguments)
        )
    );
}
pub type wl_protocol_logger_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        direction: wl_protocol_logger_type::Type,
        message: *const wl_protocol_logger_message,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_protocol_logger {
    _unused: [u8; 0],
}
extern "C" {
    pub fn wl_display_add_protocol_logger(
        display: *mut wl_display,
        arg1: wl_protocol_logger_func_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> *mut wl_protocol_logger;
}
extern "C" {
    pub fn wl_protocol_logger_destroy(logger: *mut wl_protocol_logger);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_object {
    pub interface: *const wl_interface,
    pub implementation: *const ::std::os::raw::c_void,
    pub id: u32,
}
#[test]
fn bindgen_test_layout_wl_object() {
    assert_eq!(
        ::std::mem::size_of::<wl_object>(),
        24usize,
        concat!("Size of: ", stringify!(wl_object))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_object>(),
        8usize,
        concat!("Alignment of ", stringify!(wl_object))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_object>())).interface as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_object),
            "::",
            stringify!(interface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_object>())).implementation as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_object),
            "::",
            stringify!(implementation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_object>())).id as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_object),
            "::",
            stringify!(id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_resource {
    pub object: wl_object,
    pub destroy: wl_resource_destroy_func_t,
    pub link: wl_list,
    pub destroy_signal: wl_signal,
    pub client: *mut wl_client,
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_wl_resource() {
    assert_eq!(
        ::std::mem::size_of::<wl_resource>(),
        80usize,
        concat!("Size of: ", stringify!(wl_resource))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_resource>(),
        8usize,
        concat!("Alignment of ", stringify!(wl_resource))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_resource>())).object as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_resource),
            "::",
            stringify!(object)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_resource>())).destroy as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_resource),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_resource>())).link as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_resource),
            "::",
            stringify!(link)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_resource>())).destroy_signal as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_resource),
            "::",
            stringify!(destroy_signal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_resource>())).client as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_resource),
            "::",
            stringify!(client)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_resource>())).data as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_resource),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    pub fn wl_client_add_resource(client: *mut wl_client, resource: *mut wl_resource) -> u32;
}
extern "C" {
    pub fn wl_client_add_object(
        client: *mut wl_client,
        interface: *const wl_interface,
        implementation: *const ::std::os::raw::c_void,
        id: u32,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut wl_resource;
}
extern "C" {
    pub fn wl_client_new_object(
        client: *mut wl_client,
        interface: *const wl_interface,
        implementation: *const ::std::os::raw::c_void,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut wl_resource;
}
extern "C" {
    pub fn wl_display_add_global(
        display: *mut wl_display,
        interface: *const wl_interface,
        data: *mut ::std::os::raw::c_void,
        bind: wl_global_bind_func_t,
    ) -> *mut wl_global;
}
extern "C" {
    pub fn wl_display_remove_global(display: *mut wl_display, global: *mut wl_global);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_buffer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_callback {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_compositor {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_data_device {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_data_device_manager {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_data_offer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_data_source {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_keyboard {
    _unused: [u8; 0],
}
#[doc = " @page page_xdg_shell The xdg_shell protocol"]
#[doc = " @section page_ifaces_xdg_shell Interfaces"]
#[doc = " - @subpage page_iface_xdg_wm_base - create desktop-style surfaces"]
#[doc = " - @subpage page_iface_xdg_positioner - child surface positioner"]
#[doc = " - @subpage page_iface_xdg_surface - desktop user interface surface base interface"]
#[doc = " - @subpage page_iface_xdg_toplevel - toplevel surface"]
#[doc = " - @subpage page_iface_xdg_popup - short-lived, popup surfaces for menus"]
#[doc = " @section page_copyright_xdg_shell Copyright"]
#[doc = " <pre>"]
#[doc = ""]
#[doc = " Copyright \u{a9} 2008-2013 Kristian H\u{f8}gsberg"]
#[doc = " Copyright \u{a9} 2013      Rafael Antognolli"]
#[doc = " Copyright \u{a9} 2013      Jasper St. Pierre"]
#[doc = " Copyright \u{a9} 2010-2013 Intel Corporation"]
#[doc = " Copyright \u{a9} 2015-2017 Samsung Electronics Co., Ltd"]
#[doc = " Copyright \u{a9} 2015-2017 Red Hat Inc."]
#[doc = ""]
#[doc = " Permission is hereby granted, free of charge, to any person obtaining a"]
#[doc = " copy of this software and associated documentation files (the \"Software\"),"]
#[doc = " to deal in the Software without restriction, including without limitation"]
#[doc = " the rights to use, copy, modify, merge, publish, distribute, sublicense,"]
#[doc = " and/or sell copies of the Software, and to permit persons to whom the"]
#[doc = " Software is furnished to do so, subject to the following conditions:"]
#[doc = ""]
#[doc = " The above copyright notice and this permission notice (including the next"]
#[doc = " paragraph) shall be included in all copies or substantial portions of the"]
#[doc = " Software."]
#[doc = ""]
#[doc = " THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR"]
#[doc = " IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,"]
#[doc = " FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL"]
#[doc = " THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER"]
#[doc = " LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING"]
#[doc = " FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER"]
#[doc = " DEALINGS IN THE SOFTWARE."]
#[doc = " </pre>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_output {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_pointer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_region {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_registry {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_seat {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_shell {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_shell_surface {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_shm {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_subcompositor {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_subsurface {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_surface {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_touch {
    _unused: [u8; 0],
}
extern "C" {
    pub static wl_display_interface: wl_interface;
}
extern "C" {
    pub static wl_registry_interface: wl_interface;
}
extern "C" {
    pub static wl_callback_interface: wl_interface;
}
extern "C" {
    pub static wl_compositor_interface: wl_interface;
}
extern "C" {
    pub static wl_shm_pool_interface: wl_interface;
}
extern "C" {
    pub static wl_shm_interface: wl_interface;
}
extern "C" {
    pub static wl_buffer_interface: wl_interface;
}
extern "C" {
    pub static wl_data_offer_interface: wl_interface;
}
extern "C" {
    pub static wl_data_source_interface: wl_interface;
}
extern "C" {
    pub static wl_data_device_interface: wl_interface;
}
extern "C" {
    pub static wl_data_device_manager_interface: wl_interface;
}
extern "C" {
    pub static wl_shell_interface: wl_interface;
}
extern "C" {
    pub static wl_shell_surface_interface: wl_interface;
}
extern "C" {
    pub static wl_surface_interface: wl_interface;
}
extern "C" {
    pub static wl_seat_interface: wl_interface;
}
extern "C" {
    pub static wl_pointer_interface: wl_interface;
}
extern "C" {
    pub static wl_keyboard_interface: wl_interface;
}
extern "C" {
    pub static wl_touch_interface: wl_interface;
}
extern "C" {
    pub static wl_output_interface: wl_interface;
}
extern "C" {
    pub static wl_region_interface: wl_interface;
}
extern "C" {
    pub static wl_subcompositor_interface: wl_interface;
}
extern "C" {
    pub static wl_subsurface_interface: wl_interface;
}
pub mod wl_display_error {
    pub type Type = u32;
    pub const WL_DISPLAY_ERROR_INVALID_OBJECT: Type = 0;
    pub const WL_DISPLAY_ERROR_INVALID_METHOD: Type = 1;
    pub const WL_DISPLAY_ERROR_NO_MEMORY: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_display_interface {
    pub sync: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource, callback: u32),
    >,
    pub get_registry: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource, registry: u32),
    >,
}
#[test]
fn bindgen_test_layout_wl_display_interface() {
    assert_eq!(
        ::std::mem::size_of::<wl_display_interface>(),
        16usize,
        concat!("Size of: ", stringify!(wl_display_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_display_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(wl_display_interface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_display_interface>())).sync as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_display_interface),
            "::",
            stringify!(sync)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_display_interface>())).get_registry as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_display_interface),
            "::",
            stringify!(get_registry)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_registry_interface {
    pub bind: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            name: u32,
            interface: *const ::std::os::raw::c_char,
            version: u32,
            id: u32,
        ),
    >,
}
#[test]
fn bindgen_test_layout_wl_registry_interface() {
    assert_eq!(
        ::std::mem::size_of::<wl_registry_interface>(),
        8usize,
        concat!("Size of: ", stringify!(wl_registry_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_registry_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(wl_registry_interface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_registry_interface>())).bind as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_registry_interface),
            "::",
            stringify!(bind)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_compositor_interface {
    pub create_surface: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource, id: u32),
    >,
    pub create_region: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource, id: u32),
    >,
}
#[test]
fn bindgen_test_layout_wl_compositor_interface() {
    assert_eq!(
        ::std::mem::size_of::<wl_compositor_interface>(),
        16usize,
        concat!("Size of: ", stringify!(wl_compositor_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_compositor_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(wl_compositor_interface))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_compositor_interface>())).create_surface as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_compositor_interface),
            "::",
            stringify!(create_surface)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_compositor_interface>())).create_region as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_compositor_interface),
            "::",
            stringify!(create_region)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_shm_pool_interface {
    pub create_buffer: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            id: u32,
            offset: i32,
            width: i32,
            height: i32,
            stride: i32,
            format: u32,
        ),
    >,
    pub destroy: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
    pub resize: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource, size: i32),
    >,
}
#[test]
fn bindgen_test_layout_wl_shm_pool_interface() {
    assert_eq!(
        ::std::mem::size_of::<wl_shm_pool_interface>(),
        24usize,
        concat!("Size of: ", stringify!(wl_shm_pool_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_shm_pool_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(wl_shm_pool_interface))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_shm_pool_interface>())).create_buffer as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_shm_pool_interface),
            "::",
            stringify!(create_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_shm_pool_interface>())).destroy as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_shm_pool_interface),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_shm_pool_interface>())).resize as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_shm_pool_interface),
            "::",
            stringify!(resize)
        )
    );
}
pub mod wl_shm_error {
    pub type Type = u32;
    pub const WL_SHM_ERROR_INVALID_FORMAT: Type = 0;
    pub const WL_SHM_ERROR_INVALID_STRIDE: Type = 1;
    pub const WL_SHM_ERROR_INVALID_FD: Type = 2;
}
pub mod wl_shm_format {
    pub type Type = u32;
    pub const WL_SHM_FORMAT_ARGB8888: Type = 0;
    pub const WL_SHM_FORMAT_XRGB8888: Type = 1;
    pub const WL_SHM_FORMAT_C8: Type = 538982467;
    pub const WL_SHM_FORMAT_RGB332: Type = 943867730;
    pub const WL_SHM_FORMAT_BGR233: Type = 944916290;
    pub const WL_SHM_FORMAT_XRGB4444: Type = 842093144;
    pub const WL_SHM_FORMAT_XBGR4444: Type = 842089048;
    pub const WL_SHM_FORMAT_RGBX4444: Type = 842094674;
    pub const WL_SHM_FORMAT_BGRX4444: Type = 842094658;
    pub const WL_SHM_FORMAT_ARGB4444: Type = 842093121;
    pub const WL_SHM_FORMAT_ABGR4444: Type = 842089025;
    pub const WL_SHM_FORMAT_RGBA4444: Type = 842088786;
    pub const WL_SHM_FORMAT_BGRA4444: Type = 842088770;
    pub const WL_SHM_FORMAT_XRGB1555: Type = 892424792;
    pub const WL_SHM_FORMAT_XBGR1555: Type = 892420696;
    pub const WL_SHM_FORMAT_RGBX5551: Type = 892426322;
    pub const WL_SHM_FORMAT_BGRX5551: Type = 892426306;
    pub const WL_SHM_FORMAT_ARGB1555: Type = 892424769;
    pub const WL_SHM_FORMAT_ABGR1555: Type = 892420673;
    pub const WL_SHM_FORMAT_RGBA5551: Type = 892420434;
    pub const WL_SHM_FORMAT_BGRA5551: Type = 892420418;
    pub const WL_SHM_FORMAT_RGB565: Type = 909199186;
    pub const WL_SHM_FORMAT_BGR565: Type = 909199170;
    pub const WL_SHM_FORMAT_RGB888: Type = 875710290;
    pub const WL_SHM_FORMAT_BGR888: Type = 875710274;
    pub const WL_SHM_FORMAT_XBGR8888: Type = 875709016;
    pub const WL_SHM_FORMAT_RGBX8888: Type = 875714642;
    pub const WL_SHM_FORMAT_BGRX8888: Type = 875714626;
    pub const WL_SHM_FORMAT_ABGR8888: Type = 875708993;
    pub const WL_SHM_FORMAT_RGBA8888: Type = 875708754;
    pub const WL_SHM_FORMAT_BGRA8888: Type = 875708738;
    pub const WL_SHM_FORMAT_XRGB2101010: Type = 808669784;
    pub const WL_SHM_FORMAT_XBGR2101010: Type = 808665688;
    pub const WL_SHM_FORMAT_RGBX1010102: Type = 808671314;
    pub const WL_SHM_FORMAT_BGRX1010102: Type = 808671298;
    pub const WL_SHM_FORMAT_ARGB2101010: Type = 808669761;
    pub const WL_SHM_FORMAT_ABGR2101010: Type = 808665665;
    pub const WL_SHM_FORMAT_RGBA1010102: Type = 808665426;
    pub const WL_SHM_FORMAT_BGRA1010102: Type = 808665410;
    pub const WL_SHM_FORMAT_YUYV: Type = 1448695129;
    pub const WL_SHM_FORMAT_YVYU: Type = 1431918169;
    pub const WL_SHM_FORMAT_UYVY: Type = 1498831189;
    pub const WL_SHM_FORMAT_VYUY: Type = 1498765654;
    pub const WL_SHM_FORMAT_AYUV: Type = 1448433985;
    pub const WL_SHM_FORMAT_NV12: Type = 842094158;
    pub const WL_SHM_FORMAT_NV21: Type = 825382478;
    pub const WL_SHM_FORMAT_NV16: Type = 909203022;
    pub const WL_SHM_FORMAT_NV61: Type = 825644622;
    pub const WL_SHM_FORMAT_YUV410: Type = 961959257;
    pub const WL_SHM_FORMAT_YVU410: Type = 961893977;
    pub const WL_SHM_FORMAT_YUV411: Type = 825316697;
    pub const WL_SHM_FORMAT_YVU411: Type = 825316953;
    pub const WL_SHM_FORMAT_YUV420: Type = 842093913;
    pub const WL_SHM_FORMAT_YVU420: Type = 842094169;
    pub const WL_SHM_FORMAT_YUV422: Type = 909202777;
    pub const WL_SHM_FORMAT_YVU422: Type = 909203033;
    pub const WL_SHM_FORMAT_YUV444: Type = 875713881;
    pub const WL_SHM_FORMAT_YVU444: Type = 875714137;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_shm_interface {
    pub create_pool: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            id: u32,
            fd: i32,
            size: i32,
        ),
    >,
}
#[test]
fn bindgen_test_layout_wl_shm_interface() {
    assert_eq!(
        ::std::mem::size_of::<wl_shm_interface>(),
        8usize,
        concat!("Size of: ", stringify!(wl_shm_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_shm_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(wl_shm_interface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_shm_interface>())).create_pool as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_shm_interface),
            "::",
            stringify!(create_pool)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_buffer_interface {
    pub destroy: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
}
#[test]
fn bindgen_test_layout_wl_buffer_interface() {
    assert_eq!(
        ::std::mem::size_of::<wl_buffer_interface>(),
        8usize,
        concat!("Size of: ", stringify!(wl_buffer_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_buffer_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(wl_buffer_interface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_buffer_interface>())).destroy as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_buffer_interface),
            "::",
            stringify!(destroy)
        )
    );
}
pub mod wl_data_offer_error {
    pub type Type = u32;
    pub const WL_DATA_OFFER_ERROR_INVALID_FINISH: Type = 0;
    pub const WL_DATA_OFFER_ERROR_INVALID_ACTION_MASK: Type = 1;
    pub const WL_DATA_OFFER_ERROR_INVALID_ACTION: Type = 2;
    pub const WL_DATA_OFFER_ERROR_INVALID_OFFER: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_data_offer_interface {
    pub accept: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            serial: u32,
            mime_type: *const ::std::os::raw::c_char,
        ),
    >,
    pub receive: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            mime_type: *const ::std::os::raw::c_char,
            fd: i32,
        ),
    >,
    pub destroy: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
    pub finish: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
    pub set_actions: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            dnd_actions: u32,
            preferred_action: u32,
        ),
    >,
}
#[test]
fn bindgen_test_layout_wl_data_offer_interface() {
    assert_eq!(
        ::std::mem::size_of::<wl_data_offer_interface>(),
        40usize,
        concat!("Size of: ", stringify!(wl_data_offer_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_data_offer_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(wl_data_offer_interface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_data_offer_interface>())).accept as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_data_offer_interface),
            "::",
            stringify!(accept)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_data_offer_interface>())).receive as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_data_offer_interface),
            "::",
            stringify!(receive)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_data_offer_interface>())).destroy as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_data_offer_interface),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_data_offer_interface>())).finish as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_data_offer_interface),
            "::",
            stringify!(finish)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_data_offer_interface>())).set_actions as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_data_offer_interface),
            "::",
            stringify!(set_actions)
        )
    );
}
pub mod wl_data_source_error {
    pub type Type = u32;
    pub const WL_DATA_SOURCE_ERROR_INVALID_ACTION_MASK: Type = 0;
    pub const WL_DATA_SOURCE_ERROR_INVALID_SOURCE: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_data_source_interface {
    pub offer: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            mime_type: *const ::std::os::raw::c_char,
        ),
    >,
    pub destroy: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
    pub set_actions: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource, dnd_actions: u32),
    >,
}
#[test]
fn bindgen_test_layout_wl_data_source_interface() {
    assert_eq!(
        ::std::mem::size_of::<wl_data_source_interface>(),
        24usize,
        concat!("Size of: ", stringify!(wl_data_source_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_data_source_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(wl_data_source_interface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_data_source_interface>())).offer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_data_source_interface),
            "::",
            stringify!(offer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_data_source_interface>())).destroy as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_data_source_interface),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_data_source_interface>())).set_actions as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_data_source_interface),
            "::",
            stringify!(set_actions)
        )
    );
}
pub mod wl_data_device_error {
    pub type Type = u32;
    pub const WL_DATA_DEVICE_ERROR_ROLE: Type = 0;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_data_device_interface {
    pub start_drag: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            source: *mut wl_resource,
            origin: *mut wl_resource,
            icon: *mut wl_resource,
            serial: u32,
        ),
    >,
    pub set_selection: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            source: *mut wl_resource,
            serial: u32,
        ),
    >,
    pub release: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
}
#[test]
fn bindgen_test_layout_wl_data_device_interface() {
    assert_eq!(
        ::std::mem::size_of::<wl_data_device_interface>(),
        24usize,
        concat!("Size of: ", stringify!(wl_data_device_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_data_device_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(wl_data_device_interface))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_data_device_interface>())).start_drag as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_data_device_interface),
            "::",
            stringify!(start_drag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_data_device_interface>())).set_selection as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_data_device_interface),
            "::",
            stringify!(set_selection)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_data_device_interface>())).release as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_data_device_interface),
            "::",
            stringify!(release)
        )
    );
}
pub mod wl_data_device_manager_dnd_action {
    pub type Type = u32;
    pub const WL_DATA_DEVICE_MANAGER_DND_ACTION_NONE: Type = 0;
    pub const WL_DATA_DEVICE_MANAGER_DND_ACTION_COPY: Type = 1;
    pub const WL_DATA_DEVICE_MANAGER_DND_ACTION_MOVE: Type = 2;
    pub const WL_DATA_DEVICE_MANAGER_DND_ACTION_ASK: Type = 4;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_data_device_manager_interface {
    pub create_data_source: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource, id: u32),
    >,
    pub get_data_device: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            id: u32,
            seat: *mut wl_resource,
        ),
    >,
}
#[test]
fn bindgen_test_layout_wl_data_device_manager_interface() {
    assert_eq!(
        ::std::mem::size_of::<wl_data_device_manager_interface>(),
        16usize,
        concat!("Size of: ", stringify!(wl_data_device_manager_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_data_device_manager_interface>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(wl_data_device_manager_interface)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_data_device_manager_interface>())).create_data_source
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_data_device_manager_interface),
            "::",
            stringify!(create_data_source)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_data_device_manager_interface>())).get_data_device as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_data_device_manager_interface),
            "::",
            stringify!(get_data_device)
        )
    );
}
pub mod wl_shell_error {
    pub type Type = u32;
    pub const WL_SHELL_ERROR_ROLE: Type = 0;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_shell_interface {
    pub get_shell_surface: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            id: u32,
            surface: *mut wl_resource,
        ),
    >,
}
#[test]
fn bindgen_test_layout_wl_shell_interface() {
    assert_eq!(
        ::std::mem::size_of::<wl_shell_interface>(),
        8usize,
        concat!("Size of: ", stringify!(wl_shell_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_shell_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(wl_shell_interface))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_shell_interface>())).get_shell_surface as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_shell_interface),
            "::",
            stringify!(get_shell_surface)
        )
    );
}
pub mod wl_shell_surface_resize {
    pub type Type = u32;
    pub const WL_SHELL_SURFACE_RESIZE_NONE: Type = 0;
    pub const WL_SHELL_SURFACE_RESIZE_TOP: Type = 1;
    pub const WL_SHELL_SURFACE_RESIZE_BOTTOM: Type = 2;
    pub const WL_SHELL_SURFACE_RESIZE_LEFT: Type = 4;
    pub const WL_SHELL_SURFACE_RESIZE_TOP_LEFT: Type = 5;
    pub const WL_SHELL_SURFACE_RESIZE_BOTTOM_LEFT: Type = 6;
    pub const WL_SHELL_SURFACE_RESIZE_RIGHT: Type = 8;
    pub const WL_SHELL_SURFACE_RESIZE_TOP_RIGHT: Type = 9;
    pub const WL_SHELL_SURFACE_RESIZE_BOTTOM_RIGHT: Type = 10;
}
pub mod wl_shell_surface_transient {
    pub type Type = u32;
    pub const WL_SHELL_SURFACE_TRANSIENT_INACTIVE: Type = 1;
}
pub mod wl_shell_surface_fullscreen_method {
    pub type Type = u32;
    pub const WL_SHELL_SURFACE_FULLSCREEN_METHOD_DEFAULT: Type = 0;
    pub const WL_SHELL_SURFACE_FULLSCREEN_METHOD_SCALE: Type = 1;
    pub const WL_SHELL_SURFACE_FULLSCREEN_METHOD_DRIVER: Type = 2;
    pub const WL_SHELL_SURFACE_FULLSCREEN_METHOD_FILL: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_shell_surface_interface {
    pub pong: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource, serial: u32),
    >,
    pub move_: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            seat: *mut wl_resource,
            serial: u32,
        ),
    >,
    pub resize: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            seat: *mut wl_resource,
            serial: u32,
            edges: u32,
        ),
    >,
    pub set_toplevel: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
    pub set_transient: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            parent: *mut wl_resource,
            x: i32,
            y: i32,
            flags: u32,
        ),
    >,
    pub set_fullscreen: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            method: u32,
            framerate: u32,
            output: *mut wl_resource,
        ),
    >,
    pub set_popup: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            seat: *mut wl_resource,
            serial: u32,
            parent: *mut wl_resource,
            x: i32,
            y: i32,
            flags: u32,
        ),
    >,
    pub set_maximized: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            output: *mut wl_resource,
        ),
    >,
    pub set_title: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            title: *const ::std::os::raw::c_char,
        ),
    >,
    pub set_class: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            class_: *const ::std::os::raw::c_char,
        ),
    >,
}
#[test]
fn bindgen_test_layout_wl_shell_surface_interface() {
    assert_eq!(
        ::std::mem::size_of::<wl_shell_surface_interface>(),
        80usize,
        concat!("Size of: ", stringify!(wl_shell_surface_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_shell_surface_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(wl_shell_surface_interface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_shell_surface_interface>())).pong as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_shell_surface_interface),
            "::",
            stringify!(pong)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_shell_surface_interface>())).move_ as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_shell_surface_interface),
            "::",
            stringify!(move_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_shell_surface_interface>())).resize as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_shell_surface_interface),
            "::",
            stringify!(resize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_shell_surface_interface>())).set_toplevel as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_shell_surface_interface),
            "::",
            stringify!(set_toplevel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_shell_surface_interface>())).set_transient as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_shell_surface_interface),
            "::",
            stringify!(set_transient)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_shell_surface_interface>())).set_fullscreen as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_shell_surface_interface),
            "::",
            stringify!(set_fullscreen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_shell_surface_interface>())).set_popup as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_shell_surface_interface),
            "::",
            stringify!(set_popup)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_shell_surface_interface>())).set_maximized as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_shell_surface_interface),
            "::",
            stringify!(set_maximized)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_shell_surface_interface>())).set_title as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_shell_surface_interface),
            "::",
            stringify!(set_title)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_shell_surface_interface>())).set_class as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_shell_surface_interface),
            "::",
            stringify!(set_class)
        )
    );
}
pub mod wl_surface_error {
    pub type Type = u32;
    pub const WL_SURFACE_ERROR_INVALID_SCALE: Type = 0;
    pub const WL_SURFACE_ERROR_INVALID_TRANSFORM: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_surface_interface {
    pub destroy: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
    pub attach: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            buffer: *mut wl_resource,
            x: i32,
            y: i32,
        ),
    >,
    pub damage: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            x: i32,
            y: i32,
            width: i32,
            height: i32,
        ),
    >,
    pub frame: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource, callback: u32),
    >,
    pub set_opaque_region: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            region: *mut wl_resource,
        ),
    >,
    pub set_input_region: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            region: *mut wl_resource,
        ),
    >,
    pub commit: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
    pub set_buffer_transform: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource, transform: i32),
    >,
    pub set_buffer_scale: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource, scale: i32),
    >,
    pub damage_buffer: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            x: i32,
            y: i32,
            width: i32,
            height: i32,
        ),
    >,
}
#[test]
fn bindgen_test_layout_wl_surface_interface() {
    assert_eq!(
        ::std::mem::size_of::<wl_surface_interface>(),
        80usize,
        concat!("Size of: ", stringify!(wl_surface_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_surface_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(wl_surface_interface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_surface_interface>())).destroy as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_surface_interface),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_surface_interface>())).attach as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_surface_interface),
            "::",
            stringify!(attach)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_surface_interface>())).damage as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_surface_interface),
            "::",
            stringify!(damage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_surface_interface>())).frame as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_surface_interface),
            "::",
            stringify!(frame)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_surface_interface>())).set_opaque_region as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_surface_interface),
            "::",
            stringify!(set_opaque_region)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_surface_interface>())).set_input_region as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_surface_interface),
            "::",
            stringify!(set_input_region)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_surface_interface>())).commit as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_surface_interface),
            "::",
            stringify!(commit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_surface_interface>())).set_buffer_transform as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_surface_interface),
            "::",
            stringify!(set_buffer_transform)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_surface_interface>())).set_buffer_scale as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_surface_interface),
            "::",
            stringify!(set_buffer_scale)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_surface_interface>())).damage_buffer as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_surface_interface),
            "::",
            stringify!(damage_buffer)
        )
    );
}
pub mod wl_seat_capability {
    pub type Type = u32;
    pub const WL_SEAT_CAPABILITY_POINTER: Type = 1;
    pub const WL_SEAT_CAPABILITY_KEYBOARD: Type = 2;
    pub const WL_SEAT_CAPABILITY_TOUCH: Type = 4;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_seat_interface {
    pub get_pointer: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource, id: u32),
    >,
    pub get_keyboard: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource, id: u32),
    >,
    pub get_touch: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource, id: u32),
    >,
    pub release: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
}
#[test]
fn bindgen_test_layout_wl_seat_interface() {
    assert_eq!(
        ::std::mem::size_of::<wl_seat_interface>(),
        32usize,
        concat!("Size of: ", stringify!(wl_seat_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_seat_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(wl_seat_interface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_seat_interface>())).get_pointer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_seat_interface),
            "::",
            stringify!(get_pointer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_seat_interface>())).get_keyboard as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_seat_interface),
            "::",
            stringify!(get_keyboard)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_seat_interface>())).get_touch as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_seat_interface),
            "::",
            stringify!(get_touch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_seat_interface>())).release as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_seat_interface),
            "::",
            stringify!(release)
        )
    );
}
pub mod wl_pointer_error {
    pub type Type = u32;
    pub const WL_POINTER_ERROR_ROLE: Type = 0;
}
pub mod wl_pointer_button_state {
    pub type Type = u32;
    pub const WL_POINTER_BUTTON_STATE_RELEASED: Type = 0;
    pub const WL_POINTER_BUTTON_STATE_PRESSED: Type = 1;
}
pub mod wl_pointer_axis {
    pub type Type = u32;
    pub const WL_POINTER_AXIS_VERTICAL_SCROLL: Type = 0;
    pub const WL_POINTER_AXIS_HORIZONTAL_SCROLL: Type = 1;
}
pub mod wl_pointer_axis_source {
    pub type Type = u32;
    pub const WL_POINTER_AXIS_SOURCE_WHEEL: Type = 0;
    pub const WL_POINTER_AXIS_SOURCE_FINGER: Type = 1;
    pub const WL_POINTER_AXIS_SOURCE_CONTINUOUS: Type = 2;
    pub const WL_POINTER_AXIS_SOURCE_WHEEL_TILT: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_pointer_interface {
    pub set_cursor: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            serial: u32,
            surface: *mut wl_resource,
            hotspot_x: i32,
            hotspot_y: i32,
        ),
    >,
    pub release: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
}
#[test]
fn bindgen_test_layout_wl_pointer_interface() {
    assert_eq!(
        ::std::mem::size_of::<wl_pointer_interface>(),
        16usize,
        concat!("Size of: ", stringify!(wl_pointer_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_pointer_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(wl_pointer_interface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_pointer_interface>())).set_cursor as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_pointer_interface),
            "::",
            stringify!(set_cursor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_pointer_interface>())).release as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_pointer_interface),
            "::",
            stringify!(release)
        )
    );
}
pub mod wl_keyboard_keymap_format {
    pub type Type = u32;
    pub const WL_KEYBOARD_KEYMAP_FORMAT_NO_KEYMAP: Type = 0;
    pub const WL_KEYBOARD_KEYMAP_FORMAT_XKB_V1: Type = 1;
}
pub mod wl_keyboard_key_state {
    pub type Type = u32;
    pub const WL_KEYBOARD_KEY_STATE_RELEASED: Type = 0;
    pub const WL_KEYBOARD_KEY_STATE_PRESSED: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_keyboard_interface {
    pub release: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
}
#[test]
fn bindgen_test_layout_wl_keyboard_interface() {
    assert_eq!(
        ::std::mem::size_of::<wl_keyboard_interface>(),
        8usize,
        concat!("Size of: ", stringify!(wl_keyboard_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_keyboard_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(wl_keyboard_interface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_keyboard_interface>())).release as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_keyboard_interface),
            "::",
            stringify!(release)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_touch_interface {
    pub release: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
}
#[test]
fn bindgen_test_layout_wl_touch_interface() {
    assert_eq!(
        ::std::mem::size_of::<wl_touch_interface>(),
        8usize,
        concat!("Size of: ", stringify!(wl_touch_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_touch_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(wl_touch_interface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_touch_interface>())).release as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_touch_interface),
            "::",
            stringify!(release)
        )
    );
}
pub mod wl_output_subpixel {
    pub type Type = u32;
    pub const WL_OUTPUT_SUBPIXEL_UNKNOWN: Type = 0;
    pub const WL_OUTPUT_SUBPIXEL_NONE: Type = 1;
    pub const WL_OUTPUT_SUBPIXEL_HORIZONTAL_RGB: Type = 2;
    pub const WL_OUTPUT_SUBPIXEL_HORIZONTAL_BGR: Type = 3;
    pub const WL_OUTPUT_SUBPIXEL_VERTICAL_RGB: Type = 4;
    pub const WL_OUTPUT_SUBPIXEL_VERTICAL_BGR: Type = 5;
}
pub mod wl_output_transform {
    pub type Type = u32;
    pub const WL_OUTPUT_TRANSFORM_NORMAL: Type = 0;
    pub const WL_OUTPUT_TRANSFORM_90: Type = 1;
    pub const WL_OUTPUT_TRANSFORM_180: Type = 2;
    pub const WL_OUTPUT_TRANSFORM_270: Type = 3;
    pub const WL_OUTPUT_TRANSFORM_FLIPPED: Type = 4;
    pub const WL_OUTPUT_TRANSFORM_FLIPPED_90: Type = 5;
    pub const WL_OUTPUT_TRANSFORM_FLIPPED_180: Type = 6;
    pub const WL_OUTPUT_TRANSFORM_FLIPPED_270: Type = 7;
}
pub mod wl_output_mode {
    pub type Type = u32;
    pub const WL_OUTPUT_MODE_CURRENT: Type = 1;
    pub const WL_OUTPUT_MODE_PREFERRED: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_output_interface {
    pub release: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
}
#[test]
fn bindgen_test_layout_wl_output_interface() {
    assert_eq!(
        ::std::mem::size_of::<wl_output_interface>(),
        8usize,
        concat!("Size of: ", stringify!(wl_output_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_output_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(wl_output_interface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_output_interface>())).release as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_output_interface),
            "::",
            stringify!(release)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_region_interface {
    pub destroy: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
    pub add: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            x: i32,
            y: i32,
            width: i32,
            height: i32,
        ),
    >,
    pub subtract: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            x: i32,
            y: i32,
            width: i32,
            height: i32,
        ),
    >,
}
#[test]
fn bindgen_test_layout_wl_region_interface() {
    assert_eq!(
        ::std::mem::size_of::<wl_region_interface>(),
        24usize,
        concat!("Size of: ", stringify!(wl_region_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_region_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(wl_region_interface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_region_interface>())).destroy as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_region_interface),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_region_interface>())).add as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_region_interface),
            "::",
            stringify!(add)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_region_interface>())).subtract as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_region_interface),
            "::",
            stringify!(subtract)
        )
    );
}
pub mod wl_subcompositor_error {
    pub type Type = u32;
    pub const WL_SUBCOMPOSITOR_ERROR_BAD_SURFACE: Type = 0;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_subcompositor_interface {
    pub destroy: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
    pub get_subsurface: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            id: u32,
            surface: *mut wl_resource,
            parent: *mut wl_resource,
        ),
    >,
}
#[test]
fn bindgen_test_layout_wl_subcompositor_interface() {
    assert_eq!(
        ::std::mem::size_of::<wl_subcompositor_interface>(),
        16usize,
        concat!("Size of: ", stringify!(wl_subcompositor_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_subcompositor_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(wl_subcompositor_interface))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_subcompositor_interface>())).destroy as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_subcompositor_interface),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_subcompositor_interface>())).get_subsurface as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_subcompositor_interface),
            "::",
            stringify!(get_subsurface)
        )
    );
}
pub mod wl_subsurface_error {
    pub type Type = u32;
    pub const WL_SUBSURFACE_ERROR_BAD_SURFACE: Type = 0;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_subsurface_interface {
    pub destroy: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
    pub set_position: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource, x: i32, y: i32),
    >,
    pub place_above: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            sibling: *mut wl_resource,
        ),
    >,
    pub place_below: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            sibling: *mut wl_resource,
        ),
    >,
    pub set_sync: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
    pub set_desync: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
}
#[test]
fn bindgen_test_layout_wl_subsurface_interface() {
    assert_eq!(
        ::std::mem::size_of::<wl_subsurface_interface>(),
        48usize,
        concat!("Size of: ", stringify!(wl_subsurface_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_subsurface_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(wl_subsurface_interface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_subsurface_interface>())).destroy as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_subsurface_interface),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_subsurface_interface>())).set_position as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_subsurface_interface),
            "::",
            stringify!(set_position)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_subsurface_interface>())).place_above as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_subsurface_interface),
            "::",
            stringify!(place_above)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_subsurface_interface>())).place_below as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_subsurface_interface),
            "::",
            stringify!(place_below)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_subsurface_interface>())).set_sync as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_subsurface_interface),
            "::",
            stringify!(set_sync)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_subsurface_interface>())).set_desync as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_subsurface_interface),
            "::",
            stringify!(set_desync)
        )
    );
}
extern "C" {
    pub fn gnu_dev_major(__dev: __dev_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_minor(__dev: __dev_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_makedev(
        __major: ::std::os::raw::c_uint,
        __minor: ::std::os::raw::c_uint,
    ) -> __dev_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct udev {
    _unused: [u8; 0],
}
extern "C" {
    pub fn udev_ref(udev: *mut udev) -> *mut udev;
}
extern "C" {
    pub fn udev_unref(udev: *mut udev) -> *mut udev;
}
extern "C" {
    pub fn udev_new() -> *mut udev;
}
extern "C" {
    pub fn udev_set_log_fn(
        udev: *mut udev,
        log_fn: ::std::option::Option<
            unsafe extern "C" fn(
                udev: *mut udev,
                priority: ::std::os::raw::c_int,
                file: *const ::std::os::raw::c_char,
                line: ::std::os::raw::c_int,
                fn_: *const ::std::os::raw::c_char,
                format: *const ::std::os::raw::c_char,
                args: *mut __va_list_tag,
            ),
        >,
    );
}
extern "C" {
    pub fn udev_get_log_priority(udev: *mut udev) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn udev_set_log_priority(udev: *mut udev, priority: ::std::os::raw::c_int);
}
extern "C" {
    pub fn udev_get_userdata(udev: *mut udev) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn udev_set_userdata(udev: *mut udev, userdata: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct udev_list_entry {
    _unused: [u8; 0],
}
extern "C" {
    pub fn udev_list_entry_get_next(list_entry: *mut udev_list_entry) -> *mut udev_list_entry;
}
extern "C" {
    pub fn udev_list_entry_get_by_name(
        list_entry: *mut udev_list_entry,
        name: *const ::std::os::raw::c_char,
    ) -> *mut udev_list_entry;
}
extern "C" {
    pub fn udev_list_entry_get_name(
        list_entry: *mut udev_list_entry,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn udev_list_entry_get_value(
        list_entry: *mut udev_list_entry,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct udev_device {
    _unused: [u8; 0],
}
extern "C" {
    pub fn udev_device_ref(udev_device: *mut udev_device) -> *mut udev_device;
}
extern "C" {
    pub fn udev_device_unref(udev_device: *mut udev_device) -> *mut udev_device;
}
extern "C" {
    pub fn udev_device_get_udev(udev_device: *mut udev_device) -> *mut udev;
}
extern "C" {
    pub fn udev_device_new_from_syspath(
        udev: *mut udev,
        syspath: *const ::std::os::raw::c_char,
    ) -> *mut udev_device;
}
extern "C" {
    pub fn udev_device_new_from_devnum(
        udev: *mut udev,
        type_: ::std::os::raw::c_char,
        devnum: dev_t,
    ) -> *mut udev_device;
}
extern "C" {
    pub fn udev_device_new_from_subsystem_sysname(
        udev: *mut udev,
        subsystem: *const ::std::os::raw::c_char,
        sysname: *const ::std::os::raw::c_char,
    ) -> *mut udev_device;
}
extern "C" {
    pub fn udev_device_new_from_device_id(
        udev: *mut udev,
        id: *const ::std::os::raw::c_char,
    ) -> *mut udev_device;
}
extern "C" {
    pub fn udev_device_new_from_environment(udev: *mut udev) -> *mut udev_device;
}
extern "C" {
    pub fn udev_device_get_parent(udev_device: *mut udev_device) -> *mut udev_device;
}
extern "C" {
    pub fn udev_device_get_parent_with_subsystem_devtype(
        udev_device: *mut udev_device,
        subsystem: *const ::std::os::raw::c_char,
        devtype: *const ::std::os::raw::c_char,
    ) -> *mut udev_device;
}
extern "C" {
    pub fn udev_device_get_devpath(udev_device: *mut udev_device) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn udev_device_get_subsystem(
        udev_device: *mut udev_device,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn udev_device_get_devtype(udev_device: *mut udev_device) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn udev_device_get_syspath(udev_device: *mut udev_device) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn udev_device_get_sysname(udev_device: *mut udev_device) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn udev_device_get_sysnum(udev_device: *mut udev_device) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn udev_device_get_devnode(udev_device: *mut udev_device) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn udev_device_get_is_initialized(udev_device: *mut udev_device) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn udev_device_get_devlinks_list_entry(
        udev_device: *mut udev_device,
    ) -> *mut udev_list_entry;
}
extern "C" {
    pub fn udev_device_get_properties_list_entry(
        udev_device: *mut udev_device,
    ) -> *mut udev_list_entry;
}
extern "C" {
    pub fn udev_device_get_tags_list_entry(udev_device: *mut udev_device) -> *mut udev_list_entry;
}
extern "C" {
    pub fn udev_device_get_sysattr_list_entry(
        udev_device: *mut udev_device,
    ) -> *mut udev_list_entry;
}
extern "C" {
    pub fn udev_device_get_property_value(
        udev_device: *mut udev_device,
        key: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn udev_device_get_driver(udev_device: *mut udev_device) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn udev_device_get_devnum(udev_device: *mut udev_device) -> dev_t;
}
extern "C" {
    pub fn udev_device_get_action(udev_device: *mut udev_device) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn udev_device_get_seqnum(udev_device: *mut udev_device) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn udev_device_get_usec_since_initialized(
        udev_device: *mut udev_device,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn udev_device_get_sysattr_value(
        udev_device: *mut udev_device,
        sysattr: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn udev_device_set_sysattr_value(
        udev_device: *mut udev_device,
        sysattr: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn udev_device_has_tag(
        udev_device: *mut udev_device,
        tag: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct udev_monitor {
    _unused: [u8; 0],
}
extern "C" {
    pub fn udev_monitor_ref(udev_monitor: *mut udev_monitor) -> *mut udev_monitor;
}
extern "C" {
    pub fn udev_monitor_unref(udev_monitor: *mut udev_monitor) -> *mut udev_monitor;
}
extern "C" {
    pub fn udev_monitor_get_udev(udev_monitor: *mut udev_monitor) -> *mut udev;
}
extern "C" {
    pub fn udev_monitor_new_from_netlink(
        udev: *mut udev,
        name: *const ::std::os::raw::c_char,
    ) -> *mut udev_monitor;
}
extern "C" {
    pub fn udev_monitor_enable_receiving(udev_monitor: *mut udev_monitor) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn udev_monitor_set_receive_buffer_size(
        udev_monitor: *mut udev_monitor,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn udev_monitor_get_fd(udev_monitor: *mut udev_monitor) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn udev_monitor_receive_device(udev_monitor: *mut udev_monitor) -> *mut udev_device;
}
extern "C" {
    pub fn udev_monitor_filter_add_match_subsystem_devtype(
        udev_monitor: *mut udev_monitor,
        subsystem: *const ::std::os::raw::c_char,
        devtype: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn udev_monitor_filter_add_match_tag(
        udev_monitor: *mut udev_monitor,
        tag: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn udev_monitor_filter_update(udev_monitor: *mut udev_monitor) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn udev_monitor_filter_remove(udev_monitor: *mut udev_monitor) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct udev_enumerate {
    _unused: [u8; 0],
}
extern "C" {
    pub fn udev_enumerate_ref(udev_enumerate: *mut udev_enumerate) -> *mut udev_enumerate;
}
extern "C" {
    pub fn udev_enumerate_unref(udev_enumerate: *mut udev_enumerate) -> *mut udev_enumerate;
}
extern "C" {
    pub fn udev_enumerate_get_udev(udev_enumerate: *mut udev_enumerate) -> *mut udev;
}
extern "C" {
    pub fn udev_enumerate_new(udev: *mut udev) -> *mut udev_enumerate;
}
extern "C" {
    pub fn udev_enumerate_add_match_subsystem(
        udev_enumerate: *mut udev_enumerate,
        subsystem: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn udev_enumerate_add_nomatch_subsystem(
        udev_enumerate: *mut udev_enumerate,
        subsystem: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn udev_enumerate_add_match_sysattr(
        udev_enumerate: *mut udev_enumerate,
        sysattr: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn udev_enumerate_add_nomatch_sysattr(
        udev_enumerate: *mut udev_enumerate,
        sysattr: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn udev_enumerate_add_match_property(
        udev_enumerate: *mut udev_enumerate,
        property: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn udev_enumerate_add_match_sysname(
        udev_enumerate: *mut udev_enumerate,
        sysname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn udev_enumerate_add_match_tag(
        udev_enumerate: *mut udev_enumerate,
        tag: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn udev_enumerate_add_match_parent(
        udev_enumerate: *mut udev_enumerate,
        parent: *mut udev_device,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn udev_enumerate_add_match_is_initialized(
        udev_enumerate: *mut udev_enumerate,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn udev_enumerate_add_syspath(
        udev_enumerate: *mut udev_enumerate,
        syspath: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn udev_enumerate_scan_devices(
        udev_enumerate: *mut udev_enumerate,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn udev_enumerate_scan_subsystems(
        udev_enumerate: *mut udev_enumerate,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn udev_enumerate_get_list_entry(
        udev_enumerate: *mut udev_enumerate,
    ) -> *mut udev_list_entry;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct udev_queue {
    _unused: [u8; 0],
}
extern "C" {
    pub fn udev_queue_ref(udev_queue: *mut udev_queue) -> *mut udev_queue;
}
extern "C" {
    pub fn udev_queue_unref(udev_queue: *mut udev_queue) -> *mut udev_queue;
}
extern "C" {
    pub fn udev_queue_get_udev(udev_queue: *mut udev_queue) -> *mut udev;
}
extern "C" {
    pub fn udev_queue_new(udev: *mut udev) -> *mut udev_queue;
}
extern "C" {
    pub fn udev_queue_get_kernel_seqnum(udev_queue: *mut udev_queue)
        -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn udev_queue_get_udev_seqnum(udev_queue: *mut udev_queue) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn udev_queue_get_udev_is_active(udev_queue: *mut udev_queue) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn udev_queue_get_queue_is_empty(udev_queue: *mut udev_queue) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn udev_queue_get_seqnum_is_finished(
        udev_queue: *mut udev_queue,
        seqnum: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn udev_queue_get_seqnum_sequence_is_finished(
        udev_queue: *mut udev_queue,
        start: ::std::os::raw::c_ulonglong,
        end: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn udev_queue_get_fd(udev_queue: *mut udev_queue) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn udev_queue_flush(udev_queue: *mut udev_queue) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn udev_queue_get_queued_list_entry(udev_queue: *mut udev_queue) -> *mut udev_list_entry;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct udev_hwdb {
    _unused: [u8; 0],
}
extern "C" {
    pub fn udev_hwdb_new(udev: *mut udev) -> *mut udev_hwdb;
}
extern "C" {
    pub fn udev_hwdb_ref(hwdb: *mut udev_hwdb) -> *mut udev_hwdb;
}
extern "C" {
    pub fn udev_hwdb_unref(hwdb: *mut udev_hwdb) -> *mut udev_hwdb;
}
extern "C" {
    pub fn udev_hwdb_get_properties_list_entry(
        hwdb: *mut udev_hwdb,
        modalias: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_uint,
    ) -> *mut udev_list_entry;
}
extern "C" {
    pub fn udev_util_encode_string(
        str: *const ::std::os::raw::c_char,
        str_enc: *mut ::std::os::raw::c_char,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct session_impl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_device {
    pub fd: ::std::os::raw::c_int,
    pub dev: dev_t,
    pub signal: wl_signal,
    pub link: wl_list,
}
#[test]
fn bindgen_test_layout_wlr_device() {
    assert_eq!(
        ::std::mem::size_of::<wlr_device>(),
        48usize,
        concat!("Size of: ", stringify!(wlr_device))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_device>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_device))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_device>())).fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_device),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_device>())).dev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_device),
            "::",
            stringify!(dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_device>())).signal as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_device),
            "::",
            stringify!(signal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_device>())).link as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_device),
            "::",
            stringify!(link)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wlr_session {
    pub impl_: *const session_impl,
    pub session_signal: wl_signal,
    pub active: bool,
    pub vtnr: ::std::os::raw::c_uint,
    pub seat: [::std::os::raw::c_char; 256usize],
    pub udev: *mut udev,
    pub mon: *mut udev_monitor,
    pub udev_event: *mut wl_event_source,
    pub devices: wl_list,
    pub display_destroy: wl_listener,
    pub events: wlr_session__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_session__bindgen_ty_1 {
    pub destroy: wl_signal,
}
#[test]
fn bindgen_test_layout_wlr_session__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wlr_session__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(wlr_session__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_session__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_session__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_session__bindgen_ty_1>())).destroy as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_session__bindgen_ty_1),
            "::",
            stringify!(destroy)
        )
    );
}
#[test]
fn bindgen_test_layout_wlr_session() {
    assert_eq!(
        ::std::mem::size_of::<wlr_session>(),
        368usize,
        concat!("Size of: ", stringify!(wlr_session))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_session>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_session))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_session>())).impl_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_session),
            "::",
            stringify!(impl_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_session>())).session_signal as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_session),
            "::",
            stringify!(session_signal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_session>())).active as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_session),
            "::",
            stringify!(active)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_session>())).vtnr as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_session),
            "::",
            stringify!(vtnr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_session>())).seat as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_session),
            "::",
            stringify!(seat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_session>())).udev as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_session),
            "::",
            stringify!(udev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_session>())).mon as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_session),
            "::",
            stringify!(mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_session>())).udev_event as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_session),
            "::",
            stringify!(udev_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_session>())).devices as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_session),
            "::",
            stringify!(devices)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_session>())).display_destroy as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_session),
            "::",
            stringify!(display_destroy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_session>())).events as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_session),
            "::",
            stringify!(events)
        )
    );
}
extern "C" {
    pub fn wlr_session_create(disp: *mut wl_display) -> *mut wlr_session;
}
extern "C" {
    pub fn wlr_session_destroy(session: *mut wlr_session);
}
extern "C" {
    pub fn wlr_session_open_file(
        session: *mut wlr_session,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wlr_session_close_file(session: *mut wlr_session, fd: ::std::os::raw::c_int);
}
extern "C" {
    pub fn wlr_session_signal_add(
        session: *mut wlr_session,
        fd: ::std::os::raw::c_int,
        listener: *mut wl_listener,
    );
}
extern "C" {
    pub fn wlr_session_change_vt(session: *mut wlr_session, vt: ::std::os::raw::c_uint) -> bool;
}
extern "C" {
    pub fn wlr_session_find_gpus(
        session: *mut wlr_session,
        ret_len: usize,
        ret: *mut ::std::os::raw::c_int,
    ) -> usize;
}
pub type khronos_int32_t = i32;
pub type khronos_uint32_t = u32;
pub type khronos_int64_t = i64;
pub type khronos_uint64_t = u64;
pub type khronos_int8_t = ::std::os::raw::c_schar;
pub type khronos_uint8_t = ::std::os::raw::c_uchar;
pub type khronos_int16_t = ::std::os::raw::c_short;
pub type khronos_uint16_t = ::std::os::raw::c_ushort;
pub type khronos_intptr_t = ::std::os::raw::c_long;
pub type khronos_uintptr_t = ::std::os::raw::c_ulong;
pub type khronos_ssize_t = ::std::os::raw::c_long;
pub type khronos_usize_t = ::std::os::raw::c_ulong;
pub type khronos_float_t = f32;
pub type khronos_utime_nanoseconds_t = khronos_uint64_t;
pub type khronos_stime_nanoseconds_t = khronos_int64_t;
pub mod khronos_boolean_enum_t {
    pub type Type = u32;
    pub const KHRONOS_FALSE: Type = 0;
    pub const KHRONOS_TRUE: Type = 1;
    pub const KHRONOS_BOOLEAN_ENUM_FORCE_SIZE: Type = 2147483647;
}
pub type EGLNativeDisplayType = *mut ::std::os::raw::c_void;
pub type EGLNativePixmapType = khronos_uintptr_t;
pub type EGLNativeWindowType = khronos_uintptr_t;
pub type NativeDisplayType = EGLNativeDisplayType;
pub type NativePixmapType = EGLNativePixmapType;
pub type NativeWindowType = EGLNativeWindowType;
pub type EGLint = khronos_int32_t;
pub type EGLBoolean = ::std::os::raw::c_uint;
pub type EGLDisplay = *mut ::std::os::raw::c_void;
pub type EGLConfig = *mut ::std::os::raw::c_void;
pub type EGLSurface = *mut ::std::os::raw::c_void;
pub type EGLContext = *mut ::std::os::raw::c_void;
pub type __eglMustCastToProperFunctionPointerType = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub fn eglChooseConfig(
        dpy: EGLDisplay,
        attrib_list: *const EGLint,
        configs: *mut EGLConfig,
        config_size: EGLint,
        num_config: *mut EGLint,
    ) -> EGLBoolean;
}
extern "C" {
    pub fn eglCopyBuffers(
        dpy: EGLDisplay,
        surface: EGLSurface,
        target: EGLNativePixmapType,
    ) -> EGLBoolean;
}
extern "C" {
    pub fn eglCreateContext(
        dpy: EGLDisplay,
        config: EGLConfig,
        share_context: EGLContext,
        attrib_list: *const EGLint,
    ) -> EGLContext;
}
extern "C" {
    pub fn eglCreatePbufferSurface(
        dpy: EGLDisplay,
        config: EGLConfig,
        attrib_list: *const EGLint,
    ) -> EGLSurface;
}
extern "C" {
    pub fn eglCreatePixmapSurface(
        dpy: EGLDisplay,
        config: EGLConfig,
        pixmap: EGLNativePixmapType,
        attrib_list: *const EGLint,
    ) -> EGLSurface;
}
extern "C" {
    pub fn eglCreateWindowSurface(
        dpy: EGLDisplay,
        config: EGLConfig,
        win: EGLNativeWindowType,
        attrib_list: *const EGLint,
    ) -> EGLSurface;
}
extern "C" {
    pub fn eglDestroyContext(dpy: EGLDisplay, ctx: EGLContext) -> EGLBoolean;
}
extern "C" {
    pub fn eglDestroySurface(dpy: EGLDisplay, surface: EGLSurface) -> EGLBoolean;
}
extern "C" {
    pub fn eglGetConfigAttrib(
        dpy: EGLDisplay,
        config: EGLConfig,
        attribute: EGLint,
        value: *mut EGLint,
    ) -> EGLBoolean;
}
extern "C" {
    pub fn eglGetConfigs(
        dpy: EGLDisplay,
        configs: *mut EGLConfig,
        config_size: EGLint,
        num_config: *mut EGLint,
    ) -> EGLBoolean;
}
extern "C" {
    pub fn eglGetCurrentDisplay() -> EGLDisplay;
}
extern "C" {
    pub fn eglGetCurrentSurface(readdraw: EGLint) -> EGLSurface;
}
extern "C" {
    pub fn eglGetDisplay(display_id: EGLNativeDisplayType) -> EGLDisplay;
}
extern "C" {
    pub fn eglGetError() -> EGLint;
}
extern "C" {
    pub fn eglGetProcAddress(
        procname: *const ::std::os::raw::c_char,
    ) -> __eglMustCastToProperFunctionPointerType;
}
extern "C" {
    pub fn eglInitialize(dpy: EGLDisplay, major: *mut EGLint, minor: *mut EGLint) -> EGLBoolean;
}
extern "C" {
    pub fn eglMakeCurrent(
        dpy: EGLDisplay,
        draw: EGLSurface,
        read: EGLSurface,
        ctx: EGLContext,
    ) -> EGLBoolean;
}
extern "C" {
    pub fn eglQueryContext(
        dpy: EGLDisplay,
        ctx: EGLContext,
        attribute: EGLint,
        value: *mut EGLint,
    ) -> EGLBoolean;
}
extern "C" {
    pub fn eglQueryString(dpy: EGLDisplay, name: EGLint) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn eglQuerySurface(
        dpy: EGLDisplay,
        surface: EGLSurface,
        attribute: EGLint,
        value: *mut EGLint,
    ) -> EGLBoolean;
}
extern "C" {
    pub fn eglSwapBuffers(dpy: EGLDisplay, surface: EGLSurface) -> EGLBoolean;
}
extern "C" {
    pub fn eglTerminate(dpy: EGLDisplay) -> EGLBoolean;
}
extern "C" {
    pub fn eglWaitGL() -> EGLBoolean;
}
extern "C" {
    pub fn eglWaitNative(engine: EGLint) -> EGLBoolean;
}
extern "C" {
    pub fn eglBindTexImage(dpy: EGLDisplay, surface: EGLSurface, buffer: EGLint) -> EGLBoolean;
}
extern "C" {
    pub fn eglReleaseTexImage(dpy: EGLDisplay, surface: EGLSurface, buffer: EGLint) -> EGLBoolean;
}
extern "C" {
    pub fn eglSurfaceAttrib(
        dpy: EGLDisplay,
        surface: EGLSurface,
        attribute: EGLint,
        value: EGLint,
    ) -> EGLBoolean;
}
extern "C" {
    pub fn eglSwapInterval(dpy: EGLDisplay, interval: EGLint) -> EGLBoolean;
}
pub type EGLenum = ::std::os::raw::c_uint;
pub type EGLClientBuffer = *mut ::std::os::raw::c_void;
extern "C" {
    pub fn eglBindAPI(api: EGLenum) -> EGLBoolean;
}
extern "C" {
    pub fn eglQueryAPI() -> EGLenum;
}
extern "C" {
    pub fn eglCreatePbufferFromClientBuffer(
        dpy: EGLDisplay,
        buftype: EGLenum,
        buffer: EGLClientBuffer,
        config: EGLConfig,
        attrib_list: *const EGLint,
    ) -> EGLSurface;
}
extern "C" {
    pub fn eglReleaseThread() -> EGLBoolean;
}
extern "C" {
    pub fn eglWaitClient() -> EGLBoolean;
}
extern "C" {
    pub fn eglGetCurrentContext() -> EGLContext;
}
pub type EGLSync = *mut ::std::os::raw::c_void;
pub type EGLAttrib = isize;
pub type EGLTime = khronos_utime_nanoseconds_t;
pub type EGLImage = *mut ::std::os::raw::c_void;
extern "C" {
    pub fn eglCreateSync(dpy: EGLDisplay, type_: EGLenum, attrib_list: *const EGLAttrib)
        -> EGLSync;
}
extern "C" {
    pub fn eglDestroySync(dpy: EGLDisplay, sync: EGLSync) -> EGLBoolean;
}
extern "C" {
    pub fn eglClientWaitSync(
        dpy: EGLDisplay,
        sync: EGLSync,
        flags: EGLint,
        timeout: EGLTime,
    ) -> EGLint;
}
extern "C" {
    pub fn eglGetSyncAttrib(
        dpy: EGLDisplay,
        sync: EGLSync,
        attribute: EGLint,
        value: *mut EGLAttrib,
    ) -> EGLBoolean;
}
extern "C" {
    pub fn eglCreateImage(
        dpy: EGLDisplay,
        ctx: EGLContext,
        target: EGLenum,
        buffer: EGLClientBuffer,
        attrib_list: *const EGLAttrib,
    ) -> EGLImage;
}
extern "C" {
    pub fn eglDestroyImage(dpy: EGLDisplay, image: EGLImage) -> EGLBoolean;
}
extern "C" {
    pub fn eglGetPlatformDisplay(
        platform: EGLenum,
        native_display: *mut ::std::os::raw::c_void,
        attrib_list: *const EGLAttrib,
    ) -> EGLDisplay;
}
extern "C" {
    pub fn eglCreatePlatformWindowSurface(
        dpy: EGLDisplay,
        config: EGLConfig,
        native_window: *mut ::std::os::raw::c_void,
        attrib_list: *const EGLAttrib,
    ) -> EGLSurface;
}
extern "C" {
    pub fn eglCreatePlatformPixmapSurface(
        dpy: EGLDisplay,
        config: EGLConfig,
        native_pixmap: *mut ::std::os::raw::c_void,
        attrib_list: *const EGLAttrib,
    ) -> EGLSurface;
}
extern "C" {
    pub fn eglWaitSync(dpy: EGLDisplay, sync: EGLSync, flags: EGLint) -> EGLBoolean;
}
pub type EGLSyncKHR = *mut ::std::os::raw::c_void;
pub type EGLAttribKHR = isize;
pub type PFNEGLCREATESYNC64KHRPROC = ::std::option::Option<
    unsafe extern "C" fn(
        dpy: EGLDisplay,
        type_: EGLenum,
        attrib_list: *const EGLAttribKHR,
    ) -> EGLSyncKHR,
>;
pub type EGLLabelKHR = *mut ::std::os::raw::c_void;
pub type EGLObjectKHR = *mut ::std::os::raw::c_void;
pub type EGLDEBUGPROCKHR = ::std::option::Option<
    unsafe extern "C" fn(
        error: EGLenum,
        command: *const ::std::os::raw::c_char,
        messageType: EGLint,
        threadLabel: EGLLabelKHR,
        objectLabel: EGLLabelKHR,
        message: *const ::std::os::raw::c_char,
    ),
>;
pub type PFNEGLDEBUGMESSAGECONTROLKHRPROC = ::std::option::Option<
    unsafe extern "C" fn(callback: EGLDEBUGPROCKHR, attrib_list: *const EGLAttrib) -> EGLint,
>;
pub type PFNEGLQUERYDEBUGKHRPROC = ::std::option::Option<
    unsafe extern "C" fn(attribute: EGLint, value: *mut EGLAttrib) -> EGLBoolean,
>;
pub type PFNEGLLABELOBJECTKHRPROC = ::std::option::Option<
    unsafe extern "C" fn(
        display: EGLDisplay,
        objectType: EGLenum,
        object: EGLObjectKHR,
        label: EGLLabelKHR,
    ) -> EGLint,
>;
pub type PFNEGLQUERYDISPLAYATTRIBKHRPROC = ::std::option::Option<
    unsafe extern "C" fn(dpy: EGLDisplay, name: EGLint, value: *mut EGLAttrib) -> EGLBoolean,
>;
pub type EGLTimeKHR = khronos_utime_nanoseconds_t;
pub type PFNEGLCREATESYNCKHRPROC = ::std::option::Option<
    unsafe extern "C" fn(dpy: EGLDisplay, type_: EGLenum, attrib_list: *const EGLint) -> EGLSyncKHR,
>;
pub type PFNEGLDESTROYSYNCKHRPROC =
    ::std::option::Option<unsafe extern "C" fn(dpy: EGLDisplay, sync: EGLSyncKHR) -> EGLBoolean>;
pub type PFNEGLCLIENTWAITSYNCKHRPROC = ::std::option::Option<
    unsafe extern "C" fn(
        dpy: EGLDisplay,
        sync: EGLSyncKHR,
        flags: EGLint,
        timeout: EGLTimeKHR,
    ) -> EGLint,
>;
pub type PFNEGLGETSYNCATTRIBKHRPROC = ::std::option::Option<
    unsafe extern "C" fn(
        dpy: EGLDisplay,
        sync: EGLSyncKHR,
        attribute: EGLint,
        value: *mut EGLint,
    ) -> EGLBoolean,
>;
pub type EGLImageKHR = *mut ::std::os::raw::c_void;
pub type PFNEGLCREATEIMAGEKHRPROC = ::std::option::Option<
    unsafe extern "C" fn(
        dpy: EGLDisplay,
        ctx: EGLContext,
        target: EGLenum,
        buffer: EGLClientBuffer,
        attrib_list: *const EGLint,
    ) -> EGLImageKHR,
>;
pub type PFNEGLDESTROYIMAGEKHRPROC =
    ::std::option::Option<unsafe extern "C" fn(dpy: EGLDisplay, image: EGLImageKHR) -> EGLBoolean>;
pub type PFNEGLLOCKSURFACEKHRPROC = ::std::option::Option<
    unsafe extern "C" fn(
        dpy: EGLDisplay,
        surface: EGLSurface,
        attrib_list: *const EGLint,
    ) -> EGLBoolean,
>;
pub type PFNEGLUNLOCKSURFACEKHRPROC =
    ::std::option::Option<unsafe extern "C" fn(dpy: EGLDisplay, surface: EGLSurface) -> EGLBoolean>;
pub type PFNEGLQUERYSURFACE64KHRPROC = ::std::option::Option<
    unsafe extern "C" fn(
        dpy: EGLDisplay,
        surface: EGLSurface,
        attribute: EGLint,
        value: *mut EGLAttribKHR,
    ) -> EGLBoolean,
>;
pub type PFNEGLSETDAMAGEREGIONKHRPROC = ::std::option::Option<
    unsafe extern "C" fn(
        dpy: EGLDisplay,
        surface: EGLSurface,
        rects: *mut EGLint,
        n_rects: EGLint,
    ) -> EGLBoolean,
>;
pub type PFNEGLSIGNALSYNCKHRPROC = ::std::option::Option<
    unsafe extern "C" fn(dpy: EGLDisplay, sync: EGLSyncKHR, mode: EGLenum) -> EGLBoolean,
>;
pub type EGLStreamKHR = *mut ::std::os::raw::c_void;
pub type EGLuint64KHR = khronos_uint64_t;
pub type PFNEGLCREATESTREAMKHRPROC = ::std::option::Option<
    unsafe extern "C" fn(dpy: EGLDisplay, attrib_list: *const EGLint) -> EGLStreamKHR,
>;
pub type PFNEGLDESTROYSTREAMKHRPROC = ::std::option::Option<
    unsafe extern "C" fn(dpy: EGLDisplay, stream: EGLStreamKHR) -> EGLBoolean,
>;
pub type PFNEGLSTREAMATTRIBKHRPROC = ::std::option::Option<
    unsafe extern "C" fn(
        dpy: EGLDisplay,
        stream: EGLStreamKHR,
        attribute: EGLenum,
        value: EGLint,
    ) -> EGLBoolean,
>;
pub type PFNEGLQUERYSTREAMKHRPROC = ::std::option::Option<
    unsafe extern "C" fn(
        dpy: EGLDisplay,
        stream: EGLStreamKHR,
        attribute: EGLenum,
        value: *mut EGLint,
    ) -> EGLBoolean,
>;
pub type PFNEGLQUERYSTREAMU64KHRPROC = ::std::option::Option<
    unsafe extern "C" fn(
        dpy: EGLDisplay,
        stream: EGLStreamKHR,
        attribute: EGLenum,
        value: *mut EGLuint64KHR,
    ) -> EGLBoolean,
>;
pub type PFNEGLCREATESTREAMATTRIBKHRPROC = ::std::option::Option<
    unsafe extern "C" fn(dpy: EGLDisplay, attrib_list: *const EGLAttrib) -> EGLStreamKHR,
>;
pub type PFNEGLSETSTREAMATTRIBKHRPROC = ::std::option::Option<
    unsafe extern "C" fn(
        dpy: EGLDisplay,
        stream: EGLStreamKHR,
        attribute: EGLenum,
        value: EGLAttrib,
    ) -> EGLBoolean,
>;
pub type PFNEGLQUERYSTREAMATTRIBKHRPROC = ::std::option::Option<
    unsafe extern "C" fn(
        dpy: EGLDisplay,
        stream: EGLStreamKHR,
        attribute: EGLenum,
        value: *mut EGLAttrib,
    ) -> EGLBoolean,
>;
pub type PFNEGLSTREAMCONSUMERACQUIREATTRIBKHRPROC = ::std::option::Option<
    unsafe extern "C" fn(
        dpy: EGLDisplay,
        stream: EGLStreamKHR,
        attrib_list: *const EGLAttrib,
    ) -> EGLBoolean,
>;
pub type PFNEGLSTREAMCONSUMERRELEASEATTRIBKHRPROC = ::std::option::Option<
    unsafe extern "C" fn(
        dpy: EGLDisplay,
        stream: EGLStreamKHR,
        attrib_list: *const EGLAttrib,
    ) -> EGLBoolean,
>;
pub type PFNEGLSTREAMCONSUMERGLTEXTUREEXTERNALKHRPROC = ::std::option::Option<
    unsafe extern "C" fn(dpy: EGLDisplay, stream: EGLStreamKHR) -> EGLBoolean,
>;
pub type PFNEGLSTREAMCONSUMERACQUIREKHRPROC = ::std::option::Option<
    unsafe extern "C" fn(dpy: EGLDisplay, stream: EGLStreamKHR) -> EGLBoolean,
>;
pub type PFNEGLSTREAMCONSUMERRELEASEKHRPROC = ::std::option::Option<
    unsafe extern "C" fn(dpy: EGLDisplay, stream: EGLStreamKHR) -> EGLBoolean,
>;
pub type EGLNativeFileDescriptorKHR = ::std::os::raw::c_int;
pub type PFNEGLGETSTREAMFILEDESCRIPTORKHRPROC = ::std::option::Option<
    unsafe extern "C" fn(dpy: EGLDisplay, stream: EGLStreamKHR) -> EGLNativeFileDescriptorKHR,
>;
pub type PFNEGLCREATESTREAMFROMFILEDESCRIPTORKHRPROC = ::std::option::Option<
    unsafe extern "C" fn(
        dpy: EGLDisplay,
        file_descriptor: EGLNativeFileDescriptorKHR,
    ) -> EGLStreamKHR,
>;
pub type PFNEGLQUERYSTREAMTIMEKHRPROC = ::std::option::Option<
    unsafe extern "C" fn(
        dpy: EGLDisplay,
        stream: EGLStreamKHR,
        attribute: EGLenum,
        value: *mut EGLTimeKHR,
    ) -> EGLBoolean,
>;
pub type PFNEGLCREATESTREAMPRODUCERSURFACEKHRPROC = ::std::option::Option<
    unsafe extern "C" fn(
        dpy: EGLDisplay,
        config: EGLConfig,
        stream: EGLStreamKHR,
        attrib_list: *const EGLint,
    ) -> EGLSurface,
>;
pub type PFNEGLSWAPBUFFERSWITHDAMAGEKHRPROC = ::std::option::Option<
    unsafe extern "C" fn(
        dpy: EGLDisplay,
        surface: EGLSurface,
        rects: *mut EGLint,
        n_rects: EGLint,
    ) -> EGLBoolean,
>;
pub type PFNEGLWAITSYNCKHRPROC = ::std::option::Option<
    unsafe extern "C" fn(dpy: EGLDisplay, sync: EGLSyncKHR, flags: EGLint) -> EGLint,
>;
pub type EGLsizeiANDROID = khronos_ssize_t;
pub type EGLSetBlobFuncANDROID = ::std::option::Option<
    unsafe extern "C" fn(
        key: *const ::std::os::raw::c_void,
        keySize: EGLsizeiANDROID,
        value: *const ::std::os::raw::c_void,
        valueSize: EGLsizeiANDROID,
    ),
>;
pub type EGLGetBlobFuncANDROID = ::std::option::Option<
    unsafe extern "C" fn(
        key: *const ::std::os::raw::c_void,
        keySize: EGLsizeiANDROID,
        value: *mut ::std::os::raw::c_void,
        valueSize: EGLsizeiANDROID,
    ) -> EGLsizeiANDROID,
>;
pub type PFNEGLSETBLOBCACHEFUNCSANDROIDPROC = ::std::option::Option<
    unsafe extern "C" fn(dpy: EGLDisplay, set: EGLSetBlobFuncANDROID, get: EGLGetBlobFuncANDROID),
>;
pub type PFNEGLCREATENATIVECLIENTBUFFERANDROIDPROC =
    ::std::option::Option<unsafe extern "C" fn(attrib_list: *const EGLint) -> EGLClientBuffer>;
pub type EGLnsecsANDROID = khronos_stime_nanoseconds_t;
pub type PFNEGLGETCOMPOSITORTIMINGSUPPORTEDANDROIDPROC = ::std::option::Option<
    unsafe extern "C" fn(dpy: EGLDisplay, surface: EGLSurface, name: EGLint) -> EGLBoolean,
>;
pub type PFNEGLGETCOMPOSITORTIMINGANDROIDPROC = ::std::option::Option<
    unsafe extern "C" fn(
        dpy: EGLDisplay,
        surface: EGLSurface,
        numTimestamps: EGLint,
        names: *const EGLint,
        values: *mut EGLnsecsANDROID,
    ) -> EGLBoolean,
>;
pub type PFNEGLGETNEXTFRAMEIDANDROIDPROC = ::std::option::Option<
    unsafe extern "C" fn(
        dpy: EGLDisplay,
        surface: EGLSurface,
        frameId: *mut EGLuint64KHR,
    ) -> EGLBoolean,
>;
pub type PFNEGLGETFRAMETIMESTAMPSUPPORTEDANDROIDPROC = ::std::option::Option<
    unsafe extern "C" fn(dpy: EGLDisplay, surface: EGLSurface, timestamp: EGLint) -> EGLBoolean,
>;
pub type PFNEGLGETFRAMETIMESTAMPSANDROIDPROC = ::std::option::Option<
    unsafe extern "C" fn(
        dpy: EGLDisplay,
        surface: EGLSurface,
        frameId: EGLuint64KHR,
        numTimestamps: EGLint,
        timestamps: *const EGLint,
        values: *mut EGLnsecsANDROID,
    ) -> EGLBoolean,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AHardwareBuffer {
    _unused: [u8; 0],
}
pub type PFNEGLGETNATIVECLIENTBUFFERANDROIDPROC =
    ::std::option::Option<unsafe extern "C" fn(buffer: *const AHardwareBuffer) -> EGLClientBuffer>;
pub type PFNEGLDUPNATIVEFENCEFDANDROIDPROC =
    ::std::option::Option<unsafe extern "C" fn(dpy: EGLDisplay, sync: EGLSyncKHR) -> EGLint>;
pub type PFNEGLPRESENTATIONTIMEANDROIDPROC = ::std::option::Option<
    unsafe extern "C" fn(dpy: EGLDisplay, surface: EGLSurface, time: EGLnsecsANDROID) -> EGLBoolean,
>;
pub type PFNEGLQUERYSURFACEPOINTERANGLEPROC = ::std::option::Option<
    unsafe extern "C" fn(
        dpy: EGLDisplay,
        surface: EGLSurface,
        attribute: EGLint,
        value: *mut *mut ::std::os::raw::c_void,
    ) -> EGLBoolean,
>;
pub type PFNEGLCLIENTSIGNALSYNCEXTPROC = ::std::option::Option<
    unsafe extern "C" fn(
        dpy: EGLDisplay,
        sync: EGLSync,
        attrib_list: *const EGLAttrib,
    ) -> EGLBoolean,
>;
pub type PFNEGLCOMPOSITORSETCONTEXTLISTEXTPROC = ::std::option::Option<
    unsafe extern "C" fn(external_ref_ids: *const EGLint, num_entries: EGLint) -> EGLBoolean,
>;
pub type PFNEGLCOMPOSITORSETCONTEXTATTRIBUTESEXTPROC = ::std::option::Option<
    unsafe extern "C" fn(
        external_ref_id: EGLint,
        context_attributes: *const EGLint,
        num_entries: EGLint,
    ) -> EGLBoolean,
>;
pub type PFNEGLCOMPOSITORSETWINDOWLISTEXTPROC = ::std::option::Option<
    unsafe extern "C" fn(
        external_ref_id: EGLint,
        external_win_ids: *const EGLint,
        num_entries: EGLint,
    ) -> EGLBoolean,
>;
pub type PFNEGLCOMPOSITORSETWINDOWATTRIBUTESEXTPROC = ::std::option::Option<
    unsafe extern "C" fn(
        external_win_id: EGLint,
        window_attributes: *const EGLint,
        num_entries: EGLint,
    ) -> EGLBoolean,
>;
pub type PFNEGLCOMPOSITORBINDTEXWINDOWEXTPROC =
    ::std::option::Option<unsafe extern "C" fn(external_win_id: EGLint) -> EGLBoolean>;
pub type PFNEGLCOMPOSITORSETSIZEEXTPROC = ::std::option::Option<
    unsafe extern "C" fn(external_win_id: EGLint, width: EGLint, height: EGLint) -> EGLBoolean,
>;
pub type PFNEGLCOMPOSITORSWAPPOLICYEXTPROC = ::std::option::Option<
    unsafe extern "C" fn(external_win_id: EGLint, policy: EGLint) -> EGLBoolean,
>;
pub type EGLDeviceEXT = *mut ::std::os::raw::c_void;
pub type PFNEGLQUERYDEVICEATTRIBEXTPROC = ::std::option::Option<
    unsafe extern "C" fn(
        device: EGLDeviceEXT,
        attribute: EGLint,
        value: *mut EGLAttrib,
    ) -> EGLBoolean,
>;
pub type PFNEGLQUERYDEVICESTRINGEXTPROC = ::std::option::Option<
    unsafe extern "C" fn(device: EGLDeviceEXT, name: EGLint) -> *const ::std::os::raw::c_char,
>;
pub type PFNEGLQUERYDEVICESEXTPROC = ::std::option::Option<
    unsafe extern "C" fn(
        max_devices: EGLint,
        devices: *mut EGLDeviceEXT,
        num_devices: *mut EGLint,
    ) -> EGLBoolean,
>;
pub type PFNEGLQUERYDISPLAYATTRIBEXTPROC = ::std::option::Option<
    unsafe extern "C" fn(dpy: EGLDisplay, attribute: EGLint, value: *mut EGLAttrib) -> EGLBoolean,
>;
pub type PFNEGLQUERYDMABUFFORMATSEXTPROC = ::std::option::Option<
    unsafe extern "C" fn(
        dpy: EGLDisplay,
        max_formats: EGLint,
        formats: *mut EGLint,
        num_formats: *mut EGLint,
    ) -> EGLBoolean,
>;
pub type PFNEGLQUERYDMABUFMODIFIERSEXTPROC = ::std::option::Option<
    unsafe extern "C" fn(
        dpy: EGLDisplay,
        format: EGLint,
        max_modifiers: EGLint,
        modifiers: *mut EGLuint64KHR,
        external_only: *mut EGLBoolean,
        num_modifiers: *mut EGLint,
    ) -> EGLBoolean,
>;
pub type EGLOutputLayerEXT = *mut ::std::os::raw::c_void;
pub type EGLOutputPortEXT = *mut ::std::os::raw::c_void;
pub type PFNEGLGETOUTPUTLAYERSEXTPROC = ::std::option::Option<
    unsafe extern "C" fn(
        dpy: EGLDisplay,
        attrib_list: *const EGLAttrib,
        layers: *mut EGLOutputLayerEXT,
        max_layers: EGLint,
        num_layers: *mut EGLint,
    ) -> EGLBoolean,
>;
pub type PFNEGLGETOUTPUTPORTSEXTPROC = ::std::option::Option<
    unsafe extern "C" fn(
        dpy: EGLDisplay,
        attrib_list: *const EGLAttrib,
        ports: *mut EGLOutputPortEXT,
        max_ports: EGLint,
        num_ports: *mut EGLint,
    ) -> EGLBoolean,
>;
pub type PFNEGLOUTPUTLAYERATTRIBEXTPROC = ::std::option::Option<
    unsafe extern "C" fn(
        dpy: EGLDisplay,
        layer: EGLOutputLayerEXT,
        attribute: EGLint,
        value: EGLAttrib,
    ) -> EGLBoolean,
>;
pub type PFNEGLQUERYOUTPUTLAYERATTRIBEXTPROC = ::std::option::Option<
    unsafe extern "C" fn(
        dpy: EGLDisplay,
        layer: EGLOutputLayerEXT,
        attribute: EGLint,
        value: *mut EGLAttrib,
    ) -> EGLBoolean,
>;
pub type PFNEGLQUERYOUTPUTLAYERSTRINGEXTPROC = ::std::option::Option<
    unsafe extern "C" fn(
        dpy: EGLDisplay,
        layer: EGLOutputLayerEXT,
        name: EGLint,
    ) -> *const ::std::os::raw::c_char,
>;
pub type PFNEGLOUTPUTPORTATTRIBEXTPROC = ::std::option::Option<
    unsafe extern "C" fn(
        dpy: EGLDisplay,
        port: EGLOutputPortEXT,
        attribute: EGLint,
        value: EGLAttrib,
    ) -> EGLBoolean,
>;
pub type PFNEGLQUERYOUTPUTPORTATTRIBEXTPROC = ::std::option::Option<
    unsafe extern "C" fn(
        dpy: EGLDisplay,
        port: EGLOutputPortEXT,
        attribute: EGLint,
        value: *mut EGLAttrib,
    ) -> EGLBoolean,
>;
pub type PFNEGLQUERYOUTPUTPORTSTRINGEXTPROC = ::std::option::Option<
    unsafe extern "C" fn(
        dpy: EGLDisplay,
        port: EGLOutputPortEXT,
        name: EGLint,
    ) -> *const ::std::os::raw::c_char,
>;
pub type PFNEGLGETPLATFORMDISPLAYEXTPROC = ::std::option::Option<
    unsafe extern "C" fn(
        platform: EGLenum,
        native_display: *mut ::std::os::raw::c_void,
        attrib_list: *const EGLint,
    ) -> EGLDisplay,
>;
pub type PFNEGLCREATEPLATFORMWINDOWSURFACEEXTPROC = ::std::option::Option<
    unsafe extern "C" fn(
        dpy: EGLDisplay,
        config: EGLConfig,
        native_window: *mut ::std::os::raw::c_void,
        attrib_list: *const EGLint,
    ) -> EGLSurface,
>;
pub type PFNEGLCREATEPLATFORMPIXMAPSURFACEEXTPROC = ::std::option::Option<
    unsafe extern "C" fn(
        dpy: EGLDisplay,
        config: EGLConfig,
        native_pixmap: *mut ::std::os::raw::c_void,
        attrib_list: *const EGLint,
    ) -> EGLSurface,
>;
pub type PFNEGLSTREAMCONSUMEROUTPUTEXTPROC = ::std::option::Option<
    unsafe extern "C" fn(
        dpy: EGLDisplay,
        stream: EGLStreamKHR,
        layer: EGLOutputLayerEXT,
    ) -> EGLBoolean,
>;
pub type PFNEGLSWAPBUFFERSWITHDAMAGEEXTPROC = ::std::option::Option<
    unsafe extern "C" fn(
        dpy: EGLDisplay,
        surface: EGLSurface,
        rects: *mut EGLint,
        n_rects: EGLint,
    ) -> EGLBoolean,
>;
pub type PFNEGLUNSIGNALSYNCEXTPROC = ::std::option::Option<
    unsafe extern "C" fn(
        dpy: EGLDisplay,
        sync: EGLSync,
        attrib_list: *const EGLAttrib,
    ) -> EGLBoolean,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EGLClientPixmapHI {
    pub pData: *mut ::std::os::raw::c_void,
    pub iWidth: EGLint,
    pub iHeight: EGLint,
    pub iStride: EGLint,
}
#[test]
fn bindgen_test_layout_EGLClientPixmapHI() {
    assert_eq!(
        ::std::mem::size_of::<EGLClientPixmapHI>(),
        24usize,
        concat!("Size of: ", stringify!(EGLClientPixmapHI))
    );
    assert_eq!(
        ::std::mem::align_of::<EGLClientPixmapHI>(),
        8usize,
        concat!("Alignment of ", stringify!(EGLClientPixmapHI))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EGLClientPixmapHI>())).pData as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EGLClientPixmapHI),
            "::",
            stringify!(pData)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EGLClientPixmapHI>())).iWidth as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EGLClientPixmapHI),
            "::",
            stringify!(iWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EGLClientPixmapHI>())).iHeight as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(EGLClientPixmapHI),
            "::",
            stringify!(iHeight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EGLClientPixmapHI>())).iStride as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(EGLClientPixmapHI),
            "::",
            stringify!(iStride)
        )
    );
}
pub type PFNEGLCREATEPIXMAPSURFACEHIPROC = ::std::option::Option<
    unsafe extern "C" fn(
        dpy: EGLDisplay,
        config: EGLConfig,
        pixmap: *mut EGLClientPixmapHI,
    ) -> EGLSurface,
>;
pub type PFNEGLCREATEDRMIMAGEMESAPROC = ::std::option::Option<
    unsafe extern "C" fn(dpy: EGLDisplay, attrib_list: *const EGLint) -> EGLImageKHR,
>;
pub type PFNEGLEXPORTDRMIMAGEMESAPROC = ::std::option::Option<
    unsafe extern "C" fn(
        dpy: EGLDisplay,
        image: EGLImageKHR,
        name: *mut EGLint,
        handle: *mut EGLint,
        stride: *mut EGLint,
    ) -> EGLBoolean,
>;
pub type PFNEGLEXPORTDMABUFIMAGEQUERYMESAPROC = ::std::option::Option<
    unsafe extern "C" fn(
        dpy: EGLDisplay,
        image: EGLImageKHR,
        fourcc: *mut ::std::os::raw::c_int,
        num_planes: *mut ::std::os::raw::c_int,
        modifiers: *mut EGLuint64KHR,
    ) -> EGLBoolean,
>;
pub type PFNEGLEXPORTDMABUFIMAGEMESAPROC = ::std::option::Option<
    unsafe extern "C" fn(
        dpy: EGLDisplay,
        image: EGLImageKHR,
        fds: *mut ::std::os::raw::c_int,
        strides: *mut EGLint,
        offsets: *mut EGLint,
    ) -> EGLBoolean,
>;
pub type PFNEGLGETDISPLAYDRIVERCONFIGPROC =
    ::std::option::Option<unsafe extern "C" fn(dpy: EGLDisplay) -> *mut ::std::os::raw::c_char>;
pub type PFNEGLGETDISPLAYDRIVERNAMEPROC =
    ::std::option::Option<unsafe extern "C" fn(dpy: EGLDisplay) -> *const ::std::os::raw::c_char>;
pub type PFNEGLSWAPBUFFERSREGIONNOKPROC = ::std::option::Option<
    unsafe extern "C" fn(
        dpy: EGLDisplay,
        surface: EGLSurface,
        numRects: EGLint,
        rects: *const EGLint,
    ) -> EGLBoolean,
>;
pub type PFNEGLSWAPBUFFERSREGION2NOKPROC = ::std::option::Option<
    unsafe extern "C" fn(
        dpy: EGLDisplay,
        surface: EGLSurface,
        numRects: EGLint,
        rects: *const EGLint,
    ) -> EGLBoolean,
>;
pub type PFNEGLQUERYNATIVEDISPLAYNVPROC = ::std::option::Option<
    unsafe extern "C" fn(dpy: EGLDisplay, display_id: *mut EGLNativeDisplayType) -> EGLBoolean,
>;
pub type PFNEGLQUERYNATIVEWINDOWNVPROC = ::std::option::Option<
    unsafe extern "C" fn(
        dpy: EGLDisplay,
        surf: EGLSurface,
        window: *mut EGLNativeWindowType,
    ) -> EGLBoolean,
>;
pub type PFNEGLQUERYNATIVEPIXMAPNVPROC = ::std::option::Option<
    unsafe extern "C" fn(
        dpy: EGLDisplay,
        surf: EGLSurface,
        pixmap: *mut EGLNativePixmapType,
    ) -> EGLBoolean,
>;
pub type PFNEGLPOSTSUBBUFFERNVPROC = ::std::option::Option<
    unsafe extern "C" fn(
        dpy: EGLDisplay,
        surface: EGLSurface,
        x: EGLint,
        y: EGLint,
        width: EGLint,
        height: EGLint,
    ) -> EGLBoolean,
>;
pub type PFNEGLSTREAMCONSUMERGLTEXTUREEXTERNALATTRIBSNVPROC = ::std::option::Option<
    unsafe extern "C" fn(
        dpy: EGLDisplay,
        stream: EGLStreamKHR,
        attrib_list: *const EGLAttrib,
    ) -> EGLBoolean,
>;
pub type PFNEGLSTREAMFLUSHNVPROC = ::std::option::Option<
    unsafe extern "C" fn(dpy: EGLDisplay, stream: EGLStreamKHR) -> EGLBoolean,
>;
pub type PFNEGLQUERYDISPLAYATTRIBNVPROC = ::std::option::Option<
    unsafe extern "C" fn(dpy: EGLDisplay, attribute: EGLint, value: *mut EGLAttrib) -> EGLBoolean,
>;
pub type PFNEGLSETSTREAMMETADATANVPROC = ::std::option::Option<
    unsafe extern "C" fn(
        dpy: EGLDisplay,
        stream: EGLStreamKHR,
        n: EGLint,
        offset: EGLint,
        size: EGLint,
        data: *const ::std::os::raw::c_void,
    ) -> EGLBoolean,
>;
pub type PFNEGLQUERYSTREAMMETADATANVPROC = ::std::option::Option<
    unsafe extern "C" fn(
        dpy: EGLDisplay,
        stream: EGLStreamKHR,
        name: EGLenum,
        n: EGLint,
        offset: EGLint,
        size: EGLint,
        data: *mut ::std::os::raw::c_void,
    ) -> EGLBoolean,
>;
pub type PFNEGLRESETSTREAMNVPROC = ::std::option::Option<
    unsafe extern "C" fn(dpy: EGLDisplay, stream: EGLStreamKHR) -> EGLBoolean,
>;
pub type PFNEGLCREATESTREAMSYNCNVPROC = ::std::option::Option<
    unsafe extern "C" fn(
        dpy: EGLDisplay,
        stream: EGLStreamKHR,
        type_: EGLenum,
        attrib_list: *const EGLint,
    ) -> EGLSyncKHR,
>;
pub type EGLSyncNV = *mut ::std::os::raw::c_void;
pub type EGLTimeNV = khronos_utime_nanoseconds_t;
pub type PFNEGLCREATEFENCESYNCNVPROC = ::std::option::Option<
    unsafe extern "C" fn(
        dpy: EGLDisplay,
        condition: EGLenum,
        attrib_list: *const EGLint,
    ) -> EGLSyncNV,
>;
pub type PFNEGLDESTROYSYNCNVPROC =
    ::std::option::Option<unsafe extern "C" fn(sync: EGLSyncNV) -> EGLBoolean>;
pub type PFNEGLFENCENVPROC =
    ::std::option::Option<unsafe extern "C" fn(sync: EGLSyncNV) -> EGLBoolean>;
pub type PFNEGLCLIENTWAITSYNCNVPROC = ::std::option::Option<
    unsafe extern "C" fn(sync: EGLSyncNV, flags: EGLint, timeout: EGLTimeNV) -> EGLint,
>;
pub type PFNEGLSIGNALSYNCNVPROC =
    ::std::option::Option<unsafe extern "C" fn(sync: EGLSyncNV, mode: EGLenum) -> EGLBoolean>;
pub type PFNEGLGETSYNCATTRIBNVPROC = ::std::option::Option<
    unsafe extern "C" fn(sync: EGLSyncNV, attribute: EGLint, value: *mut EGLint) -> EGLBoolean,
>;
pub type EGLuint64NV = khronos_utime_nanoseconds_t;
pub type PFNEGLGETSYSTEMTIMEFREQUENCYNVPROC =
    ::std::option::Option<unsafe extern "C" fn() -> EGLuint64NV>;
pub type PFNEGLGETSYSTEMTIMENVPROC = ::std::option::Option<unsafe extern "C" fn() -> EGLuint64NV>;
pub type PFNEGLBINDWAYLANDDISPLAYWL = ::std::option::Option<
    unsafe extern "C" fn(dpy: EGLDisplay, display: *mut wl_display) -> EGLBoolean,
>;
pub type PFNEGLUNBINDWAYLANDDISPLAYWL = ::std::option::Option<
    unsafe extern "C" fn(dpy: EGLDisplay, display: *mut wl_display) -> EGLBoolean,
>;
pub type PFNEGLQUERYWAYLANDBUFFERWL = ::std::option::Option<
    unsafe extern "C" fn(
        dpy: EGLDisplay,
        buffer: *mut wl_resource,
        attribute: EGLint,
        value: *mut EGLint,
    ) -> EGLBoolean,
>;
pub type PFNEGLCREATEWAYLANDBUFFERFROMIMAGEWL = ::std::option::Option<
    unsafe extern "C" fn(dpy: EGLDisplay, image: EGLImageKHR) -> *mut wl_buffer,
>;
pub type PFNEGLSWAPBUFFERSREGIONNOK = ::std::option::Option<
    unsafe extern "C" fn(
        dpy: EGLDisplay,
        surface: EGLSurface,
        numRects: EGLint,
        rects: *const EGLint,
    ) -> EGLBoolean,
>;
pub type EGLuint64CHROMIUM = khronos_uint64_t;
pub type PFNEGLGETSYNCVALUESCHROMIUMPROC = ::std::option::Option<
    unsafe extern "C" fn(
        dpy: EGLDisplay,
        surface: EGLSurface,
        ust: *mut EGLuint64CHROMIUM,
        msc: *mut EGLuint64CHROMIUM,
        sbc: *mut EGLuint64CHROMIUM,
    ) -> EGLBoolean,
>;
pub type pixman_bool_t = ::std::os::raw::c_int;
pub type pixman_fixed_32_32_t = i64;
pub type pixman_fixed_48_16_t = pixman_fixed_32_32_t;
pub type pixman_fixed_1_31_t = u32;
pub type pixman_fixed_1_16_t = u32;
pub type pixman_fixed_16_16_t = i32;
pub type pixman_fixed_t = pixman_fixed_16_16_t;
pub type pixman_color_t = pixman_color;
pub type pixman_point_fixed_t = pixman_point_fixed;
pub type pixman_line_fixed_t = pixman_line_fixed;
pub type pixman_vector_t = pixman_vector;
pub type pixman_transform_t = pixman_transform;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pixman_color {
    pub red: u16,
    pub green: u16,
    pub blue: u16,
    pub alpha: u16,
}
#[test]
fn bindgen_test_layout_pixman_color() {
    assert_eq!(
        ::std::mem::size_of::<pixman_color>(),
        8usize,
        concat!("Size of: ", stringify!(pixman_color))
    );
    assert_eq!(
        ::std::mem::align_of::<pixman_color>(),
        2usize,
        concat!("Alignment of ", stringify!(pixman_color))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_color>())).red as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_color),
            "::",
            stringify!(red)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_color>())).green as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_color),
            "::",
            stringify!(green)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_color>())).blue as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_color),
            "::",
            stringify!(blue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_color>())).alpha as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_color),
            "::",
            stringify!(alpha)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pixman_point_fixed {
    pub x: pixman_fixed_t,
    pub y: pixman_fixed_t,
}
#[test]
fn bindgen_test_layout_pixman_point_fixed() {
    assert_eq!(
        ::std::mem::size_of::<pixman_point_fixed>(),
        8usize,
        concat!("Size of: ", stringify!(pixman_point_fixed))
    );
    assert_eq!(
        ::std::mem::align_of::<pixman_point_fixed>(),
        4usize,
        concat!("Alignment of ", stringify!(pixman_point_fixed))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_point_fixed>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_point_fixed),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_point_fixed>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_point_fixed),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pixman_line_fixed {
    pub p1: pixman_point_fixed_t,
    pub p2: pixman_point_fixed_t,
}
#[test]
fn bindgen_test_layout_pixman_line_fixed() {
    assert_eq!(
        ::std::mem::size_of::<pixman_line_fixed>(),
        16usize,
        concat!("Size of: ", stringify!(pixman_line_fixed))
    );
    assert_eq!(
        ::std::mem::align_of::<pixman_line_fixed>(),
        4usize,
        concat!("Alignment of ", stringify!(pixman_line_fixed))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_line_fixed>())).p1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_line_fixed),
            "::",
            stringify!(p1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_line_fixed>())).p2 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_line_fixed),
            "::",
            stringify!(p2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pixman_vector {
    pub vector: [pixman_fixed_t; 3usize],
}
#[test]
fn bindgen_test_layout_pixman_vector() {
    assert_eq!(
        ::std::mem::size_of::<pixman_vector>(),
        12usize,
        concat!("Size of: ", stringify!(pixman_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<pixman_vector>(),
        4usize,
        concat!("Alignment of ", stringify!(pixman_vector))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_vector>())).vector as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_vector),
            "::",
            stringify!(vector)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pixman_transform {
    pub matrix: [[pixman_fixed_t; 3usize]; 3usize],
}
#[test]
fn bindgen_test_layout_pixman_transform() {
    assert_eq!(
        ::std::mem::size_of::<pixman_transform>(),
        36usize,
        concat!("Size of: ", stringify!(pixman_transform))
    );
    assert_eq!(
        ::std::mem::align_of::<pixman_transform>(),
        4usize,
        concat!("Alignment of ", stringify!(pixman_transform))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_transform>())).matrix as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_transform),
            "::",
            stringify!(matrix)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pixman_image {
    _unused: [u8; 0],
}
pub type pixman_image_t = pixman_image;
extern "C" {
    pub fn pixman_transform_init_identity(matrix: *mut pixman_transform);
}
extern "C" {
    pub fn pixman_transform_point_3d(
        transform: *const pixman_transform,
        vector: *mut pixman_vector,
    ) -> pixman_bool_t;
}
extern "C" {
    pub fn pixman_transform_point(
        transform: *const pixman_transform,
        vector: *mut pixman_vector,
    ) -> pixman_bool_t;
}
extern "C" {
    pub fn pixman_transform_multiply(
        dst: *mut pixman_transform,
        l: *const pixman_transform,
        r: *const pixman_transform,
    ) -> pixman_bool_t;
}
extern "C" {
    pub fn pixman_transform_init_scale(
        t: *mut pixman_transform,
        sx: pixman_fixed_t,
        sy: pixman_fixed_t,
    );
}
extern "C" {
    pub fn pixman_transform_scale(
        forward: *mut pixman_transform,
        reverse: *mut pixman_transform,
        sx: pixman_fixed_t,
        sy: pixman_fixed_t,
    ) -> pixman_bool_t;
}
extern "C" {
    pub fn pixman_transform_init_rotate(
        t: *mut pixman_transform,
        cos: pixman_fixed_t,
        sin: pixman_fixed_t,
    );
}
extern "C" {
    pub fn pixman_transform_rotate(
        forward: *mut pixman_transform,
        reverse: *mut pixman_transform,
        c: pixman_fixed_t,
        s: pixman_fixed_t,
    ) -> pixman_bool_t;
}
extern "C" {
    pub fn pixman_transform_init_translate(
        t: *mut pixman_transform,
        tx: pixman_fixed_t,
        ty: pixman_fixed_t,
    );
}
extern "C" {
    pub fn pixman_transform_translate(
        forward: *mut pixman_transform,
        reverse: *mut pixman_transform,
        tx: pixman_fixed_t,
        ty: pixman_fixed_t,
    ) -> pixman_bool_t;
}
extern "C" {
    pub fn pixman_transform_bounds(
        matrix: *const pixman_transform,
        b: *mut pixman_box16,
    ) -> pixman_bool_t;
}
extern "C" {
    pub fn pixman_transform_invert(
        dst: *mut pixman_transform,
        src: *const pixman_transform,
    ) -> pixman_bool_t;
}
extern "C" {
    pub fn pixman_transform_is_identity(t: *const pixman_transform) -> pixman_bool_t;
}
extern "C" {
    pub fn pixman_transform_is_scale(t: *const pixman_transform) -> pixman_bool_t;
}
extern "C" {
    pub fn pixman_transform_is_int_translate(t: *const pixman_transform) -> pixman_bool_t;
}
extern "C" {
    pub fn pixman_transform_is_inverse(
        a: *const pixman_transform,
        b: *const pixman_transform,
    ) -> pixman_bool_t;
}
pub type pixman_f_transform_t = pixman_f_transform;
pub type pixman_f_vector_t = pixman_f_vector;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pixman_f_vector {
    pub v: [f64; 3usize],
}
#[test]
fn bindgen_test_layout_pixman_f_vector() {
    assert_eq!(
        ::std::mem::size_of::<pixman_f_vector>(),
        24usize,
        concat!("Size of: ", stringify!(pixman_f_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<pixman_f_vector>(),
        8usize,
        concat!("Alignment of ", stringify!(pixman_f_vector))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_f_vector>())).v as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_f_vector),
            "::",
            stringify!(v)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pixman_f_transform {
    pub m: [[f64; 3usize]; 3usize],
}
#[test]
fn bindgen_test_layout_pixman_f_transform() {
    assert_eq!(
        ::std::mem::size_of::<pixman_f_transform>(),
        72usize,
        concat!("Size of: ", stringify!(pixman_f_transform))
    );
    assert_eq!(
        ::std::mem::align_of::<pixman_f_transform>(),
        8usize,
        concat!("Alignment of ", stringify!(pixman_f_transform))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_f_transform>())).m as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_f_transform),
            "::",
            stringify!(m)
        )
    );
}
extern "C" {
    pub fn pixman_transform_from_pixman_f_transform(
        t: *mut pixman_transform,
        ft: *const pixman_f_transform,
    ) -> pixman_bool_t;
}
extern "C" {
    pub fn pixman_f_transform_from_pixman_transform(
        ft: *mut pixman_f_transform,
        t: *const pixman_transform,
    );
}
extern "C" {
    pub fn pixman_f_transform_invert(
        dst: *mut pixman_f_transform,
        src: *const pixman_f_transform,
    ) -> pixman_bool_t;
}
extern "C" {
    pub fn pixman_f_transform_point(
        t: *const pixman_f_transform,
        v: *mut pixman_f_vector,
    ) -> pixman_bool_t;
}
extern "C" {
    pub fn pixman_f_transform_point_3d(t: *const pixman_f_transform, v: *mut pixman_f_vector);
}
extern "C" {
    pub fn pixman_f_transform_multiply(
        dst: *mut pixman_f_transform,
        l: *const pixman_f_transform,
        r: *const pixman_f_transform,
    );
}
extern "C" {
    pub fn pixman_f_transform_init_scale(t: *mut pixman_f_transform, sx: f64, sy: f64);
}
extern "C" {
    pub fn pixman_f_transform_scale(
        forward: *mut pixman_f_transform,
        reverse: *mut pixman_f_transform,
        sx: f64,
        sy: f64,
    ) -> pixman_bool_t;
}
extern "C" {
    pub fn pixman_f_transform_init_rotate(t: *mut pixman_f_transform, cos: f64, sin: f64);
}
extern "C" {
    pub fn pixman_f_transform_rotate(
        forward: *mut pixman_f_transform,
        reverse: *mut pixman_f_transform,
        c: f64,
        s: f64,
    ) -> pixman_bool_t;
}
extern "C" {
    pub fn pixman_f_transform_init_translate(t: *mut pixman_f_transform, tx: f64, ty: f64);
}
extern "C" {
    pub fn pixman_f_transform_translate(
        forward: *mut pixman_f_transform,
        reverse: *mut pixman_f_transform,
        tx: f64,
        ty: f64,
    ) -> pixman_bool_t;
}
extern "C" {
    pub fn pixman_f_transform_bounds(
        t: *const pixman_f_transform,
        b: *mut pixman_box16,
    ) -> pixman_bool_t;
}
extern "C" {
    pub fn pixman_f_transform_init_identity(t: *mut pixman_f_transform);
}
pub mod pixman_repeat_t {
    pub type Type = u32;
    pub const PIXMAN_REPEAT_NONE: Type = 0;
    pub const PIXMAN_REPEAT_NORMAL: Type = 1;
    pub const PIXMAN_REPEAT_PAD: Type = 2;
    pub const PIXMAN_REPEAT_REFLECT: Type = 3;
}
pub mod pixman_filter_t {
    pub type Type = u32;
    pub const PIXMAN_FILTER_FAST: Type = 0;
    pub const PIXMAN_FILTER_GOOD: Type = 1;
    pub const PIXMAN_FILTER_BEST: Type = 2;
    pub const PIXMAN_FILTER_NEAREST: Type = 3;
    pub const PIXMAN_FILTER_BILINEAR: Type = 4;
    pub const PIXMAN_FILTER_CONVOLUTION: Type = 5;
    pub const PIXMAN_FILTER_SEPARABLE_CONVOLUTION: Type = 6;
}
pub mod pixman_op_t {
    pub type Type = u32;
    pub const PIXMAN_OP_CLEAR: Type = 0;
    pub const PIXMAN_OP_SRC: Type = 1;
    pub const PIXMAN_OP_DST: Type = 2;
    pub const PIXMAN_OP_OVER: Type = 3;
    pub const PIXMAN_OP_OVER_REVERSE: Type = 4;
    pub const PIXMAN_OP_IN: Type = 5;
    pub const PIXMAN_OP_IN_REVERSE: Type = 6;
    pub const PIXMAN_OP_OUT: Type = 7;
    pub const PIXMAN_OP_OUT_REVERSE: Type = 8;
    pub const PIXMAN_OP_ATOP: Type = 9;
    pub const PIXMAN_OP_ATOP_REVERSE: Type = 10;
    pub const PIXMAN_OP_XOR: Type = 11;
    pub const PIXMAN_OP_ADD: Type = 12;
    pub const PIXMAN_OP_SATURATE: Type = 13;
    pub const PIXMAN_OP_DISJOINT_CLEAR: Type = 16;
    pub const PIXMAN_OP_DISJOINT_SRC: Type = 17;
    pub const PIXMAN_OP_DISJOINT_DST: Type = 18;
    pub const PIXMAN_OP_DISJOINT_OVER: Type = 19;
    pub const PIXMAN_OP_DISJOINT_OVER_REVERSE: Type = 20;
    pub const PIXMAN_OP_DISJOINT_IN: Type = 21;
    pub const PIXMAN_OP_DISJOINT_IN_REVERSE: Type = 22;
    pub const PIXMAN_OP_DISJOINT_OUT: Type = 23;
    pub const PIXMAN_OP_DISJOINT_OUT_REVERSE: Type = 24;
    pub const PIXMAN_OP_DISJOINT_ATOP: Type = 25;
    pub const PIXMAN_OP_DISJOINT_ATOP_REVERSE: Type = 26;
    pub const PIXMAN_OP_DISJOINT_XOR: Type = 27;
    pub const PIXMAN_OP_CONJOINT_CLEAR: Type = 32;
    pub const PIXMAN_OP_CONJOINT_SRC: Type = 33;
    pub const PIXMAN_OP_CONJOINT_DST: Type = 34;
    pub const PIXMAN_OP_CONJOINT_OVER: Type = 35;
    pub const PIXMAN_OP_CONJOINT_OVER_REVERSE: Type = 36;
    pub const PIXMAN_OP_CONJOINT_IN: Type = 37;
    pub const PIXMAN_OP_CONJOINT_IN_REVERSE: Type = 38;
    pub const PIXMAN_OP_CONJOINT_OUT: Type = 39;
    pub const PIXMAN_OP_CONJOINT_OUT_REVERSE: Type = 40;
    pub const PIXMAN_OP_CONJOINT_ATOP: Type = 41;
    pub const PIXMAN_OP_CONJOINT_ATOP_REVERSE: Type = 42;
    pub const PIXMAN_OP_CONJOINT_XOR: Type = 43;
    pub const PIXMAN_OP_MULTIPLY: Type = 48;
    pub const PIXMAN_OP_SCREEN: Type = 49;
    pub const PIXMAN_OP_OVERLAY: Type = 50;
    pub const PIXMAN_OP_DARKEN: Type = 51;
    pub const PIXMAN_OP_LIGHTEN: Type = 52;
    pub const PIXMAN_OP_COLOR_DODGE: Type = 53;
    pub const PIXMAN_OP_COLOR_BURN: Type = 54;
    pub const PIXMAN_OP_HARD_LIGHT: Type = 55;
    pub const PIXMAN_OP_SOFT_LIGHT: Type = 56;
    pub const PIXMAN_OP_DIFFERENCE: Type = 57;
    pub const PIXMAN_OP_EXCLUSION: Type = 58;
    pub const PIXMAN_OP_HSL_HUE: Type = 59;
    pub const PIXMAN_OP_HSL_SATURATION: Type = 60;
    pub const PIXMAN_OP_HSL_COLOR: Type = 61;
    pub const PIXMAN_OP_HSL_LUMINOSITY: Type = 62;
}
pub type pixman_region16_data_t = pixman_region16_data;
pub type pixman_box16_t = pixman_box16;
pub type pixman_rectangle16_t = pixman_rectangle16;
pub type pixman_region16_t = pixman_region16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pixman_region16_data {
    pub size: ::std::os::raw::c_long,
    pub numRects: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pixman_region16_data() {
    assert_eq!(
        ::std::mem::size_of::<pixman_region16_data>(),
        16usize,
        concat!("Size of: ", stringify!(pixman_region16_data))
    );
    assert_eq!(
        ::std::mem::align_of::<pixman_region16_data>(),
        8usize,
        concat!("Alignment of ", stringify!(pixman_region16_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_region16_data>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_region16_data),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_region16_data>())).numRects as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_region16_data),
            "::",
            stringify!(numRects)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pixman_rectangle16 {
    pub x: i16,
    pub y: i16,
    pub width: u16,
    pub height: u16,
}
#[test]
fn bindgen_test_layout_pixman_rectangle16() {
    assert_eq!(
        ::std::mem::size_of::<pixman_rectangle16>(),
        8usize,
        concat!("Size of: ", stringify!(pixman_rectangle16))
    );
    assert_eq!(
        ::std::mem::align_of::<pixman_rectangle16>(),
        2usize,
        concat!("Alignment of ", stringify!(pixman_rectangle16))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_rectangle16>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_rectangle16),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_rectangle16>())).y as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_rectangle16),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_rectangle16>())).width as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_rectangle16),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_rectangle16>())).height as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_rectangle16),
            "::",
            stringify!(height)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pixman_box16 {
    pub x1: i16,
    pub y1: i16,
    pub x2: i16,
    pub y2: i16,
}
#[test]
fn bindgen_test_layout_pixman_box16() {
    assert_eq!(
        ::std::mem::size_of::<pixman_box16>(),
        8usize,
        concat!("Size of: ", stringify!(pixman_box16))
    );
    assert_eq!(
        ::std::mem::align_of::<pixman_box16>(),
        2usize,
        concat!("Alignment of ", stringify!(pixman_box16))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_box16>())).x1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_box16),
            "::",
            stringify!(x1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_box16>())).y1 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_box16),
            "::",
            stringify!(y1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_box16>())).x2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_box16),
            "::",
            stringify!(x2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_box16>())).y2 as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_box16),
            "::",
            stringify!(y2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pixman_region16 {
    pub extents: pixman_box16_t,
    pub data: *mut pixman_region16_data_t,
}
#[test]
fn bindgen_test_layout_pixman_region16() {
    assert_eq!(
        ::std::mem::size_of::<pixman_region16>(),
        16usize,
        concat!("Size of: ", stringify!(pixman_region16))
    );
    assert_eq!(
        ::std::mem::align_of::<pixman_region16>(),
        8usize,
        concat!("Alignment of ", stringify!(pixman_region16))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_region16>())).extents as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_region16),
            "::",
            stringify!(extents)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_region16>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_region16),
            "::",
            stringify!(data)
        )
    );
}
pub mod pixman_region_overlap_t {
    pub type Type = u32;
    pub const PIXMAN_REGION_OUT: Type = 0;
    pub const PIXMAN_REGION_IN: Type = 1;
    pub const PIXMAN_REGION_PART: Type = 2;
}
extern "C" {
    pub fn pixman_region_set_static_pointers(
        empty_box: *mut pixman_box16_t,
        empty_data: *mut pixman_region16_data_t,
        broken_data: *mut pixman_region16_data_t,
    );
}
extern "C" {
    pub fn pixman_region_init(region: *mut pixman_region16_t);
}
extern "C" {
    pub fn pixman_region_init_rect(
        region: *mut pixman_region16_t,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn pixman_region_init_rects(
        region: *mut pixman_region16_t,
        boxes: *const pixman_box16_t,
        count: ::std::os::raw::c_int,
    ) -> pixman_bool_t;
}
extern "C" {
    pub fn pixman_region_init_with_extents(
        region: *mut pixman_region16_t,
        extents: *mut pixman_box16_t,
    );
}
extern "C" {
    pub fn pixman_region_init_from_image(
        region: *mut pixman_region16_t,
        image: *mut pixman_image_t,
    );
}
extern "C" {
    pub fn pixman_region_fini(region: *mut pixman_region16_t);
}
extern "C" {
    pub fn pixman_region_translate(
        region: *mut pixman_region16_t,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pixman_region_copy(
        dest: *mut pixman_region16_t,
        source: *mut pixman_region16_t,
    ) -> pixman_bool_t;
}
extern "C" {
    pub fn pixman_region_intersect(
        new_reg: *mut pixman_region16_t,
        reg1: *mut pixman_region16_t,
        reg2: *mut pixman_region16_t,
    ) -> pixman_bool_t;
}
extern "C" {
    pub fn pixman_region_union(
        new_reg: *mut pixman_region16_t,
        reg1: *mut pixman_region16_t,
        reg2: *mut pixman_region16_t,
    ) -> pixman_bool_t;
}
extern "C" {
    pub fn pixman_region_union_rect(
        dest: *mut pixman_region16_t,
        source: *mut pixman_region16_t,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
    ) -> pixman_bool_t;
}
extern "C" {
    pub fn pixman_region_intersect_rect(
        dest: *mut pixman_region16_t,
        source: *mut pixman_region16_t,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
    ) -> pixman_bool_t;
}
extern "C" {
    pub fn pixman_region_subtract(
        reg_d: *mut pixman_region16_t,
        reg_m: *mut pixman_region16_t,
        reg_s: *mut pixman_region16_t,
    ) -> pixman_bool_t;
}
extern "C" {
    pub fn pixman_region_inverse(
        new_reg: *mut pixman_region16_t,
        reg1: *mut pixman_region16_t,
        inv_rect: *mut pixman_box16_t,
    ) -> pixman_bool_t;
}
extern "C" {
    pub fn pixman_region_contains_point(
        region: *mut pixman_region16_t,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        box_: *mut pixman_box16_t,
    ) -> pixman_bool_t;
}
extern "C" {
    pub fn pixman_region_contains_rectangle(
        region: *mut pixman_region16_t,
        prect: *mut pixman_box16_t,
    ) -> pixman_region_overlap_t::Type;
}
extern "C" {
    pub fn pixman_region_not_empty(region: *mut pixman_region16_t) -> pixman_bool_t;
}
extern "C" {
    pub fn pixman_region_extents(region: *mut pixman_region16_t) -> *mut pixman_box16_t;
}
extern "C" {
    pub fn pixman_region_n_rects(region: *mut pixman_region16_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pixman_region_rectangles(
        region: *mut pixman_region16_t,
        n_rects: *mut ::std::os::raw::c_int,
    ) -> *mut pixman_box16_t;
}
extern "C" {
    pub fn pixman_region_equal(
        region1: *mut pixman_region16_t,
        region2: *mut pixman_region16_t,
    ) -> pixman_bool_t;
}
extern "C" {
    pub fn pixman_region_selfcheck(region: *mut pixman_region16_t) -> pixman_bool_t;
}
extern "C" {
    pub fn pixman_region_reset(region: *mut pixman_region16_t, box_: *mut pixman_box16_t);
}
extern "C" {
    pub fn pixman_region_clear(region: *mut pixman_region16_t);
}
pub type pixman_region32_data_t = pixman_region32_data;
pub type pixman_box32_t = pixman_box32;
pub type pixman_rectangle32_t = pixman_rectangle32;
pub type pixman_region32_t = pixman_region32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pixman_region32_data {
    pub size: ::std::os::raw::c_long,
    pub numRects: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pixman_region32_data() {
    assert_eq!(
        ::std::mem::size_of::<pixman_region32_data>(),
        16usize,
        concat!("Size of: ", stringify!(pixman_region32_data))
    );
    assert_eq!(
        ::std::mem::align_of::<pixman_region32_data>(),
        8usize,
        concat!("Alignment of ", stringify!(pixman_region32_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_region32_data>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_region32_data),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_region32_data>())).numRects as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_region32_data),
            "::",
            stringify!(numRects)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pixman_rectangle32 {
    pub x: i32,
    pub y: i32,
    pub width: u32,
    pub height: u32,
}
#[test]
fn bindgen_test_layout_pixman_rectangle32() {
    assert_eq!(
        ::std::mem::size_of::<pixman_rectangle32>(),
        16usize,
        concat!("Size of: ", stringify!(pixman_rectangle32))
    );
    assert_eq!(
        ::std::mem::align_of::<pixman_rectangle32>(),
        4usize,
        concat!("Alignment of ", stringify!(pixman_rectangle32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_rectangle32>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_rectangle32),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_rectangle32>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_rectangle32),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_rectangle32>())).width as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_rectangle32),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_rectangle32>())).height as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_rectangle32),
            "::",
            stringify!(height)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pixman_box32 {
    pub x1: i32,
    pub y1: i32,
    pub x2: i32,
    pub y2: i32,
}
#[test]
fn bindgen_test_layout_pixman_box32() {
    assert_eq!(
        ::std::mem::size_of::<pixman_box32>(),
        16usize,
        concat!("Size of: ", stringify!(pixman_box32))
    );
    assert_eq!(
        ::std::mem::align_of::<pixman_box32>(),
        4usize,
        concat!("Alignment of ", stringify!(pixman_box32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_box32>())).x1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_box32),
            "::",
            stringify!(x1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_box32>())).y1 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_box32),
            "::",
            stringify!(y1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_box32>())).x2 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_box32),
            "::",
            stringify!(x2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_box32>())).y2 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_box32),
            "::",
            stringify!(y2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pixman_region32 {
    pub extents: pixman_box32_t,
    pub data: *mut pixman_region32_data_t,
}
#[test]
fn bindgen_test_layout_pixman_region32() {
    assert_eq!(
        ::std::mem::size_of::<pixman_region32>(),
        24usize,
        concat!("Size of: ", stringify!(pixman_region32))
    );
    assert_eq!(
        ::std::mem::align_of::<pixman_region32>(),
        8usize,
        concat!("Alignment of ", stringify!(pixman_region32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_region32>())).extents as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_region32),
            "::",
            stringify!(extents)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_region32>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_region32),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    pub fn pixman_region32_init(region: *mut pixman_region32_t);
}
extern "C" {
    pub fn pixman_region32_init_rect(
        region: *mut pixman_region32_t,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn pixman_region32_init_rects(
        region: *mut pixman_region32_t,
        boxes: *const pixman_box32_t,
        count: ::std::os::raw::c_int,
    ) -> pixman_bool_t;
}
extern "C" {
    pub fn pixman_region32_init_with_extents(
        region: *mut pixman_region32_t,
        extents: *mut pixman_box32_t,
    );
}
extern "C" {
    pub fn pixman_region32_init_from_image(
        region: *mut pixman_region32_t,
        image: *mut pixman_image_t,
    );
}
extern "C" {
    pub fn pixman_region32_fini(region: *mut pixman_region32_t);
}
extern "C" {
    pub fn pixman_region32_translate(
        region: *mut pixman_region32_t,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pixman_region32_copy(
        dest: *mut pixman_region32_t,
        source: *mut pixman_region32_t,
    ) -> pixman_bool_t;
}
extern "C" {
    pub fn pixman_region32_intersect(
        new_reg: *mut pixman_region32_t,
        reg1: *mut pixman_region32_t,
        reg2: *mut pixman_region32_t,
    ) -> pixman_bool_t;
}
extern "C" {
    pub fn pixman_region32_union(
        new_reg: *mut pixman_region32_t,
        reg1: *mut pixman_region32_t,
        reg2: *mut pixman_region32_t,
    ) -> pixman_bool_t;
}
extern "C" {
    pub fn pixman_region32_intersect_rect(
        dest: *mut pixman_region32_t,
        source: *mut pixman_region32_t,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
    ) -> pixman_bool_t;
}
extern "C" {
    pub fn pixman_region32_union_rect(
        dest: *mut pixman_region32_t,
        source: *mut pixman_region32_t,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
    ) -> pixman_bool_t;
}
extern "C" {
    pub fn pixman_region32_subtract(
        reg_d: *mut pixman_region32_t,
        reg_m: *mut pixman_region32_t,
        reg_s: *mut pixman_region32_t,
    ) -> pixman_bool_t;
}
extern "C" {
    pub fn pixman_region32_inverse(
        new_reg: *mut pixman_region32_t,
        reg1: *mut pixman_region32_t,
        inv_rect: *mut pixman_box32_t,
    ) -> pixman_bool_t;
}
extern "C" {
    pub fn pixman_region32_contains_point(
        region: *mut pixman_region32_t,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        box_: *mut pixman_box32_t,
    ) -> pixman_bool_t;
}
extern "C" {
    pub fn pixman_region32_contains_rectangle(
        region: *mut pixman_region32_t,
        prect: *mut pixman_box32_t,
    ) -> pixman_region_overlap_t::Type;
}
extern "C" {
    pub fn pixman_region32_not_empty(region: *mut pixman_region32_t) -> pixman_bool_t;
}
extern "C" {
    pub fn pixman_region32_extents(region: *mut pixman_region32_t) -> *mut pixman_box32_t;
}
extern "C" {
    pub fn pixman_region32_n_rects(region: *mut pixman_region32_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pixman_region32_rectangles(
        region: *mut pixman_region32_t,
        n_rects: *mut ::std::os::raw::c_int,
    ) -> *mut pixman_box32_t;
}
extern "C" {
    pub fn pixman_region32_equal(
        region1: *mut pixman_region32_t,
        region2: *mut pixman_region32_t,
    ) -> pixman_bool_t;
}
extern "C" {
    pub fn pixman_region32_selfcheck(region: *mut pixman_region32_t) -> pixman_bool_t;
}
extern "C" {
    pub fn pixman_region32_reset(region: *mut pixman_region32_t, box_: *mut pixman_box32_t);
}
extern "C" {
    pub fn pixman_region32_clear(region: *mut pixman_region32_t);
}
extern "C" {
    pub fn pixman_blt(
        src_bits: *mut u32,
        dst_bits: *mut u32,
        src_stride: ::std::os::raw::c_int,
        dst_stride: ::std::os::raw::c_int,
        src_bpp: ::std::os::raw::c_int,
        dst_bpp: ::std::os::raw::c_int,
        src_x: ::std::os::raw::c_int,
        src_y: ::std::os::raw::c_int,
        dest_x: ::std::os::raw::c_int,
        dest_y: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> pixman_bool_t;
}
extern "C" {
    pub fn pixman_fill(
        bits: *mut u32,
        stride: ::std::os::raw::c_int,
        bpp: ::std::os::raw::c_int,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        _xor: u32,
    ) -> pixman_bool_t;
}
extern "C" {
    pub fn pixman_version() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pixman_version_string() -> *const ::std::os::raw::c_char;
}
pub type pixman_indexed_t = pixman_indexed;
pub type pixman_gradient_stop_t = pixman_gradient_stop;
pub type pixman_read_memory_func_t = ::std::option::Option<
    unsafe extern "C" fn(src: *const ::std::os::raw::c_void, size: ::std::os::raw::c_int) -> u32,
>;
pub type pixman_write_memory_func_t = ::std::option::Option<
    unsafe extern "C" fn(dst: *mut ::std::os::raw::c_void, value: u32, size: ::std::os::raw::c_int),
>;
pub type pixman_image_destroy_func_t = ::std::option::Option<
    unsafe extern "C" fn(image: *mut pixman_image_t, data: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pixman_gradient_stop {
    pub x: pixman_fixed_t,
    pub color: pixman_color_t,
}
#[test]
fn bindgen_test_layout_pixman_gradient_stop() {
    assert_eq!(
        ::std::mem::size_of::<pixman_gradient_stop>(),
        12usize,
        concat!("Size of: ", stringify!(pixman_gradient_stop))
    );
    assert_eq!(
        ::std::mem::align_of::<pixman_gradient_stop>(),
        4usize,
        concat!("Alignment of ", stringify!(pixman_gradient_stop))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_gradient_stop>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_gradient_stop),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_gradient_stop>())).color as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_gradient_stop),
            "::",
            stringify!(color)
        )
    );
}
pub type pixman_index_type = u8;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pixman_indexed {
    pub color: pixman_bool_t,
    pub rgba: [u32; 256usize],
    pub ent: [pixman_index_type; 32768usize],
}
#[test]
fn bindgen_test_layout_pixman_indexed() {
    assert_eq!(
        ::std::mem::size_of::<pixman_indexed>(),
        33796usize,
        concat!("Size of: ", stringify!(pixman_indexed))
    );
    assert_eq!(
        ::std::mem::align_of::<pixman_indexed>(),
        4usize,
        concat!("Alignment of ", stringify!(pixman_indexed))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_indexed>())).color as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_indexed),
            "::",
            stringify!(color)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_indexed>())).rgba as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_indexed),
            "::",
            stringify!(rgba)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_indexed>())).ent as *const _ as usize },
        1028usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_indexed),
            "::",
            stringify!(ent)
        )
    );
}
pub mod pixman_format_code_t {
    pub type Type = u32;
    pub const PIXMAN_rgba_float: Type = 281756740;
    pub const PIXMAN_rgb_float: Type = 214631492;
    pub const PIXMAN_a8r8g8b8: Type = 537036936;
    pub const PIXMAN_x8r8g8b8: Type = 537004168;
    pub const PIXMAN_a8b8g8r8: Type = 537102472;
    pub const PIXMAN_x8b8g8r8: Type = 537069704;
    pub const PIXMAN_b8g8r8a8: Type = 537430152;
    pub const PIXMAN_b8g8r8x8: Type = 537397384;
    pub const PIXMAN_r8g8b8a8: Type = 537495688;
    pub const PIXMAN_r8g8b8x8: Type = 537462920;
    pub const PIXMAN_x14r6g6b6: Type = 537003622;
    pub const PIXMAN_x2r10g10b10: Type = 537004714;
    pub const PIXMAN_a2r10g10b10: Type = 537012906;
    pub const PIXMAN_x2b10g10r10: Type = 537070250;
    pub const PIXMAN_a2b10g10r10: Type = 537078442;
    pub const PIXMAN_a8r8g8b8_sRGB: Type = 537561224;
    pub const PIXMAN_r8g8b8: Type = 402786440;
    pub const PIXMAN_b8g8r8: Type = 402851976;
    pub const PIXMAN_r5g6b5: Type = 268567909;
    pub const PIXMAN_b5g6r5: Type = 268633445;
    pub const PIXMAN_a1r5g5b5: Type = 268571989;
    pub const PIXMAN_x1r5g5b5: Type = 268567893;
    pub const PIXMAN_a1b5g5r5: Type = 268637525;
    pub const PIXMAN_x1b5g5r5: Type = 268633429;
    pub const PIXMAN_a4r4g4b4: Type = 268584004;
    pub const PIXMAN_x4r4g4b4: Type = 268567620;
    pub const PIXMAN_a4b4g4r4: Type = 268649540;
    pub const PIXMAN_x4b4g4r4: Type = 268633156;
    pub const PIXMAN_a8: Type = 134316032;
    pub const PIXMAN_r3g3b2: Type = 134349618;
    pub const PIXMAN_b2g3r3: Type = 134415154;
    pub const PIXMAN_a2r2g2b2: Type = 134357538;
    pub const PIXMAN_a2b2g2r2: Type = 134423074;
    pub const PIXMAN_c8: Type = 134479872;
    pub const PIXMAN_g8: Type = 134545408;
    pub const PIXMAN_x4a4: Type = 134299648;
    pub const PIXMAN_x4c4: Type = 134479872;
    pub const PIXMAN_x4g4: Type = 134545408;
    pub const PIXMAN_a4: Type = 67190784;
    pub const PIXMAN_r1g2b1: Type = 67240225;
    pub const PIXMAN_b1g2r1: Type = 67305761;
    pub const PIXMAN_a1r1g1b1: Type = 67244305;
    pub const PIXMAN_a1b1g1r1: Type = 67309841;
    pub const PIXMAN_c4: Type = 67371008;
    pub const PIXMAN_g4: Type = 67436544;
    pub const PIXMAN_a1: Type = 16846848;
    pub const PIXMAN_g1: Type = 17104896;
    pub const PIXMAN_yuy2: Type = 268828672;
    pub const PIXMAN_yv12: Type = 201785344;
}
extern "C" {
    pub fn pixman_format_supported_destination(format: pixman_format_code_t::Type)
        -> pixman_bool_t;
}
extern "C" {
    pub fn pixman_format_supported_source(format: pixman_format_code_t::Type) -> pixman_bool_t;
}
extern "C" {
    pub fn pixman_image_create_solid_fill(color: *const pixman_color_t) -> *mut pixman_image_t;
}
extern "C" {
    pub fn pixman_image_create_linear_gradient(
        p1: *const pixman_point_fixed_t,
        p2: *const pixman_point_fixed_t,
        stops: *const pixman_gradient_stop_t,
        n_stops: ::std::os::raw::c_int,
    ) -> *mut pixman_image_t;
}
extern "C" {
    pub fn pixman_image_create_radial_gradient(
        inner: *const pixman_point_fixed_t,
        outer: *const pixman_point_fixed_t,
        inner_radius: pixman_fixed_t,
        outer_radius: pixman_fixed_t,
        stops: *const pixman_gradient_stop_t,
        n_stops: ::std::os::raw::c_int,
    ) -> *mut pixman_image_t;
}
extern "C" {
    pub fn pixman_image_create_conical_gradient(
        center: *const pixman_point_fixed_t,
        angle: pixman_fixed_t,
        stops: *const pixman_gradient_stop_t,
        n_stops: ::std::os::raw::c_int,
    ) -> *mut pixman_image_t;
}
extern "C" {
    pub fn pixman_image_create_bits(
        format: pixman_format_code_t::Type,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        bits: *mut u32,
        rowstride_bytes: ::std::os::raw::c_int,
    ) -> *mut pixman_image_t;
}
extern "C" {
    pub fn pixman_image_create_bits_no_clear(
        format: pixman_format_code_t::Type,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        bits: *mut u32,
        rowstride_bytes: ::std::os::raw::c_int,
    ) -> *mut pixman_image_t;
}
extern "C" {
    pub fn pixman_image_ref(image: *mut pixman_image_t) -> *mut pixman_image_t;
}
extern "C" {
    pub fn pixman_image_unref(image: *mut pixman_image_t) -> pixman_bool_t;
}
extern "C" {
    pub fn pixman_image_set_destroy_function(
        image: *mut pixman_image_t,
        function: pixman_image_destroy_func_t,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn pixman_image_get_destroy_data(image: *mut pixman_image_t)
        -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pixman_image_set_clip_region(
        image: *mut pixman_image_t,
        region: *mut pixman_region16_t,
    ) -> pixman_bool_t;
}
extern "C" {
    pub fn pixman_image_set_clip_region32(
        image: *mut pixman_image_t,
        region: *mut pixman_region32_t,
    ) -> pixman_bool_t;
}
extern "C" {
    pub fn pixman_image_set_has_client_clip(image: *mut pixman_image_t, clien_clip: pixman_bool_t);
}
extern "C" {
    pub fn pixman_image_set_transform(
        image: *mut pixman_image_t,
        transform: *const pixman_transform_t,
    ) -> pixman_bool_t;
}
extern "C" {
    pub fn pixman_image_set_repeat(image: *mut pixman_image_t, repeat: pixman_repeat_t::Type);
}
extern "C" {
    pub fn pixman_image_set_filter(
        image: *mut pixman_image_t,
        filter: pixman_filter_t::Type,
        filter_params: *const pixman_fixed_t,
        n_filter_params: ::std::os::raw::c_int,
    ) -> pixman_bool_t;
}
extern "C" {
    pub fn pixman_image_set_source_clipping(
        image: *mut pixman_image_t,
        source_clipping: pixman_bool_t,
    );
}
extern "C" {
    pub fn pixman_image_set_alpha_map(
        image: *mut pixman_image_t,
        alpha_map: *mut pixman_image_t,
        x: i16,
        y: i16,
    );
}
extern "C" {
    pub fn pixman_image_set_component_alpha(
        image: *mut pixman_image_t,
        component_alpha: pixman_bool_t,
    );
}
extern "C" {
    pub fn pixman_image_get_component_alpha(image: *mut pixman_image_t) -> pixman_bool_t;
}
extern "C" {
    pub fn pixman_image_set_accessors(
        image: *mut pixman_image_t,
        read_func: pixman_read_memory_func_t,
        write_func: pixman_write_memory_func_t,
    );
}
extern "C" {
    pub fn pixman_image_set_indexed(image: *mut pixman_image_t, indexed: *const pixman_indexed_t);
}
extern "C" {
    pub fn pixman_image_get_data(image: *mut pixman_image_t) -> *mut u32;
}
extern "C" {
    pub fn pixman_image_get_width(image: *mut pixman_image_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pixman_image_get_height(image: *mut pixman_image_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pixman_image_get_stride(image: *mut pixman_image_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pixman_image_get_depth(image: *mut pixman_image_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pixman_image_get_format(image: *mut pixman_image_t) -> pixman_format_code_t::Type;
}
pub mod pixman_kernel_t {
    pub type Type = u32;
    pub const PIXMAN_KERNEL_IMPULSE: Type = 0;
    pub const PIXMAN_KERNEL_BOX: Type = 1;
    pub const PIXMAN_KERNEL_LINEAR: Type = 2;
    pub const PIXMAN_KERNEL_CUBIC: Type = 3;
    pub const PIXMAN_KERNEL_GAUSSIAN: Type = 4;
    pub const PIXMAN_KERNEL_LANCZOS2: Type = 5;
    pub const PIXMAN_KERNEL_LANCZOS3: Type = 6;
    pub const PIXMAN_KERNEL_LANCZOS3_STRETCHED: Type = 7;
}
extern "C" {
    pub fn pixman_filter_create_separable_convolution(
        n_values: *mut ::std::os::raw::c_int,
        scale_x: pixman_fixed_t,
        scale_y: pixman_fixed_t,
        reconstruct_x: pixman_kernel_t::Type,
        reconstruct_y: pixman_kernel_t::Type,
        sample_x: pixman_kernel_t::Type,
        sample_y: pixman_kernel_t::Type,
        subsample_bits_x: ::std::os::raw::c_int,
        subsample_bits_y: ::std::os::raw::c_int,
    ) -> *mut pixman_fixed_t;
}
extern "C" {
    pub fn pixman_image_fill_rectangles(
        op: pixman_op_t::Type,
        image: *mut pixman_image_t,
        color: *const pixman_color_t,
        n_rects: ::std::os::raw::c_int,
        rects: *const pixman_rectangle16_t,
    ) -> pixman_bool_t;
}
extern "C" {
    pub fn pixman_image_fill_boxes(
        op: pixman_op_t::Type,
        dest: *mut pixman_image_t,
        color: *const pixman_color_t,
        n_boxes: ::std::os::raw::c_int,
        boxes: *const pixman_box32_t,
    ) -> pixman_bool_t;
}
extern "C" {
    pub fn pixman_compute_composite_region(
        region: *mut pixman_region16_t,
        src_image: *mut pixman_image_t,
        mask_image: *mut pixman_image_t,
        dest_image: *mut pixman_image_t,
        src_x: i16,
        src_y: i16,
        mask_x: i16,
        mask_y: i16,
        dest_x: i16,
        dest_y: i16,
        width: u16,
        height: u16,
    ) -> pixman_bool_t;
}
extern "C" {
    pub fn pixman_image_composite(
        op: pixman_op_t::Type,
        src: *mut pixman_image_t,
        mask: *mut pixman_image_t,
        dest: *mut pixman_image_t,
        src_x: i16,
        src_y: i16,
        mask_x: i16,
        mask_y: i16,
        dest_x: i16,
        dest_y: i16,
        width: u16,
        height: u16,
    );
}
extern "C" {
    pub fn pixman_image_composite32(
        op: pixman_op_t::Type,
        src: *mut pixman_image_t,
        mask: *mut pixman_image_t,
        dest: *mut pixman_image_t,
        src_x: i32,
        src_y: i32,
        mask_x: i32,
        mask_y: i32,
        dest_x: i32,
        dest_y: i32,
        width: i32,
        height: i32,
    );
}
extern "C" {
    pub fn pixman_disable_out_of_bounds_workaround();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pixman_glyph_cache_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pixman_glyph_t {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub glyph: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_pixman_glyph_t() {
    assert_eq!(
        ::std::mem::size_of::<pixman_glyph_t>(),
        16usize,
        concat!("Size of: ", stringify!(pixman_glyph_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pixman_glyph_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pixman_glyph_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_glyph_t>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_glyph_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_glyph_t>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_glyph_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_glyph_t>())).glyph as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_glyph_t),
            "::",
            stringify!(glyph)
        )
    );
}
extern "C" {
    pub fn pixman_glyph_cache_create() -> *mut pixman_glyph_cache_t;
}
extern "C" {
    pub fn pixman_glyph_cache_destroy(cache: *mut pixman_glyph_cache_t);
}
extern "C" {
    pub fn pixman_glyph_cache_freeze(cache: *mut pixman_glyph_cache_t);
}
extern "C" {
    pub fn pixman_glyph_cache_thaw(cache: *mut pixman_glyph_cache_t);
}
extern "C" {
    pub fn pixman_glyph_cache_lookup(
        cache: *mut pixman_glyph_cache_t,
        font_key: *mut ::std::os::raw::c_void,
        glyph_key: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn pixman_glyph_cache_insert(
        cache: *mut pixman_glyph_cache_t,
        font_key: *mut ::std::os::raw::c_void,
        glyph_key: *mut ::std::os::raw::c_void,
        origin_x: ::std::os::raw::c_int,
        origin_y: ::std::os::raw::c_int,
        glyph_image: *mut pixman_image_t,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn pixman_glyph_cache_remove(
        cache: *mut pixman_glyph_cache_t,
        font_key: *mut ::std::os::raw::c_void,
        glyph_key: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn pixman_glyph_get_extents(
        cache: *mut pixman_glyph_cache_t,
        n_glyphs: ::std::os::raw::c_int,
        glyphs: *mut pixman_glyph_t,
        extents: *mut pixman_box32_t,
    );
}
extern "C" {
    pub fn pixman_glyph_get_mask_format(
        cache: *mut pixman_glyph_cache_t,
        n_glyphs: ::std::os::raw::c_int,
        glyphs: *const pixman_glyph_t,
    ) -> pixman_format_code_t::Type;
}
extern "C" {
    pub fn pixman_composite_glyphs(
        op: pixman_op_t::Type,
        src: *mut pixman_image_t,
        dest: *mut pixman_image_t,
        mask_format: pixman_format_code_t::Type,
        src_x: i32,
        src_y: i32,
        mask_x: i32,
        mask_y: i32,
        dest_x: i32,
        dest_y: i32,
        width: i32,
        height: i32,
        cache: *mut pixman_glyph_cache_t,
        n_glyphs: ::std::os::raw::c_int,
        glyphs: *const pixman_glyph_t,
    );
}
extern "C" {
    pub fn pixman_composite_glyphs_no_mask(
        op: pixman_op_t::Type,
        src: *mut pixman_image_t,
        dest: *mut pixman_image_t,
        src_x: i32,
        src_y: i32,
        dest_x: i32,
        dest_y: i32,
        cache: *mut pixman_glyph_cache_t,
        n_glyphs: ::std::os::raw::c_int,
        glyphs: *const pixman_glyph_t,
    );
}
pub type pixman_edge_t = pixman_edge;
pub type pixman_trapezoid_t = pixman_trapezoid;
pub type pixman_trap_t = pixman_trap;
pub type pixman_span_fix_t = pixman_span_fix;
pub type pixman_triangle_t = pixman_triangle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pixman_edge {
    pub x: pixman_fixed_t,
    pub e: pixman_fixed_t,
    pub stepx: pixman_fixed_t,
    pub signdx: pixman_fixed_t,
    pub dy: pixman_fixed_t,
    pub dx: pixman_fixed_t,
    pub stepx_small: pixman_fixed_t,
    pub stepx_big: pixman_fixed_t,
    pub dx_small: pixman_fixed_t,
    pub dx_big: pixman_fixed_t,
}
#[test]
fn bindgen_test_layout_pixman_edge() {
    assert_eq!(
        ::std::mem::size_of::<pixman_edge>(),
        40usize,
        concat!("Size of: ", stringify!(pixman_edge))
    );
    assert_eq!(
        ::std::mem::align_of::<pixman_edge>(),
        4usize,
        concat!("Alignment of ", stringify!(pixman_edge))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_edge>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_edge),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_edge>())).e as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_edge),
            "::",
            stringify!(e)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_edge>())).stepx as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_edge),
            "::",
            stringify!(stepx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_edge>())).signdx as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_edge),
            "::",
            stringify!(signdx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_edge>())).dy as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_edge),
            "::",
            stringify!(dy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_edge>())).dx as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_edge),
            "::",
            stringify!(dx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_edge>())).stepx_small as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_edge),
            "::",
            stringify!(stepx_small)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_edge>())).stepx_big as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_edge),
            "::",
            stringify!(stepx_big)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_edge>())).dx_small as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_edge),
            "::",
            stringify!(dx_small)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_edge>())).dx_big as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_edge),
            "::",
            stringify!(dx_big)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pixman_trapezoid {
    pub top: pixman_fixed_t,
    pub bottom: pixman_fixed_t,
    pub left: pixman_line_fixed_t,
    pub right: pixman_line_fixed_t,
}
#[test]
fn bindgen_test_layout_pixman_trapezoid() {
    assert_eq!(
        ::std::mem::size_of::<pixman_trapezoid>(),
        40usize,
        concat!("Size of: ", stringify!(pixman_trapezoid))
    );
    assert_eq!(
        ::std::mem::align_of::<pixman_trapezoid>(),
        4usize,
        concat!("Alignment of ", stringify!(pixman_trapezoid))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_trapezoid>())).top as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_trapezoid),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_trapezoid>())).bottom as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_trapezoid),
            "::",
            stringify!(bottom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_trapezoid>())).left as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_trapezoid),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_trapezoid>())).right as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_trapezoid),
            "::",
            stringify!(right)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pixman_triangle {
    pub p1: pixman_point_fixed_t,
    pub p2: pixman_point_fixed_t,
    pub p3: pixman_point_fixed_t,
}
#[test]
fn bindgen_test_layout_pixman_triangle() {
    assert_eq!(
        ::std::mem::size_of::<pixman_triangle>(),
        24usize,
        concat!("Size of: ", stringify!(pixman_triangle))
    );
    assert_eq!(
        ::std::mem::align_of::<pixman_triangle>(),
        4usize,
        concat!("Alignment of ", stringify!(pixman_triangle))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_triangle>())).p1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_triangle),
            "::",
            stringify!(p1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_triangle>())).p2 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_triangle),
            "::",
            stringify!(p2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_triangle>())).p3 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_triangle),
            "::",
            stringify!(p3)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pixman_span_fix {
    pub l: pixman_fixed_t,
    pub r: pixman_fixed_t,
    pub y: pixman_fixed_t,
}
#[test]
fn bindgen_test_layout_pixman_span_fix() {
    assert_eq!(
        ::std::mem::size_of::<pixman_span_fix>(),
        12usize,
        concat!("Size of: ", stringify!(pixman_span_fix))
    );
    assert_eq!(
        ::std::mem::align_of::<pixman_span_fix>(),
        4usize,
        concat!("Alignment of ", stringify!(pixman_span_fix))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_span_fix>())).l as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_span_fix),
            "::",
            stringify!(l)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_span_fix>())).r as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_span_fix),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_span_fix>())).y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_span_fix),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pixman_trap {
    pub top: pixman_span_fix_t,
    pub bot: pixman_span_fix_t,
}
#[test]
fn bindgen_test_layout_pixman_trap() {
    assert_eq!(
        ::std::mem::size_of::<pixman_trap>(),
        24usize,
        concat!("Size of: ", stringify!(pixman_trap))
    );
    assert_eq!(
        ::std::mem::align_of::<pixman_trap>(),
        4usize,
        concat!("Alignment of ", stringify!(pixman_trap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_trap>())).top as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_trap),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pixman_trap>())).bot as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(pixman_trap),
            "::",
            stringify!(bot)
        )
    );
}
extern "C" {
    pub fn pixman_sample_ceil_y(y: pixman_fixed_t, bpp: ::std::os::raw::c_int) -> pixman_fixed_t;
}
extern "C" {
    pub fn pixman_sample_floor_y(y: pixman_fixed_t, bpp: ::std::os::raw::c_int) -> pixman_fixed_t;
}
extern "C" {
    pub fn pixman_edge_step(e: *mut pixman_edge_t, n: ::std::os::raw::c_int);
}
extern "C" {
    pub fn pixman_edge_init(
        e: *mut pixman_edge_t,
        bpp: ::std::os::raw::c_int,
        y_start: pixman_fixed_t,
        x_top: pixman_fixed_t,
        y_top: pixman_fixed_t,
        x_bot: pixman_fixed_t,
        y_bot: pixman_fixed_t,
    );
}
extern "C" {
    pub fn pixman_line_fixed_edge_init(
        e: *mut pixman_edge_t,
        bpp: ::std::os::raw::c_int,
        y: pixman_fixed_t,
        line: *const pixman_line_fixed_t,
        x_off: ::std::os::raw::c_int,
        y_off: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pixman_rasterize_edges(
        image: *mut pixman_image_t,
        l: *mut pixman_edge_t,
        r: *mut pixman_edge_t,
        t: pixman_fixed_t,
        b: pixman_fixed_t,
    );
}
extern "C" {
    pub fn pixman_add_traps(
        image: *mut pixman_image_t,
        x_off: i16,
        y_off: i16,
        ntrap: ::std::os::raw::c_int,
        traps: *const pixman_trap_t,
    );
}
extern "C" {
    pub fn pixman_add_trapezoids(
        image: *mut pixman_image_t,
        x_off: i16,
        y_off: ::std::os::raw::c_int,
        ntraps: ::std::os::raw::c_int,
        traps: *const pixman_trapezoid_t,
    );
}
extern "C" {
    pub fn pixman_rasterize_trapezoid(
        image: *mut pixman_image_t,
        trap: *const pixman_trapezoid_t,
        x_off: ::std::os::raw::c_int,
        y_off: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pixman_composite_trapezoids(
        op: pixman_op_t::Type,
        src: *mut pixman_image_t,
        dst: *mut pixman_image_t,
        mask_format: pixman_format_code_t::Type,
        x_src: ::std::os::raw::c_int,
        y_src: ::std::os::raw::c_int,
        x_dst: ::std::os::raw::c_int,
        y_dst: ::std::os::raw::c_int,
        n_traps: ::std::os::raw::c_int,
        traps: *const pixman_trapezoid_t,
    );
}
extern "C" {
    pub fn pixman_composite_triangles(
        op: pixman_op_t::Type,
        src: *mut pixman_image_t,
        dst: *mut pixman_image_t,
        mask_format: pixman_format_code_t::Type,
        x_src: ::std::os::raw::c_int,
        y_src: ::std::os::raw::c_int,
        x_dst: ::std::os::raw::c_int,
        y_dst: ::std::os::raw::c_int,
        n_tris: ::std::os::raw::c_int,
        tris: *const pixman_triangle_t,
    );
}
extern "C" {
    pub fn pixman_add_triangles(
        image: *mut pixman_image_t,
        x_off: i32,
        y_off: i32,
        n_tris: ::std::os::raw::c_int,
        tris: *const pixman_triangle_t,
    );
}
pub mod wlr_dmabuf_attributes_flags {
    pub type Type = u32;
    pub const WLR_DMABUF_ATTRIBUTES_FLAGS_Y_INVERT: Type = 1;
    pub const WLR_DMABUF_ATTRIBUTES_FLAGS_INTERLACED: Type = 2;
    pub const WLR_DMABUF_ATTRIBUTES_FLAGS_BOTTOM_FIRST: Type = 4;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_dmabuf_attributes {
    pub width: i32,
    pub height: i32,
    pub format: u32,
    pub flags: u32,
    pub modifier: u64,
    pub n_planes: ::std::os::raw::c_int,
    pub offset: [u32; 4usize],
    pub stride: [u32; 4usize],
    pub fd: [::std::os::raw::c_int; 4usize],
}
#[test]
fn bindgen_test_layout_wlr_dmabuf_attributes() {
    assert_eq!(
        ::std::mem::size_of::<wlr_dmabuf_attributes>(),
        80usize,
        concat!("Size of: ", stringify!(wlr_dmabuf_attributes))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_dmabuf_attributes>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_dmabuf_attributes))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_dmabuf_attributes>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_dmabuf_attributes),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_dmabuf_attributes>())).height as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_dmabuf_attributes),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_dmabuf_attributes>())).format as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_dmabuf_attributes),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_dmabuf_attributes>())).flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_dmabuf_attributes),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_dmabuf_attributes>())).modifier as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_dmabuf_attributes),
            "::",
            stringify!(modifier)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_dmabuf_attributes>())).n_planes as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_dmabuf_attributes),
            "::",
            stringify!(n_planes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_dmabuf_attributes>())).offset as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_dmabuf_attributes),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_dmabuf_attributes>())).stride as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_dmabuf_attributes),
            "::",
            stringify!(stride)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_dmabuf_attributes>())).fd as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_dmabuf_attributes),
            "::",
            stringify!(fd)
        )
    );
}
extern "C" {
    #[doc = " Closes all file descriptors in the DMA-BUF attributes."]
    pub fn wlr_dmabuf_attributes_finish(attribs: *mut wlr_dmabuf_attributes);
}
extern "C" {
    #[doc = " Clones the DMA-BUF attributes."]
    pub fn wlr_dmabuf_attributes_copy(
        dst: *mut wlr_dmabuf_attributes,
        src: *mut wlr_dmabuf_attributes,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug)]
pub struct wlr_drm_format {
    pub format: u32,
    pub len: usize,
    pub cap: usize,
    pub modifiers: __IncompleteArrayField<u64>,
}
#[test]
fn bindgen_test_layout_wlr_drm_format() {
    assert_eq!(
        ::std::mem::size_of::<wlr_drm_format>(),
        24usize,
        concat!("Size of: ", stringify!(wlr_drm_format))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_drm_format>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_drm_format))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_drm_format_set {
    pub len: usize,
    pub cap: usize,
    pub formats: *mut *mut wlr_drm_format,
}
#[test]
fn bindgen_test_layout_wlr_drm_format_set() {
    assert_eq!(
        ::std::mem::size_of::<wlr_drm_format_set>(),
        24usize,
        concat!("Size of: ", stringify!(wlr_drm_format_set))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_drm_format_set>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_drm_format_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_drm_format_set>())).len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_drm_format_set),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_drm_format_set>())).cap as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_drm_format_set),
            "::",
            stringify!(cap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_drm_format_set>())).formats as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_drm_format_set),
            "::",
            stringify!(formats)
        )
    );
}
extern "C" {
    pub fn wlr_drm_format_set_finish(set: *mut wlr_drm_format_set);
}
extern "C" {
    pub fn wlr_drm_format_set_get(
        set: *const wlr_drm_format_set,
        format: u32,
    ) -> *const wlr_drm_format;
}
extern "C" {
    pub fn wlr_drm_format_set_has(
        set: *const wlr_drm_format_set,
        format: u32,
        modifier: u64,
    ) -> bool;
}
extern "C" {
    pub fn wlr_drm_format_set_add(set: *mut wlr_drm_format_set, format: u32, modifier: u64)
        -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_egl {
    pub platform: EGLenum,
    pub display: EGLDisplay,
    pub config: EGLConfig,
    pub context: EGLContext,
    pub exts_str: *const ::std::os::raw::c_char,
    pub exts: wlr_egl__bindgen_ty_1,
    pub wl_display: *mut wl_display,
    pub dmabuf_formats: wlr_drm_format_set,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_egl__bindgen_ty_1 {
    pub bind_wayland_display_wl: bool,
    pub buffer_age_ext: bool,
    pub image_base_khr: bool,
    pub image_dma_buf_export_mesa: bool,
    pub image_dmabuf_import_ext: bool,
    pub image_dmabuf_import_modifiers_ext: bool,
    pub swap_buffers_with_damage_ext: bool,
    pub swap_buffers_with_damage_khr: bool,
}
#[test]
fn bindgen_test_layout_wlr_egl__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wlr_egl__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(wlr_egl__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_egl__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(wlr_egl__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_egl__bindgen_ty_1>())).bind_wayland_display_wl as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_egl__bindgen_ty_1),
            "::",
            stringify!(bind_wayland_display_wl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_egl__bindgen_ty_1>())).buffer_age_ext as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_egl__bindgen_ty_1),
            "::",
            stringify!(buffer_age_ext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_egl__bindgen_ty_1>())).image_base_khr as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_egl__bindgen_ty_1),
            "::",
            stringify!(image_base_khr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_egl__bindgen_ty_1>())).image_dma_buf_export_mesa as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_egl__bindgen_ty_1),
            "::",
            stringify!(image_dma_buf_export_mesa)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_egl__bindgen_ty_1>())).image_dmabuf_import_ext as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_egl__bindgen_ty_1),
            "::",
            stringify!(image_dmabuf_import_ext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_egl__bindgen_ty_1>())).image_dmabuf_import_modifiers_ext
                as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_egl__bindgen_ty_1),
            "::",
            stringify!(image_dmabuf_import_modifiers_ext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_egl__bindgen_ty_1>())).swap_buffers_with_damage_ext
                as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_egl__bindgen_ty_1),
            "::",
            stringify!(swap_buffers_with_damage_ext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_egl__bindgen_ty_1>())).swap_buffers_with_damage_khr
                as *const _ as usize
        },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_egl__bindgen_ty_1),
            "::",
            stringify!(swap_buffers_with_damage_khr)
        )
    );
}
#[test]
fn bindgen_test_layout_wlr_egl() {
    assert_eq!(
        ::std::mem::size_of::<wlr_egl>(),
        80usize,
        concat!("Size of: ", stringify!(wlr_egl))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_egl>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_egl))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_egl>())).platform as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_egl),
            "::",
            stringify!(platform)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_egl>())).display as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_egl),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_egl>())).config as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_egl),
            "::",
            stringify!(config)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_egl>())).context as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_egl),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_egl>())).exts_str as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_egl),
            "::",
            stringify!(exts_str)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_egl>())).exts as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_egl),
            "::",
            stringify!(exts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_egl>())).wl_display as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_egl),
            "::",
            stringify!(wl_display)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_egl>())).dmabuf_formats as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_egl),
            "::",
            stringify!(dmabuf_formats)
        )
    );
}
extern "C" {
    #[doc = " Initializes an EGL context for the given platform and remote display."]
    #[doc = " Will attempt to load all possibly required api functions."]
    pub fn wlr_egl_init(
        egl: *mut wlr_egl,
        platform: EGLenum,
        remote_display: *mut ::std::os::raw::c_void,
        config_attribs: *mut EGLint,
        visual_id: EGLint,
    ) -> bool;
}
extern "C" {
    #[doc = " Frees all related EGL resources, makes the context not-current and"]
    #[doc = " unbinds a bound wayland display."]
    pub fn wlr_egl_finish(egl: *mut wlr_egl);
}
extern "C" {
    #[doc = " Binds the given display to the EGL instance."]
    #[doc = " This will allow clients to create EGL surfaces from wayland ones and render"]
    #[doc = " to it."]
    pub fn wlr_egl_bind_display(egl: *mut wlr_egl, local_display: *mut wl_display) -> bool;
}
extern "C" {
    #[doc = " Returns a surface for the given native window"]
    #[doc = " The window must match the remote display the wlr_egl was created with."]
    pub fn wlr_egl_create_surface(
        egl: *mut wlr_egl,
        window: *mut ::std::os::raw::c_void,
    ) -> EGLSurface;
}
extern "C" {
    #[doc = " Creates an EGL image from the given wl_drm buffer resource."]
    pub fn wlr_egl_create_image_from_wl_drm(
        egl: *mut wlr_egl,
        data: *mut wl_resource,
        fmt: *mut EGLint,
        width: *mut ::std::os::raw::c_int,
        height: *mut ::std::os::raw::c_int,
        inverted_y: *mut bool,
    ) -> EGLImageKHR;
}
extern "C" {
    #[doc = " Creates an EGL image from the given dmabuf attributes. Check usability"]
    #[doc = " of the dmabuf with wlr_egl_check_import_dmabuf once first."]
    pub fn wlr_egl_create_image_from_dmabuf(
        egl: *mut wlr_egl,
        attributes: *mut wlr_dmabuf_attributes,
    ) -> EGLImageKHR;
}
extern "C" {
    #[doc = " Get the available dmabuf formats"]
    pub fn wlr_egl_get_dmabuf_formats(egl: *mut wlr_egl) -> *const wlr_drm_format_set;
}
extern "C" {
    pub fn wlr_egl_export_image_to_dmabuf(
        egl: *mut wlr_egl,
        image: EGLImageKHR,
        width: i32,
        height: i32,
        flags: u32,
        attribs: *mut wlr_dmabuf_attributes,
    ) -> bool;
}
extern "C" {
    #[doc = " Destroys an EGL image created with the given wlr_egl."]
    pub fn wlr_egl_destroy_image(egl: *mut wlr_egl, image: EGLImageKHR) -> bool;
}
extern "C" {
    pub fn wlr_egl_make_current(
        egl: *mut wlr_egl,
        surface: EGLSurface,
        buffer_age: *mut ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn wlr_egl_is_current(egl: *mut wlr_egl) -> bool;
}
extern "C" {
    pub fn wlr_egl_swap_buffers(
        egl: *mut wlr_egl,
        surface: EGLSurface,
        damage: *mut pixman_region32_t,
    ) -> bool;
}
extern "C" {
    pub fn wlr_egl_destroy_surface(egl: *mut wlr_egl, surface: EGLSurface) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_backend_impl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_backend {
    pub impl_: *const wlr_backend_impl,
    pub events: wlr_backend__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_backend__bindgen_ty_1 {
    #[doc = " Raised when destroyed, passed the wlr_backend reference"]
    pub destroy: wl_signal,
    #[doc = " Raised when new inputs are added, passed the wlr_input_device"]
    pub new_input: wl_signal,
    #[doc = " Raised when new outputs are added, passed the wlr_output"]
    pub new_output: wl_signal,
}
#[test]
fn bindgen_test_layout_wlr_backend__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wlr_backend__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(wlr_backend__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_backend__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_backend__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_backend__bindgen_ty_1>())).destroy as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_backend__bindgen_ty_1),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_backend__bindgen_ty_1>())).new_input as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_backend__bindgen_ty_1),
            "::",
            stringify!(new_input)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_backend__bindgen_ty_1>())).new_output as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_backend__bindgen_ty_1),
            "::",
            stringify!(new_output)
        )
    );
}
#[test]
fn bindgen_test_layout_wlr_backend() {
    assert_eq!(
        ::std::mem::size_of::<wlr_backend>(),
        56usize,
        concat!("Size of: ", stringify!(wlr_backend))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_backend>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_backend))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_backend>())).impl_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_backend),
            "::",
            stringify!(impl_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_backend>())).events as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_backend),
            "::",
            stringify!(events)
        )
    );
}
pub type wlr_renderer_create_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        egl: *mut wlr_egl,
        platform: EGLenum,
        remote_display: *mut ::std::os::raw::c_void,
        config_attribs: *mut EGLint,
        visual_id: EGLint,
    ) -> *mut wlr_renderer,
>;
extern "C" {
    #[doc = " Automatically initializes the most suitable backend given the environment."]
    #[doc = " Will always return a multibackend. The backend is created but not started."]
    #[doc = " Returns NULL on failure."]
    #[doc = ""]
    #[doc = " The compositor can request to initialize the backend's renderer by setting"]
    #[doc = " the create_render_func. The callback must initialize the given wlr_egl and"]
    #[doc = " return a valid wlr_renderer, or NULL if it has failed to initiaze it."]
    #[doc = " Pass NULL as create_renderer_func to use the backend's default renderer."]
    pub fn wlr_backend_autocreate(
        display: *mut wl_display,
        create_renderer_func: wlr_renderer_create_func_t,
    ) -> *mut wlr_backend;
}
extern "C" {
    #[doc = " Start the backend. This may signal new_input or new_output immediately, but"]
    #[doc = " may also wait until the display's event loop begins. Returns false on"]
    #[doc = " failure."]
    pub fn wlr_backend_start(backend: *mut wlr_backend) -> bool;
}
extern "C" {
    #[doc = " Destroy the backend and clean up all of its resources. Normally called"]
    #[doc = " automatically when the wl_display is destroyed."]
    pub fn wlr_backend_destroy(backend: *mut wlr_backend);
}
extern "C" {
    #[doc = " Obtains the wlr_renderer reference this backend is using."]
    pub fn wlr_backend_get_renderer(backend: *mut wlr_backend) -> *mut wlr_renderer;
}
extern "C" {
    #[doc = " Obtains the wlr_session reference from this backend if there is any."]
    #[doc = " Might return NULL for backends that don't use a session."]
    pub fn wlr_backend_get_session(backend: *mut wlr_backend) -> *mut wlr_session;
}
extern "C" {
    #[doc = " Returns the clock used by the backend for presentation feedback."]
    pub fn wlr_backend_get_presentation_clock(backend: *mut wlr_backend) -> clockid_t;
}
pub mod idtype_t {
    pub type Type = u32;
    pub const P_ALL: Type = 0;
    pub const P_PID: Type = 1;
    pub const P_PGID: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).rem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    assert_eq!(
        ::std::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::std::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).fptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).state as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_type as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_deg as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_sep as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).end_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    assert_eq!(
        ::std::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::std::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__old_x as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__c as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__init as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__a as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(__alignment: usize, __size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libinput {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libinput_device {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libinput_device_group {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libinput_seat {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libinput_tablet_tool {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libinput_event {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libinput_event_device_notify {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libinput_event_keyboard {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libinput_event_pointer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libinput_event_touch {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libinput_event_tablet_tool {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libinput_event_tablet_pad {
    _unused: [u8; 0],
}
pub mod libinput_log_priority {
    pub type Type = u32;
    pub const LIBINPUT_LOG_PRIORITY_DEBUG: Type = 10;
    pub const LIBINPUT_LOG_PRIORITY_INFO: Type = 20;
    pub const LIBINPUT_LOG_PRIORITY_ERROR: Type = 30;
}
pub mod libinput_device_capability {
    pub type Type = u32;
    pub const LIBINPUT_DEVICE_CAP_KEYBOARD: Type = 0;
    pub const LIBINPUT_DEVICE_CAP_POINTER: Type = 1;
    pub const LIBINPUT_DEVICE_CAP_TOUCH: Type = 2;
    pub const LIBINPUT_DEVICE_CAP_TABLET_TOOL: Type = 3;
    pub const LIBINPUT_DEVICE_CAP_TABLET_PAD: Type = 4;
    pub const LIBINPUT_DEVICE_CAP_GESTURE: Type = 5;
    pub const LIBINPUT_DEVICE_CAP_SWITCH: Type = 6;
}
pub mod libinput_key_state {
    pub type Type = u32;
    pub const LIBINPUT_KEY_STATE_RELEASED: Type = 0;
    pub const LIBINPUT_KEY_STATE_PRESSED: Type = 1;
}
pub mod libinput_led {
    pub type Type = u32;
    pub const LIBINPUT_LED_NUM_LOCK: Type = 1;
    pub const LIBINPUT_LED_CAPS_LOCK: Type = 2;
    pub const LIBINPUT_LED_SCROLL_LOCK: Type = 4;
}
pub mod libinput_button_state {
    pub type Type = u32;
    pub const LIBINPUT_BUTTON_STATE_RELEASED: Type = 0;
    pub const LIBINPUT_BUTTON_STATE_PRESSED: Type = 1;
}
pub mod libinput_pointer_axis {
    pub type Type = u32;
    pub const LIBINPUT_POINTER_AXIS_SCROLL_VERTICAL: Type = 0;
    pub const LIBINPUT_POINTER_AXIS_SCROLL_HORIZONTAL: Type = 1;
}
pub mod libinput_pointer_axis_source {
    pub type Type = u32;
    pub const LIBINPUT_POINTER_AXIS_SOURCE_WHEEL: Type = 1;
    pub const LIBINPUT_POINTER_AXIS_SOURCE_FINGER: Type = 2;
    pub const LIBINPUT_POINTER_AXIS_SOURCE_CONTINUOUS: Type = 3;
    pub const LIBINPUT_POINTER_AXIS_SOURCE_WHEEL_TILT: Type = 4;
}
pub mod libinput_tablet_pad_ring_axis_source {
    pub type Type = u32;
    pub const LIBINPUT_TABLET_PAD_RING_SOURCE_UNKNOWN: Type = 1;
    pub const LIBINPUT_TABLET_PAD_RING_SOURCE_FINGER: Type = 2;
}
pub mod libinput_tablet_pad_strip_axis_source {
    pub type Type = u32;
    pub const LIBINPUT_TABLET_PAD_STRIP_SOURCE_UNKNOWN: Type = 1;
    pub const LIBINPUT_TABLET_PAD_STRIP_SOURCE_FINGER: Type = 2;
}
pub mod libinput_tablet_tool_type {
    pub type Type = u32;
    pub const LIBINPUT_TABLET_TOOL_TYPE_PEN: Type = 1;
    pub const LIBINPUT_TABLET_TOOL_TYPE_ERASER: Type = 2;
    pub const LIBINPUT_TABLET_TOOL_TYPE_BRUSH: Type = 3;
    pub const LIBINPUT_TABLET_TOOL_TYPE_PENCIL: Type = 4;
    pub const LIBINPUT_TABLET_TOOL_TYPE_AIRBRUSH: Type = 5;
    pub const LIBINPUT_TABLET_TOOL_TYPE_MOUSE: Type = 6;
    pub const LIBINPUT_TABLET_TOOL_TYPE_LENS: Type = 7;
}
pub mod libinput_tablet_tool_proximity_state {
    pub type Type = u32;
    pub const LIBINPUT_TABLET_TOOL_PROXIMITY_STATE_OUT: Type = 0;
    pub const LIBINPUT_TABLET_TOOL_PROXIMITY_STATE_IN: Type = 1;
}
pub mod libinput_tablet_tool_tip_state {
    pub type Type = u32;
    pub const LIBINPUT_TABLET_TOOL_TIP_UP: Type = 0;
    pub const LIBINPUT_TABLET_TOOL_TIP_DOWN: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libinput_tablet_pad_mode_group {
    _unused: [u8; 0],
}
extern "C" {
    pub fn libinput_device_tablet_pad_get_num_mode_groups(
        device: *mut libinput_device,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libinput_device_tablet_pad_get_mode_group(
        device: *mut libinput_device,
        index: ::std::os::raw::c_uint,
    ) -> *mut libinput_tablet_pad_mode_group;
}
extern "C" {
    pub fn libinput_tablet_pad_mode_group_get_index(
        group: *mut libinput_tablet_pad_mode_group,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn libinput_tablet_pad_mode_group_get_num_modes(
        group: *mut libinput_tablet_pad_mode_group,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn libinput_tablet_pad_mode_group_get_mode(
        group: *mut libinput_tablet_pad_mode_group,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn libinput_tablet_pad_mode_group_has_button(
        group: *mut libinput_tablet_pad_mode_group,
        button: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libinput_tablet_pad_mode_group_has_ring(
        group: *mut libinput_tablet_pad_mode_group,
        ring: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libinput_tablet_pad_mode_group_has_strip(
        group: *mut libinput_tablet_pad_mode_group,
        strip: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libinput_tablet_pad_mode_group_button_is_toggle(
        group: *mut libinput_tablet_pad_mode_group,
        button: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libinput_tablet_pad_mode_group_ref(
        group: *mut libinput_tablet_pad_mode_group,
    ) -> *mut libinput_tablet_pad_mode_group;
}
extern "C" {
    pub fn libinput_tablet_pad_mode_group_unref(
        group: *mut libinput_tablet_pad_mode_group,
    ) -> *mut libinput_tablet_pad_mode_group;
}
extern "C" {
    pub fn libinput_tablet_pad_mode_group_set_user_data(
        group: *mut libinput_tablet_pad_mode_group,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn libinput_tablet_pad_mode_group_get_user_data(
        group: *mut libinput_tablet_pad_mode_group,
    ) -> *mut ::std::os::raw::c_void;
}
pub mod libinput_switch_state {
    pub type Type = u32;
    pub const LIBINPUT_SWITCH_STATE_OFF: Type = 0;
    pub const LIBINPUT_SWITCH_STATE_ON: Type = 1;
}
pub mod libinput_switch {
    pub type Type = u32;
    pub const LIBINPUT_SWITCH_LID: Type = 1;
    pub const LIBINPUT_SWITCH_TABLET_MODE: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libinput_event_switch {
    _unused: [u8; 0],
}
pub mod libinput_event_type {
    pub type Type = u32;
    pub const LIBINPUT_EVENT_NONE: Type = 0;
    pub const LIBINPUT_EVENT_DEVICE_ADDED: Type = 1;
    pub const LIBINPUT_EVENT_DEVICE_REMOVED: Type = 2;
    pub const LIBINPUT_EVENT_KEYBOARD_KEY: Type = 300;
    pub const LIBINPUT_EVENT_POINTER_MOTION: Type = 400;
    pub const LIBINPUT_EVENT_POINTER_MOTION_ABSOLUTE: Type = 401;
    pub const LIBINPUT_EVENT_POINTER_BUTTON: Type = 402;
    pub const LIBINPUT_EVENT_POINTER_AXIS: Type = 403;
    pub const LIBINPUT_EVENT_TOUCH_DOWN: Type = 500;
    pub const LIBINPUT_EVENT_TOUCH_UP: Type = 501;
    pub const LIBINPUT_EVENT_TOUCH_MOTION: Type = 502;
    pub const LIBINPUT_EVENT_TOUCH_CANCEL: Type = 503;
    pub const LIBINPUT_EVENT_TOUCH_FRAME: Type = 504;
    pub const LIBINPUT_EVENT_TABLET_TOOL_AXIS: Type = 600;
    pub const LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY: Type = 601;
    pub const LIBINPUT_EVENT_TABLET_TOOL_TIP: Type = 602;
    pub const LIBINPUT_EVENT_TABLET_TOOL_BUTTON: Type = 603;
    pub const LIBINPUT_EVENT_TABLET_PAD_BUTTON: Type = 700;
    pub const LIBINPUT_EVENT_TABLET_PAD_RING: Type = 701;
    pub const LIBINPUT_EVENT_TABLET_PAD_STRIP: Type = 702;
    pub const LIBINPUT_EVENT_GESTURE_SWIPE_BEGIN: Type = 800;
    pub const LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE: Type = 801;
    pub const LIBINPUT_EVENT_GESTURE_SWIPE_END: Type = 802;
    pub const LIBINPUT_EVENT_GESTURE_PINCH_BEGIN: Type = 803;
    pub const LIBINPUT_EVENT_GESTURE_PINCH_UPDATE: Type = 804;
    pub const LIBINPUT_EVENT_GESTURE_PINCH_END: Type = 805;
    pub const LIBINPUT_EVENT_SWITCH_TOGGLE: Type = 900;
}
extern "C" {
    pub fn libinput_event_destroy(event: *mut libinput_event);
}
extern "C" {
    pub fn libinput_event_get_type(event: *mut libinput_event) -> libinput_event_type::Type;
}
extern "C" {
    pub fn libinput_event_get_context(event: *mut libinput_event) -> *mut libinput;
}
extern "C" {
    pub fn libinput_event_get_device(event: *mut libinput_event) -> *mut libinput_device;
}
extern "C" {
    pub fn libinput_event_get_pointer_event(
        event: *mut libinput_event,
    ) -> *mut libinput_event_pointer;
}
extern "C" {
    pub fn libinput_event_get_keyboard_event(
        event: *mut libinput_event,
    ) -> *mut libinput_event_keyboard;
}
extern "C" {
    pub fn libinput_event_get_touch_event(event: *mut libinput_event) -> *mut libinput_event_touch;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libinput_event_gesture {
    _unused: [u8; 0],
}
extern "C" {
    pub fn libinput_event_get_gesture_event(
        event: *mut libinput_event,
    ) -> *mut libinput_event_gesture;
}
extern "C" {
    pub fn libinput_event_get_tablet_tool_event(
        event: *mut libinput_event,
    ) -> *mut libinput_event_tablet_tool;
}
extern "C" {
    pub fn libinput_event_get_tablet_pad_event(
        event: *mut libinput_event,
    ) -> *mut libinput_event_tablet_pad;
}
extern "C" {
    pub fn libinput_event_get_switch_event(
        event: *mut libinput_event,
    ) -> *mut libinput_event_switch;
}
extern "C" {
    pub fn libinput_event_get_device_notify_event(
        event: *mut libinput_event,
    ) -> *mut libinput_event_device_notify;
}
extern "C" {
    pub fn libinput_event_device_notify_get_base_event(
        event: *mut libinput_event_device_notify,
    ) -> *mut libinput_event;
}
extern "C" {
    pub fn libinput_event_keyboard_get_time(event: *mut libinput_event_keyboard) -> u32;
}
extern "C" {
    pub fn libinput_event_keyboard_get_time_usec(event: *mut libinput_event_keyboard) -> u64;
}
extern "C" {
    pub fn libinput_event_keyboard_get_key(event: *mut libinput_event_keyboard) -> u32;
}
extern "C" {
    pub fn libinput_event_keyboard_get_key_state(
        event: *mut libinput_event_keyboard,
    ) -> libinput_key_state::Type;
}
extern "C" {
    pub fn libinput_event_keyboard_get_base_event(
        event: *mut libinput_event_keyboard,
    ) -> *mut libinput_event;
}
extern "C" {
    pub fn libinput_event_keyboard_get_seat_key_count(event: *mut libinput_event_keyboard) -> u32;
}
extern "C" {
    pub fn libinput_event_pointer_get_time(event: *mut libinput_event_pointer) -> u32;
}
extern "C" {
    pub fn libinput_event_pointer_get_time_usec(event: *mut libinput_event_pointer) -> u64;
}
extern "C" {
    pub fn libinput_event_pointer_get_dx(event: *mut libinput_event_pointer) -> f64;
}
extern "C" {
    pub fn libinput_event_pointer_get_dy(event: *mut libinput_event_pointer) -> f64;
}
extern "C" {
    pub fn libinput_event_pointer_get_dx_unaccelerated(event: *mut libinput_event_pointer) -> f64;
}
extern "C" {
    pub fn libinput_event_pointer_get_dy_unaccelerated(event: *mut libinput_event_pointer) -> f64;
}
extern "C" {
    pub fn libinput_event_pointer_get_absolute_x(event: *mut libinput_event_pointer) -> f64;
}
extern "C" {
    pub fn libinput_event_pointer_get_absolute_y(event: *mut libinput_event_pointer) -> f64;
}
extern "C" {
    pub fn libinput_event_pointer_get_absolute_x_transformed(
        event: *mut libinput_event_pointer,
        width: u32,
    ) -> f64;
}
extern "C" {
    pub fn libinput_event_pointer_get_absolute_y_transformed(
        event: *mut libinput_event_pointer,
        height: u32,
    ) -> f64;
}
extern "C" {
    pub fn libinput_event_pointer_get_button(event: *mut libinput_event_pointer) -> u32;
}
extern "C" {
    pub fn libinput_event_pointer_get_button_state(
        event: *mut libinput_event_pointer,
    ) -> libinput_button_state::Type;
}
extern "C" {
    pub fn libinput_event_pointer_get_seat_button_count(event: *mut libinput_event_pointer) -> u32;
}
extern "C" {
    pub fn libinput_event_pointer_has_axis(
        event: *mut libinput_event_pointer,
        axis: libinput_pointer_axis::Type,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libinput_event_pointer_get_axis_value(
        event: *mut libinput_event_pointer,
        axis: libinput_pointer_axis::Type,
    ) -> f64;
}
extern "C" {
    pub fn libinput_event_pointer_get_axis_source(
        event: *mut libinput_event_pointer,
    ) -> libinput_pointer_axis_source::Type;
}
extern "C" {
    pub fn libinput_event_pointer_get_axis_value_discrete(
        event: *mut libinput_event_pointer,
        axis: libinput_pointer_axis::Type,
    ) -> f64;
}
extern "C" {
    pub fn libinput_event_pointer_get_base_event(
        event: *mut libinput_event_pointer,
    ) -> *mut libinput_event;
}
extern "C" {
    pub fn libinput_event_touch_get_time(event: *mut libinput_event_touch) -> u32;
}
extern "C" {
    pub fn libinput_event_touch_get_time_usec(event: *mut libinput_event_touch) -> u64;
}
extern "C" {
    pub fn libinput_event_touch_get_slot(event: *mut libinput_event_touch) -> i32;
}
extern "C" {
    pub fn libinput_event_touch_get_seat_slot(event: *mut libinput_event_touch) -> i32;
}
extern "C" {
    pub fn libinput_event_touch_get_x(event: *mut libinput_event_touch) -> f64;
}
extern "C" {
    pub fn libinput_event_touch_get_y(event: *mut libinput_event_touch) -> f64;
}
extern "C" {
    pub fn libinput_event_touch_get_x_transformed(
        event: *mut libinput_event_touch,
        width: u32,
    ) -> f64;
}
extern "C" {
    pub fn libinput_event_touch_get_y_transformed(
        event: *mut libinput_event_touch,
        height: u32,
    ) -> f64;
}
extern "C" {
    pub fn libinput_event_touch_get_base_event(
        event: *mut libinput_event_touch,
    ) -> *mut libinput_event;
}
extern "C" {
    pub fn libinput_event_gesture_get_time(event: *mut libinput_event_gesture) -> u32;
}
extern "C" {
    pub fn libinput_event_gesture_get_time_usec(event: *mut libinput_event_gesture) -> u64;
}
extern "C" {
    pub fn libinput_event_gesture_get_base_event(
        event: *mut libinput_event_gesture,
    ) -> *mut libinput_event;
}
extern "C" {
    pub fn libinput_event_gesture_get_finger_count(
        event: *mut libinput_event_gesture,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libinput_event_gesture_get_cancelled(
        event: *mut libinput_event_gesture,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libinput_event_gesture_get_dx(event: *mut libinput_event_gesture) -> f64;
}
extern "C" {
    pub fn libinput_event_gesture_get_dy(event: *mut libinput_event_gesture) -> f64;
}
extern "C" {
    pub fn libinput_event_gesture_get_dx_unaccelerated(event: *mut libinput_event_gesture) -> f64;
}
extern "C" {
    pub fn libinput_event_gesture_get_dy_unaccelerated(event: *mut libinput_event_gesture) -> f64;
}
extern "C" {
    pub fn libinput_event_gesture_get_scale(event: *mut libinput_event_gesture) -> f64;
}
extern "C" {
    pub fn libinput_event_gesture_get_angle_delta(event: *mut libinput_event_gesture) -> f64;
}
extern "C" {
    pub fn libinput_event_tablet_tool_get_base_event(
        event: *mut libinput_event_tablet_tool,
    ) -> *mut libinput_event;
}
extern "C" {
    pub fn libinput_event_tablet_tool_x_has_changed(
        event: *mut libinput_event_tablet_tool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libinput_event_tablet_tool_y_has_changed(
        event: *mut libinput_event_tablet_tool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libinput_event_tablet_tool_pressure_has_changed(
        event: *mut libinput_event_tablet_tool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libinput_event_tablet_tool_distance_has_changed(
        event: *mut libinput_event_tablet_tool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libinput_event_tablet_tool_tilt_x_has_changed(
        event: *mut libinput_event_tablet_tool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libinput_event_tablet_tool_tilt_y_has_changed(
        event: *mut libinput_event_tablet_tool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libinput_event_tablet_tool_rotation_has_changed(
        event: *mut libinput_event_tablet_tool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libinput_event_tablet_tool_slider_has_changed(
        event: *mut libinput_event_tablet_tool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libinput_event_tablet_tool_wheel_has_changed(
        event: *mut libinput_event_tablet_tool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libinput_event_tablet_tool_get_x(event: *mut libinput_event_tablet_tool) -> f64;
}
extern "C" {
    pub fn libinput_event_tablet_tool_get_y(event: *mut libinput_event_tablet_tool) -> f64;
}
extern "C" {
    pub fn libinput_event_tablet_tool_get_dx(event: *mut libinput_event_tablet_tool) -> f64;
}
extern "C" {
    pub fn libinput_event_tablet_tool_get_dy(event: *mut libinput_event_tablet_tool) -> f64;
}
extern "C" {
    pub fn libinput_event_tablet_tool_get_pressure(event: *mut libinput_event_tablet_tool) -> f64;
}
extern "C" {
    pub fn libinput_event_tablet_tool_get_distance(event: *mut libinput_event_tablet_tool) -> f64;
}
extern "C" {
    pub fn libinput_event_tablet_tool_get_tilt_x(event: *mut libinput_event_tablet_tool) -> f64;
}
extern "C" {
    pub fn libinput_event_tablet_tool_get_tilt_y(event: *mut libinput_event_tablet_tool) -> f64;
}
extern "C" {
    pub fn libinput_event_tablet_tool_get_rotation(event: *mut libinput_event_tablet_tool) -> f64;
}
extern "C" {
    pub fn libinput_event_tablet_tool_get_slider_position(
        event: *mut libinput_event_tablet_tool,
    ) -> f64;
}
extern "C" {
    pub fn libinput_event_tablet_tool_get_wheel_delta(
        event: *mut libinput_event_tablet_tool,
    ) -> f64;
}
extern "C" {
    pub fn libinput_event_tablet_tool_get_wheel_delta_discrete(
        event: *mut libinput_event_tablet_tool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libinput_event_tablet_tool_get_x_transformed(
        event: *mut libinput_event_tablet_tool,
        width: u32,
    ) -> f64;
}
extern "C" {
    pub fn libinput_event_tablet_tool_get_y_transformed(
        event: *mut libinput_event_tablet_tool,
        height: u32,
    ) -> f64;
}
extern "C" {
    pub fn libinput_event_tablet_tool_get_tool(
        event: *mut libinput_event_tablet_tool,
    ) -> *mut libinput_tablet_tool;
}
extern "C" {
    pub fn libinput_event_tablet_tool_get_proximity_state(
        event: *mut libinput_event_tablet_tool,
    ) -> libinput_tablet_tool_proximity_state::Type;
}
extern "C" {
    pub fn libinput_event_tablet_tool_get_tip_state(
        event: *mut libinput_event_tablet_tool,
    ) -> libinput_tablet_tool_tip_state::Type;
}
extern "C" {
    pub fn libinput_event_tablet_tool_get_button(event: *mut libinput_event_tablet_tool) -> u32;
}
extern "C" {
    pub fn libinput_event_tablet_tool_get_button_state(
        event: *mut libinput_event_tablet_tool,
    ) -> libinput_button_state::Type;
}
extern "C" {
    pub fn libinput_event_tablet_tool_get_seat_button_count(
        event: *mut libinput_event_tablet_tool,
    ) -> u32;
}
extern "C" {
    pub fn libinput_event_tablet_tool_get_time(event: *mut libinput_event_tablet_tool) -> u32;
}
extern "C" {
    pub fn libinput_event_tablet_tool_get_time_usec(event: *mut libinput_event_tablet_tool) -> u64;
}
extern "C" {
    pub fn libinput_tablet_tool_get_type(
        tool: *mut libinput_tablet_tool,
    ) -> libinput_tablet_tool_type::Type;
}
extern "C" {
    pub fn libinput_tablet_tool_get_tool_id(tool: *mut libinput_tablet_tool) -> u64;
}
extern "C" {
    pub fn libinput_tablet_tool_ref(tool: *mut libinput_tablet_tool) -> *mut libinput_tablet_tool;
}
extern "C" {
    pub fn libinput_tablet_tool_unref(tool: *mut libinput_tablet_tool)
        -> *mut libinput_tablet_tool;
}
extern "C" {
    pub fn libinput_tablet_tool_has_pressure(
        tool: *mut libinput_tablet_tool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libinput_tablet_tool_has_distance(
        tool: *mut libinput_tablet_tool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libinput_tablet_tool_has_tilt(tool: *mut libinput_tablet_tool) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libinput_tablet_tool_has_rotation(
        tool: *mut libinput_tablet_tool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libinput_tablet_tool_has_slider(
        tool: *mut libinput_tablet_tool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libinput_tablet_tool_has_wheel(tool: *mut libinput_tablet_tool)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libinput_tablet_tool_has_button(
        tool: *mut libinput_tablet_tool,
        code: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libinput_tablet_tool_is_unique(tool: *mut libinput_tablet_tool)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libinput_tablet_tool_get_serial(tool: *mut libinput_tablet_tool) -> u64;
}
extern "C" {
    pub fn libinput_tablet_tool_get_user_data(
        tool: *mut libinput_tablet_tool,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn libinput_tablet_tool_set_user_data(
        tool: *mut libinput_tablet_tool,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn libinput_event_tablet_pad_get_base_event(
        event: *mut libinput_event_tablet_pad,
    ) -> *mut libinput_event;
}
extern "C" {
    pub fn libinput_event_tablet_pad_get_ring_position(
        event: *mut libinput_event_tablet_pad,
    ) -> f64;
}
extern "C" {
    pub fn libinput_event_tablet_pad_get_ring_number(
        event: *mut libinput_event_tablet_pad,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn libinput_event_tablet_pad_get_ring_source(
        event: *mut libinput_event_tablet_pad,
    ) -> libinput_tablet_pad_ring_axis_source::Type;
}
extern "C" {
    pub fn libinput_event_tablet_pad_get_strip_position(
        event: *mut libinput_event_tablet_pad,
    ) -> f64;
}
extern "C" {
    pub fn libinput_event_tablet_pad_get_strip_number(
        event: *mut libinput_event_tablet_pad,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn libinput_event_tablet_pad_get_strip_source(
        event: *mut libinput_event_tablet_pad,
    ) -> libinput_tablet_pad_strip_axis_source::Type;
}
extern "C" {
    pub fn libinput_event_tablet_pad_get_button_number(
        event: *mut libinput_event_tablet_pad,
    ) -> u32;
}
extern "C" {
    pub fn libinput_event_tablet_pad_get_button_state(
        event: *mut libinput_event_tablet_pad,
    ) -> libinput_button_state::Type;
}
extern "C" {
    pub fn libinput_event_tablet_pad_get_mode(
        event: *mut libinput_event_tablet_pad,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn libinput_event_tablet_pad_get_mode_group(
        event: *mut libinput_event_tablet_pad,
    ) -> *mut libinput_tablet_pad_mode_group;
}
extern "C" {
    pub fn libinput_event_tablet_pad_get_time(event: *mut libinput_event_tablet_pad) -> u32;
}
extern "C" {
    pub fn libinput_event_tablet_pad_get_time_usec(event: *mut libinput_event_tablet_pad) -> u64;
}
extern "C" {
    pub fn libinput_event_switch_get_switch(
        event: *mut libinput_event_switch,
    ) -> libinput_switch::Type;
}
extern "C" {
    pub fn libinput_event_switch_get_switch_state(
        event: *mut libinput_event_switch,
    ) -> libinput_switch_state::Type;
}
extern "C" {
    pub fn libinput_event_switch_get_base_event(
        event: *mut libinput_event_switch,
    ) -> *mut libinput_event;
}
extern "C" {
    pub fn libinput_event_switch_get_time(event: *mut libinput_event_switch) -> u32;
}
extern "C" {
    pub fn libinput_event_switch_get_time_usec(event: *mut libinput_event_switch) -> u64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libinput_interface {
    pub open_restricted: ::std::option::Option<
        unsafe extern "C" fn(
            path: *const ::std::os::raw::c_char,
            flags: ::std::os::raw::c_int,
            user_data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub close_restricted: ::std::option::Option<
        unsafe extern "C" fn(fd: ::std::os::raw::c_int, user_data: *mut ::std::os::raw::c_void),
    >,
}
#[test]
fn bindgen_test_layout_libinput_interface() {
    assert_eq!(
        ::std::mem::size_of::<libinput_interface>(),
        16usize,
        concat!("Size of: ", stringify!(libinput_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<libinput_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(libinput_interface))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libinput_interface>())).open_restricted as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libinput_interface),
            "::",
            stringify!(open_restricted)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libinput_interface>())).close_restricted as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(libinput_interface),
            "::",
            stringify!(close_restricted)
        )
    );
}
extern "C" {
    pub fn libinput_udev_create_context(
        interface: *const libinput_interface,
        user_data: *mut ::std::os::raw::c_void,
        udev: *mut udev,
    ) -> *mut libinput;
}
extern "C" {
    pub fn libinput_udev_assign_seat(
        libinput: *mut libinput,
        seat_id: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libinput_path_create_context(
        interface: *const libinput_interface,
        user_data: *mut ::std::os::raw::c_void,
    ) -> *mut libinput;
}
extern "C" {
    pub fn libinput_path_add_device(
        libinput: *mut libinput,
        path: *const ::std::os::raw::c_char,
    ) -> *mut libinput_device;
}
extern "C" {
    pub fn libinput_path_remove_device(device: *mut libinput_device);
}
extern "C" {
    pub fn libinput_get_fd(libinput: *mut libinput) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libinput_dispatch(libinput: *mut libinput) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libinput_get_event(libinput: *mut libinput) -> *mut libinput_event;
}
extern "C" {
    pub fn libinput_next_event_type(libinput: *mut libinput) -> libinput_event_type::Type;
}
extern "C" {
    pub fn libinput_set_user_data(libinput: *mut libinput, user_data: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn libinput_get_user_data(libinput: *mut libinput) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn libinput_resume(libinput: *mut libinput) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libinput_suspend(libinput: *mut libinput);
}
extern "C" {
    pub fn libinput_ref(libinput: *mut libinput) -> *mut libinput;
}
extern "C" {
    pub fn libinput_unref(libinput: *mut libinput) -> *mut libinput;
}
extern "C" {
    pub fn libinput_log_set_priority(
        libinput: *mut libinput,
        priority: libinput_log_priority::Type,
    );
}
extern "C" {
    pub fn libinput_log_get_priority(libinput: *const libinput) -> libinput_log_priority::Type;
}
pub type libinput_log_handler = ::std::option::Option<
    unsafe extern "C" fn(
        libinput: *mut libinput,
        priority: libinput_log_priority::Type,
        format: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ),
>;
extern "C" {
    pub fn libinput_log_set_handler(libinput: *mut libinput, log_handler: libinput_log_handler);
}
extern "C" {
    pub fn libinput_seat_ref(seat: *mut libinput_seat) -> *mut libinput_seat;
}
extern "C" {
    pub fn libinput_seat_unref(seat: *mut libinput_seat) -> *mut libinput_seat;
}
extern "C" {
    pub fn libinput_seat_set_user_data(
        seat: *mut libinput_seat,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn libinput_seat_get_user_data(seat: *mut libinput_seat) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn libinput_seat_get_context(seat: *mut libinput_seat) -> *mut libinput;
}
extern "C" {
    pub fn libinput_seat_get_physical_name(
        seat: *mut libinput_seat,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn libinput_seat_get_logical_name(
        seat: *mut libinput_seat,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn libinput_device_ref(device: *mut libinput_device) -> *mut libinput_device;
}
extern "C" {
    pub fn libinput_device_unref(device: *mut libinput_device) -> *mut libinput_device;
}
extern "C" {
    pub fn libinput_device_set_user_data(
        device: *mut libinput_device,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn libinput_device_get_user_data(
        device: *mut libinput_device,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn libinput_device_get_context(device: *mut libinput_device) -> *mut libinput;
}
extern "C" {
    pub fn libinput_device_get_device_group(
        device: *mut libinput_device,
    ) -> *mut libinput_device_group;
}
extern "C" {
    pub fn libinput_device_get_sysname(
        device: *mut libinput_device,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn libinput_device_get_name(device: *mut libinput_device) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn libinput_device_get_id_product(device: *mut libinput_device) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn libinput_device_get_id_vendor(device: *mut libinput_device) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn libinput_device_get_output_name(
        device: *mut libinput_device,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn libinput_device_get_seat(device: *mut libinput_device) -> *mut libinput_seat;
}
extern "C" {
    pub fn libinput_device_set_seat_logical_name(
        device: *mut libinput_device,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libinput_device_get_udev_device(device: *mut libinput_device) -> *mut udev_device;
}
extern "C" {
    pub fn libinput_device_led_update(device: *mut libinput_device, leds: libinput_led::Type);
}
extern "C" {
    pub fn libinput_device_has_capability(
        device: *mut libinput_device,
        capability: libinput_device_capability::Type,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libinput_device_get_size(
        device: *mut libinput_device,
        width: *mut f64,
        height: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libinput_device_pointer_has_button(
        device: *mut libinput_device,
        code: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libinput_device_keyboard_has_key(
        device: *mut libinput_device,
        code: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libinput_device_touch_get_touch_count(
        device: *mut libinput_device,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libinput_device_switch_has_switch(
        device: *mut libinput_device,
        sw: libinput_switch::Type,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libinput_device_tablet_pad_get_num_buttons(
        device: *mut libinput_device,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libinput_device_tablet_pad_get_num_rings(
        device: *mut libinput_device,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libinput_device_tablet_pad_get_num_strips(
        device: *mut libinput_device,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libinput_device_group_ref(
        group: *mut libinput_device_group,
    ) -> *mut libinput_device_group;
}
extern "C" {
    pub fn libinput_device_group_unref(
        group: *mut libinput_device_group,
    ) -> *mut libinput_device_group;
}
extern "C" {
    pub fn libinput_device_group_set_user_data(
        group: *mut libinput_device_group,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn libinput_device_group_get_user_data(
        group: *mut libinput_device_group,
    ) -> *mut ::std::os::raw::c_void;
}
pub mod libinput_config_status {
    pub type Type = u32;
    pub const LIBINPUT_CONFIG_STATUS_SUCCESS: Type = 0;
    pub const LIBINPUT_CONFIG_STATUS_UNSUPPORTED: Type = 1;
    pub const LIBINPUT_CONFIG_STATUS_INVALID: Type = 2;
}
extern "C" {
    pub fn libinput_config_status_to_str(
        status: libinput_config_status::Type,
    ) -> *const ::std::os::raw::c_char;
}
pub mod libinput_config_tap_state {
    pub type Type = u32;
    pub const LIBINPUT_CONFIG_TAP_DISABLED: Type = 0;
    pub const LIBINPUT_CONFIG_TAP_ENABLED: Type = 1;
}
extern "C" {
    pub fn libinput_device_config_tap_get_finger_count(
        device: *mut libinput_device,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libinput_device_config_tap_set_enabled(
        device: *mut libinput_device,
        enable: libinput_config_tap_state::Type,
    ) -> libinput_config_status::Type;
}
extern "C" {
    pub fn libinput_device_config_tap_get_enabled(
        device: *mut libinput_device,
    ) -> libinput_config_tap_state::Type;
}
extern "C" {
    pub fn libinput_device_config_tap_get_default_enabled(
        device: *mut libinput_device,
    ) -> libinput_config_tap_state::Type;
}
pub mod libinput_config_tap_button_map {
    pub type Type = u32;
    pub const LIBINPUT_CONFIG_TAP_MAP_LRM: Type = 0;
    pub const LIBINPUT_CONFIG_TAP_MAP_LMR: Type = 1;
}
extern "C" {
    pub fn libinput_device_config_tap_set_button_map(
        device: *mut libinput_device,
        map: libinput_config_tap_button_map::Type,
    ) -> libinput_config_status::Type;
}
extern "C" {
    pub fn libinput_device_config_tap_get_button_map(
        device: *mut libinput_device,
    ) -> libinput_config_tap_button_map::Type;
}
extern "C" {
    pub fn libinput_device_config_tap_get_default_button_map(
        device: *mut libinput_device,
    ) -> libinput_config_tap_button_map::Type;
}
pub mod libinput_config_drag_state {
    pub type Type = u32;
    pub const LIBINPUT_CONFIG_DRAG_DISABLED: Type = 0;
    pub const LIBINPUT_CONFIG_DRAG_ENABLED: Type = 1;
}
extern "C" {
    pub fn libinput_device_config_tap_set_drag_enabled(
        device: *mut libinput_device,
        enable: libinput_config_drag_state::Type,
    ) -> libinput_config_status::Type;
}
extern "C" {
    pub fn libinput_device_config_tap_get_drag_enabled(
        device: *mut libinput_device,
    ) -> libinput_config_drag_state::Type;
}
extern "C" {
    pub fn libinput_device_config_tap_get_default_drag_enabled(
        device: *mut libinput_device,
    ) -> libinput_config_drag_state::Type;
}
pub mod libinput_config_drag_lock_state {
    pub type Type = u32;
    pub const LIBINPUT_CONFIG_DRAG_LOCK_DISABLED: Type = 0;
    pub const LIBINPUT_CONFIG_DRAG_LOCK_ENABLED: Type = 1;
}
extern "C" {
    pub fn libinput_device_config_tap_set_drag_lock_enabled(
        device: *mut libinput_device,
        enable: libinput_config_drag_lock_state::Type,
    ) -> libinput_config_status::Type;
}
extern "C" {
    pub fn libinput_device_config_tap_get_drag_lock_enabled(
        device: *mut libinput_device,
    ) -> libinput_config_drag_lock_state::Type;
}
extern "C" {
    pub fn libinput_device_config_tap_get_default_drag_lock_enabled(
        device: *mut libinput_device,
    ) -> libinput_config_drag_lock_state::Type;
}
extern "C" {
    pub fn libinput_device_config_calibration_has_matrix(
        device: *mut libinput_device,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libinput_device_config_calibration_set_matrix(
        device: *mut libinput_device,
        matrix: *const f32,
    ) -> libinput_config_status::Type;
}
extern "C" {
    pub fn libinput_device_config_calibration_get_matrix(
        device: *mut libinput_device,
        matrix: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libinput_device_config_calibration_get_default_matrix(
        device: *mut libinput_device,
        matrix: *mut f32,
    ) -> ::std::os::raw::c_int;
}
pub mod libinput_config_send_events_mode {
    pub type Type = u32;
    pub const LIBINPUT_CONFIG_SEND_EVENTS_ENABLED: Type = 0;
    pub const LIBINPUT_CONFIG_SEND_EVENTS_DISABLED: Type = 1;
    pub const LIBINPUT_CONFIG_SEND_EVENTS_DISABLED_ON_EXTERNAL_MOUSE: Type = 2;
}
extern "C" {
    pub fn libinput_device_config_send_events_get_modes(device: *mut libinput_device) -> u32;
}
extern "C" {
    pub fn libinput_device_config_send_events_set_mode(
        device: *mut libinput_device,
        mode: u32,
    ) -> libinput_config_status::Type;
}
extern "C" {
    pub fn libinput_device_config_send_events_get_mode(device: *mut libinput_device) -> u32;
}
extern "C" {
    pub fn libinput_device_config_send_events_get_default_mode(device: *mut libinput_device)
        -> u32;
}
extern "C" {
    pub fn libinput_device_config_accel_is_available(
        device: *mut libinput_device,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libinput_device_config_accel_set_speed(
        device: *mut libinput_device,
        speed: f64,
    ) -> libinput_config_status::Type;
}
extern "C" {
    pub fn libinput_device_config_accel_get_speed(device: *mut libinput_device) -> f64;
}
extern "C" {
    pub fn libinput_device_config_accel_get_default_speed(device: *mut libinput_device) -> f64;
}
pub mod libinput_config_accel_profile {
    pub type Type = u32;
    pub const LIBINPUT_CONFIG_ACCEL_PROFILE_NONE: Type = 0;
    pub const LIBINPUT_CONFIG_ACCEL_PROFILE_FLAT: Type = 1;
    pub const LIBINPUT_CONFIG_ACCEL_PROFILE_ADAPTIVE: Type = 2;
}
extern "C" {
    pub fn libinput_device_config_accel_get_profiles(device: *mut libinput_device) -> u32;
}
extern "C" {
    pub fn libinput_device_config_accel_set_profile(
        device: *mut libinput_device,
        mode: libinput_config_accel_profile::Type,
    ) -> libinput_config_status::Type;
}
extern "C" {
    pub fn libinput_device_config_accel_get_profile(
        device: *mut libinput_device,
    ) -> libinput_config_accel_profile::Type;
}
extern "C" {
    pub fn libinput_device_config_accel_get_default_profile(
        device: *mut libinput_device,
    ) -> libinput_config_accel_profile::Type;
}
extern "C" {
    pub fn libinput_device_config_scroll_has_natural_scroll(
        device: *mut libinput_device,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libinput_device_config_scroll_set_natural_scroll_enabled(
        device: *mut libinput_device,
        enable: ::std::os::raw::c_int,
    ) -> libinput_config_status::Type;
}
extern "C" {
    pub fn libinput_device_config_scroll_get_natural_scroll_enabled(
        device: *mut libinput_device,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libinput_device_config_scroll_get_default_natural_scroll_enabled(
        device: *mut libinput_device,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libinput_device_config_left_handed_is_available(
        device: *mut libinput_device,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libinput_device_config_left_handed_set(
        device: *mut libinput_device,
        left_handed: ::std::os::raw::c_int,
    ) -> libinput_config_status::Type;
}
extern "C" {
    pub fn libinput_device_config_left_handed_get(
        device: *mut libinput_device,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libinput_device_config_left_handed_get_default(
        device: *mut libinput_device,
    ) -> ::std::os::raw::c_int;
}
pub mod libinput_config_click_method {
    pub type Type = u32;
    pub const LIBINPUT_CONFIG_CLICK_METHOD_NONE: Type = 0;
    pub const LIBINPUT_CONFIG_CLICK_METHOD_BUTTON_AREAS: Type = 1;
    pub const LIBINPUT_CONFIG_CLICK_METHOD_CLICKFINGER: Type = 2;
}
extern "C" {
    pub fn libinput_device_config_click_get_methods(device: *mut libinput_device) -> u32;
}
extern "C" {
    pub fn libinput_device_config_click_set_method(
        device: *mut libinput_device,
        method: libinput_config_click_method::Type,
    ) -> libinput_config_status::Type;
}
extern "C" {
    pub fn libinput_device_config_click_get_method(
        device: *mut libinput_device,
    ) -> libinput_config_click_method::Type;
}
extern "C" {
    pub fn libinput_device_config_click_get_default_method(
        device: *mut libinput_device,
    ) -> libinput_config_click_method::Type;
}
pub mod libinput_config_middle_emulation_state {
    pub type Type = u32;
    pub const LIBINPUT_CONFIG_MIDDLE_EMULATION_DISABLED: Type = 0;
    pub const LIBINPUT_CONFIG_MIDDLE_EMULATION_ENABLED: Type = 1;
}
extern "C" {
    pub fn libinput_device_config_middle_emulation_is_available(
        device: *mut libinput_device,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libinput_device_config_middle_emulation_set_enabled(
        device: *mut libinput_device,
        enable: libinput_config_middle_emulation_state::Type,
    ) -> libinput_config_status::Type;
}
extern "C" {
    pub fn libinput_device_config_middle_emulation_get_enabled(
        device: *mut libinput_device,
    ) -> libinput_config_middle_emulation_state::Type;
}
extern "C" {
    pub fn libinput_device_config_middle_emulation_get_default_enabled(
        device: *mut libinput_device,
    ) -> libinput_config_middle_emulation_state::Type;
}
pub mod libinput_config_scroll_method {
    pub type Type = u32;
    pub const LIBINPUT_CONFIG_SCROLL_NO_SCROLL: Type = 0;
    pub const LIBINPUT_CONFIG_SCROLL_2FG: Type = 1;
    pub const LIBINPUT_CONFIG_SCROLL_EDGE: Type = 2;
    pub const LIBINPUT_CONFIG_SCROLL_ON_BUTTON_DOWN: Type = 4;
}
extern "C" {
    pub fn libinput_device_config_scroll_get_methods(device: *mut libinput_device) -> u32;
}
extern "C" {
    pub fn libinput_device_config_scroll_set_method(
        device: *mut libinput_device,
        method: libinput_config_scroll_method::Type,
    ) -> libinput_config_status::Type;
}
extern "C" {
    pub fn libinput_device_config_scroll_get_method(
        device: *mut libinput_device,
    ) -> libinput_config_scroll_method::Type;
}
extern "C" {
    pub fn libinput_device_config_scroll_get_default_method(
        device: *mut libinput_device,
    ) -> libinput_config_scroll_method::Type;
}
extern "C" {
    pub fn libinput_device_config_scroll_set_button(
        device: *mut libinput_device,
        button: u32,
    ) -> libinput_config_status::Type;
}
extern "C" {
    pub fn libinput_device_config_scroll_get_button(device: *mut libinput_device) -> u32;
}
extern "C" {
    pub fn libinput_device_config_scroll_get_default_button(device: *mut libinput_device) -> u32;
}
pub mod libinput_config_dwt_state {
    pub type Type = u32;
    pub const LIBINPUT_CONFIG_DWT_DISABLED: Type = 0;
    pub const LIBINPUT_CONFIG_DWT_ENABLED: Type = 1;
}
extern "C" {
    pub fn libinput_device_config_dwt_is_available(
        device: *mut libinput_device,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libinput_device_config_dwt_set_enabled(
        device: *mut libinput_device,
        enable: libinput_config_dwt_state::Type,
    ) -> libinput_config_status::Type;
}
extern "C" {
    pub fn libinput_device_config_dwt_get_enabled(
        device: *mut libinput_device,
    ) -> libinput_config_dwt_state::Type;
}
extern "C" {
    pub fn libinput_device_config_dwt_get_default_enabled(
        device: *mut libinput_device,
    ) -> libinput_config_dwt_state::Type;
}
extern "C" {
    pub fn libinput_device_config_rotation_is_available(
        device: *mut libinput_device,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libinput_device_config_rotation_set_angle(
        device: *mut libinput_device,
        degrees_cw: ::std::os::raw::c_uint,
    ) -> libinput_config_status::Type;
}
extern "C" {
    pub fn libinput_device_config_rotation_get_angle(
        device: *mut libinput_device,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn libinput_device_config_rotation_get_default_angle(
        device: *mut libinput_device,
    ) -> ::std::os::raw::c_uint;
}
pub mod wlr_button_state {
    pub type Type = u32;
    pub const WLR_BUTTON_RELEASED: Type = 0;
    pub const WLR_BUTTON_PRESSED: Type = 1;
}
pub mod wlr_input_device_type {
    pub type Type = u32;
    pub const WLR_INPUT_DEVICE_KEYBOARD: Type = 0;
    pub const WLR_INPUT_DEVICE_POINTER: Type = 1;
    pub const WLR_INPUT_DEVICE_TOUCH: Type = 2;
    pub const WLR_INPUT_DEVICE_TABLET_TOOL: Type = 3;
    pub const WLR_INPUT_DEVICE_TABLET_PAD: Type = 4;
    pub const WLR_INPUT_DEVICE_SWITCH: Type = 5;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._codecvt as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._wide_data as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_list as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_buf as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
pub type fpos_t = __fpos_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub static mut sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xkb_context {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xkb_keymap {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xkb_state {
    _unused: [u8; 0],
}
pub type xkb_keycode_t = u32;
pub type xkb_keysym_t = u32;
pub type xkb_layout_index_t = u32;
pub type xkb_layout_mask_t = u32;
pub type xkb_level_index_t = u32;
pub type xkb_mod_index_t = u32;
pub type xkb_mod_mask_t = u32;
pub type xkb_led_index_t = u32;
pub type xkb_led_mask_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xkb_rule_names {
    pub rules: *const ::std::os::raw::c_char,
    pub model: *const ::std::os::raw::c_char,
    pub layout: *const ::std::os::raw::c_char,
    pub variant: *const ::std::os::raw::c_char,
    pub options: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_xkb_rule_names() {
    assert_eq!(
        ::std::mem::size_of::<xkb_rule_names>(),
        40usize,
        concat!("Size of: ", stringify!(xkb_rule_names))
    );
    assert_eq!(
        ::std::mem::align_of::<xkb_rule_names>(),
        8usize,
        concat!("Alignment of ", stringify!(xkb_rule_names))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xkb_rule_names>())).rules as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xkb_rule_names),
            "::",
            stringify!(rules)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xkb_rule_names>())).model as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xkb_rule_names),
            "::",
            stringify!(model)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xkb_rule_names>())).layout as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xkb_rule_names),
            "::",
            stringify!(layout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xkb_rule_names>())).variant as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xkb_rule_names),
            "::",
            stringify!(variant)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xkb_rule_names>())).options as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(xkb_rule_names),
            "::",
            stringify!(options)
        )
    );
}
extern "C" {
    pub fn xkb_keysym_get_name(
        keysym: xkb_keysym_t,
        buffer: *mut ::std::os::raw::c_char,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
pub mod xkb_keysym_flags {
    pub type Type = u32;
    pub const XKB_KEYSYM_NO_FLAGS: Type = 0;
    pub const XKB_KEYSYM_CASE_INSENSITIVE: Type = 1;
}
extern "C" {
    pub fn xkb_keysym_from_name(
        name: *const ::std::os::raw::c_char,
        flags: xkb_keysym_flags::Type,
    ) -> xkb_keysym_t;
}
extern "C" {
    pub fn xkb_keysym_to_utf8(
        keysym: xkb_keysym_t,
        buffer: *mut ::std::os::raw::c_char,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xkb_keysym_to_utf32(keysym: xkb_keysym_t) -> u32;
}
extern "C" {
    pub fn xkb_keysym_to_upper(ks: xkb_keysym_t) -> xkb_keysym_t;
}
extern "C" {
    pub fn xkb_keysym_to_lower(ks: xkb_keysym_t) -> xkb_keysym_t;
}
pub mod xkb_context_flags {
    pub type Type = u32;
    pub const XKB_CONTEXT_NO_FLAGS: Type = 0;
    pub const XKB_CONTEXT_NO_DEFAULT_INCLUDES: Type = 1;
    pub const XKB_CONTEXT_NO_ENVIRONMENT_NAMES: Type = 2;
}
extern "C" {
    pub fn xkb_context_new(flags: xkb_context_flags::Type) -> *mut xkb_context;
}
extern "C" {
    pub fn xkb_context_ref(context: *mut xkb_context) -> *mut xkb_context;
}
extern "C" {
    pub fn xkb_context_unref(context: *mut xkb_context);
}
extern "C" {
    pub fn xkb_context_set_user_data(
        context: *mut xkb_context,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn xkb_context_get_user_data(context: *mut xkb_context) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn xkb_context_include_path_append(
        context: *mut xkb_context,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xkb_context_include_path_append_default(
        context: *mut xkb_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xkb_context_include_path_reset_defaults(
        context: *mut xkb_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xkb_context_include_path_clear(context: *mut xkb_context);
}
extern "C" {
    pub fn xkb_context_num_include_paths(context: *mut xkb_context) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn xkb_context_include_path_get(
        context: *mut xkb_context,
        index: ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char;
}
pub mod xkb_log_level {
    pub type Type = u32;
    pub const XKB_LOG_LEVEL_CRITICAL: Type = 10;
    pub const XKB_LOG_LEVEL_ERROR: Type = 20;
    pub const XKB_LOG_LEVEL_WARNING: Type = 30;
    pub const XKB_LOG_LEVEL_INFO: Type = 40;
    pub const XKB_LOG_LEVEL_DEBUG: Type = 50;
}
extern "C" {
    pub fn xkb_context_set_log_level(context: *mut xkb_context, level: xkb_log_level::Type);
}
extern "C" {
    pub fn xkb_context_get_log_level(context: *mut xkb_context) -> xkb_log_level::Type;
}
extern "C" {
    pub fn xkb_context_set_log_verbosity(
        context: *mut xkb_context,
        verbosity: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn xkb_context_get_log_verbosity(context: *mut xkb_context) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xkb_context_set_log_fn(
        context: *mut xkb_context,
        log_fn: ::std::option::Option<
            unsafe extern "C" fn(
                context: *mut xkb_context,
                level: xkb_log_level::Type,
                format: *const ::std::os::raw::c_char,
                args: *mut __va_list_tag,
            ),
        >,
    );
}
pub mod xkb_keymap_compile_flags {
    pub type Type = u32;
    pub const XKB_KEYMAP_COMPILE_NO_FLAGS: Type = 0;
}
extern "C" {
    pub fn xkb_keymap_new_from_names(
        context: *mut xkb_context,
        names: *const xkb_rule_names,
        flags: xkb_keymap_compile_flags::Type,
    ) -> *mut xkb_keymap;
}
pub mod xkb_keymap_format {
    pub type Type = u32;
    pub const XKB_KEYMAP_FORMAT_TEXT_V1: Type = 1;
}
extern "C" {
    pub fn xkb_keymap_new_from_file(
        context: *mut xkb_context,
        file: *mut FILE,
        format: xkb_keymap_format::Type,
        flags: xkb_keymap_compile_flags::Type,
    ) -> *mut xkb_keymap;
}
extern "C" {
    pub fn xkb_keymap_new_from_string(
        context: *mut xkb_context,
        string: *const ::std::os::raw::c_char,
        format: xkb_keymap_format::Type,
        flags: xkb_keymap_compile_flags::Type,
    ) -> *mut xkb_keymap;
}
extern "C" {
    pub fn xkb_keymap_new_from_buffer(
        context: *mut xkb_context,
        buffer: *const ::std::os::raw::c_char,
        length: usize,
        format: xkb_keymap_format::Type,
        flags: xkb_keymap_compile_flags::Type,
    ) -> *mut xkb_keymap;
}
extern "C" {
    pub fn xkb_keymap_ref(keymap: *mut xkb_keymap) -> *mut xkb_keymap;
}
extern "C" {
    pub fn xkb_keymap_unref(keymap: *mut xkb_keymap);
}
extern "C" {
    pub fn xkb_keymap_get_as_string(
        keymap: *mut xkb_keymap,
        format: xkb_keymap_format::Type,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn xkb_keymap_min_keycode(keymap: *mut xkb_keymap) -> xkb_keycode_t;
}
extern "C" {
    pub fn xkb_keymap_max_keycode(keymap: *mut xkb_keymap) -> xkb_keycode_t;
}
pub type xkb_keymap_key_iter_t = ::std::option::Option<
    unsafe extern "C" fn(
        keymap: *mut xkb_keymap,
        key: xkb_keycode_t,
        data: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    pub fn xkb_keymap_key_for_each(
        keymap: *mut xkb_keymap,
        iter: xkb_keymap_key_iter_t,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn xkb_keymap_key_get_name(
        keymap: *mut xkb_keymap,
        key: xkb_keycode_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn xkb_keymap_key_by_name(
        keymap: *mut xkb_keymap,
        name: *const ::std::os::raw::c_char,
    ) -> xkb_keycode_t;
}
extern "C" {
    pub fn xkb_keymap_num_mods(keymap: *mut xkb_keymap) -> xkb_mod_index_t;
}
extern "C" {
    pub fn xkb_keymap_mod_get_name(
        keymap: *mut xkb_keymap,
        idx: xkb_mod_index_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn xkb_keymap_mod_get_index(
        keymap: *mut xkb_keymap,
        name: *const ::std::os::raw::c_char,
    ) -> xkb_mod_index_t;
}
extern "C" {
    pub fn xkb_keymap_num_layouts(keymap: *mut xkb_keymap) -> xkb_layout_index_t;
}
extern "C" {
    pub fn xkb_keymap_layout_get_name(
        keymap: *mut xkb_keymap,
        idx: xkb_layout_index_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn xkb_keymap_layout_get_index(
        keymap: *mut xkb_keymap,
        name: *const ::std::os::raw::c_char,
    ) -> xkb_layout_index_t;
}
extern "C" {
    pub fn xkb_keymap_num_leds(keymap: *mut xkb_keymap) -> xkb_led_index_t;
}
extern "C" {
    pub fn xkb_keymap_led_get_name(
        keymap: *mut xkb_keymap,
        idx: xkb_led_index_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn xkb_keymap_led_get_index(
        keymap: *mut xkb_keymap,
        name: *const ::std::os::raw::c_char,
    ) -> xkb_led_index_t;
}
extern "C" {
    pub fn xkb_keymap_num_layouts_for_key(
        keymap: *mut xkb_keymap,
        key: xkb_keycode_t,
    ) -> xkb_layout_index_t;
}
extern "C" {
    pub fn xkb_keymap_num_levels_for_key(
        keymap: *mut xkb_keymap,
        key: xkb_keycode_t,
        layout: xkb_layout_index_t,
    ) -> xkb_level_index_t;
}
extern "C" {
    pub fn xkb_keymap_key_get_syms_by_level(
        keymap: *mut xkb_keymap,
        key: xkb_keycode_t,
        layout: xkb_layout_index_t,
        level: xkb_level_index_t,
        syms_out: *mut *const xkb_keysym_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xkb_keymap_key_repeats(
        keymap: *mut xkb_keymap,
        key: xkb_keycode_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xkb_state_new(keymap: *mut xkb_keymap) -> *mut xkb_state;
}
extern "C" {
    pub fn xkb_state_ref(state: *mut xkb_state) -> *mut xkb_state;
}
extern "C" {
    pub fn xkb_state_unref(state: *mut xkb_state);
}
extern "C" {
    pub fn xkb_state_get_keymap(state: *mut xkb_state) -> *mut xkb_keymap;
}
pub mod xkb_key_direction {
    pub type Type = u32;
    pub const XKB_KEY_UP: Type = 0;
    pub const XKB_KEY_DOWN: Type = 1;
}
pub mod xkb_state_component {
    pub type Type = u32;
    pub const XKB_STATE_MODS_DEPRESSED: Type = 1;
    pub const XKB_STATE_MODS_LATCHED: Type = 2;
    pub const XKB_STATE_MODS_LOCKED: Type = 4;
    pub const XKB_STATE_MODS_EFFECTIVE: Type = 8;
    pub const XKB_STATE_LAYOUT_DEPRESSED: Type = 16;
    pub const XKB_STATE_LAYOUT_LATCHED: Type = 32;
    pub const XKB_STATE_LAYOUT_LOCKED: Type = 64;
    pub const XKB_STATE_LAYOUT_EFFECTIVE: Type = 128;
    pub const XKB_STATE_LEDS: Type = 256;
}
extern "C" {
    pub fn xkb_state_update_key(
        state: *mut xkb_state,
        key: xkb_keycode_t,
        direction: xkb_key_direction::Type,
    ) -> xkb_state_component::Type;
}
extern "C" {
    pub fn xkb_state_update_mask(
        state: *mut xkb_state,
        depressed_mods: xkb_mod_mask_t,
        latched_mods: xkb_mod_mask_t,
        locked_mods: xkb_mod_mask_t,
        depressed_layout: xkb_layout_index_t,
        latched_layout: xkb_layout_index_t,
        locked_layout: xkb_layout_index_t,
    ) -> xkb_state_component::Type;
}
extern "C" {
    pub fn xkb_state_key_get_syms(
        state: *mut xkb_state,
        key: xkb_keycode_t,
        syms_out: *mut *const xkb_keysym_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xkb_state_key_get_utf8(
        state: *mut xkb_state,
        key: xkb_keycode_t,
        buffer: *mut ::std::os::raw::c_char,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xkb_state_key_get_utf32(state: *mut xkb_state, key: xkb_keycode_t) -> u32;
}
extern "C" {
    pub fn xkb_state_key_get_one_sym(state: *mut xkb_state, key: xkb_keycode_t) -> xkb_keysym_t;
}
extern "C" {
    pub fn xkb_state_key_get_layout(
        state: *mut xkb_state,
        key: xkb_keycode_t,
    ) -> xkb_layout_index_t;
}
extern "C" {
    pub fn xkb_state_key_get_level(
        state: *mut xkb_state,
        key: xkb_keycode_t,
        layout: xkb_layout_index_t,
    ) -> xkb_level_index_t;
}
pub mod xkb_state_match {
    pub type Type = u32;
    pub const XKB_STATE_MATCH_ANY: Type = 1;
    pub const XKB_STATE_MATCH_ALL: Type = 2;
    pub const XKB_STATE_MATCH_NON_EXCLUSIVE: Type = 65536;
}
extern "C" {
    pub fn xkb_state_serialize_mods(
        state: *mut xkb_state,
        components: xkb_state_component::Type,
    ) -> xkb_mod_mask_t;
}
extern "C" {
    pub fn xkb_state_serialize_layout(
        state: *mut xkb_state,
        components: xkb_state_component::Type,
    ) -> xkb_layout_index_t;
}
extern "C" {
    pub fn xkb_state_mod_name_is_active(
        state: *mut xkb_state,
        name: *const ::std::os::raw::c_char,
        type_: xkb_state_component::Type,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xkb_state_mod_names_are_active(
        state: *mut xkb_state,
        type_: xkb_state_component::Type,
        match_: xkb_state_match::Type,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xkb_state_mod_index_is_active(
        state: *mut xkb_state,
        idx: xkb_mod_index_t,
        type_: xkb_state_component::Type,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xkb_state_mod_indices_are_active(
        state: *mut xkb_state,
        type_: xkb_state_component::Type,
        match_: xkb_state_match::Type,
        ...
    ) -> ::std::os::raw::c_int;
}
pub mod xkb_consumed_mode {
    pub type Type = u32;
    pub const XKB_CONSUMED_MODE_XKB: Type = 0;
    pub const XKB_CONSUMED_MODE_GTK: Type = 1;
}
extern "C" {
    pub fn xkb_state_key_get_consumed_mods2(
        state: *mut xkb_state,
        key: xkb_keycode_t,
        mode: xkb_consumed_mode::Type,
    ) -> xkb_mod_mask_t;
}
extern "C" {
    pub fn xkb_state_key_get_consumed_mods(
        state: *mut xkb_state,
        key: xkb_keycode_t,
    ) -> xkb_mod_mask_t;
}
extern "C" {
    pub fn xkb_state_mod_index_is_consumed2(
        state: *mut xkb_state,
        key: xkb_keycode_t,
        idx: xkb_mod_index_t,
        mode: xkb_consumed_mode::Type,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xkb_state_mod_index_is_consumed(
        state: *mut xkb_state,
        key: xkb_keycode_t,
        idx: xkb_mod_index_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xkb_state_mod_mask_remove_consumed(
        state: *mut xkb_state,
        key: xkb_keycode_t,
        mask: xkb_mod_mask_t,
    ) -> xkb_mod_mask_t;
}
extern "C" {
    pub fn xkb_state_layout_name_is_active(
        state: *mut xkb_state,
        name: *const ::std::os::raw::c_char,
        type_: xkb_state_component::Type,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xkb_state_layout_index_is_active(
        state: *mut xkb_state,
        idx: xkb_layout_index_t,
        type_: xkb_state_component::Type,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xkb_state_led_name_is_active(
        state: *mut xkb_state,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xkb_state_led_index_is_active(
        state: *mut xkb_state,
        idx: xkb_led_index_t,
    ) -> ::std::os::raw::c_int;
}
pub mod wlr_keyboard_led {
    pub type Type = u32;
    pub const WLR_LED_NUM_LOCK: Type = 1;
    pub const WLR_LED_CAPS_LOCK: Type = 2;
    pub const WLR_LED_SCROLL_LOCK: Type = 4;
}
pub mod wlr_keyboard_modifier {
    pub type Type = u32;
    pub const WLR_MODIFIER_SHIFT: Type = 1;
    pub const WLR_MODIFIER_CAPS: Type = 2;
    pub const WLR_MODIFIER_CTRL: Type = 4;
    pub const WLR_MODIFIER_ALT: Type = 8;
    pub const WLR_MODIFIER_MOD2: Type = 16;
    pub const WLR_MODIFIER_MOD3: Type = 32;
    pub const WLR_MODIFIER_LOGO: Type = 64;
    pub const WLR_MODIFIER_MOD5: Type = 128;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_keyboard_impl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_keyboard_modifiers {
    pub depressed: xkb_mod_mask_t,
    pub latched: xkb_mod_mask_t,
    pub locked: xkb_mod_mask_t,
    pub group: xkb_mod_mask_t,
}
#[test]
fn bindgen_test_layout_wlr_keyboard_modifiers() {
    assert_eq!(
        ::std::mem::size_of::<wlr_keyboard_modifiers>(),
        16usize,
        concat!("Size of: ", stringify!(wlr_keyboard_modifiers))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_keyboard_modifiers>(),
        4usize,
        concat!("Alignment of ", stringify!(wlr_keyboard_modifiers))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_keyboard_modifiers>())).depressed as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_keyboard_modifiers),
            "::",
            stringify!(depressed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_keyboard_modifiers>())).latched as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_keyboard_modifiers),
            "::",
            stringify!(latched)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_keyboard_modifiers>())).locked as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_keyboard_modifiers),
            "::",
            stringify!(locked)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_keyboard_modifiers>())).group as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_keyboard_modifiers),
            "::",
            stringify!(group)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_keyboard {
    pub impl_: *const wlr_keyboard_impl,
    pub keymap_string: *mut ::std::os::raw::c_char,
    pub keymap_size: usize,
    pub keymap: *mut xkb_keymap,
    pub xkb_state: *mut xkb_state,
    pub led_indexes: [xkb_led_index_t; 3usize],
    pub mod_indexes: [xkb_mod_index_t; 8usize],
    pub keycodes: [u32; 32usize],
    pub num_keycodes: usize,
    pub modifiers: wlr_keyboard_modifiers,
    pub repeat_info: wlr_keyboard__bindgen_ty_1,
    pub events: wlr_keyboard__bindgen_ty_2,
    pub data: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_keyboard__bindgen_ty_1 {
    pub rate: i32,
    pub delay: i32,
}
#[test]
fn bindgen_test_layout_wlr_keyboard__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wlr_keyboard__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(wlr_keyboard__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_keyboard__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(wlr_keyboard__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_keyboard__bindgen_ty_1>())).rate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_keyboard__bindgen_ty_1),
            "::",
            stringify!(rate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_keyboard__bindgen_ty_1>())).delay as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_keyboard__bindgen_ty_1),
            "::",
            stringify!(delay)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_keyboard__bindgen_ty_2 {
    #[doc = " The `key` event signals with a `wlr_event_keyboard_key` event that a"]
    #[doc = " key has been pressed or released on the keyboard. This event is"]
    #[doc = " emitted before the xkb state of the keyboard has been updated"]
    #[doc = " (including modifiers)."]
    pub key: wl_signal,
    #[doc = " The `modifiers` event signals that the modifier state of the"]
    #[doc = " `wlr_keyboard` has been updated. At this time, you can read the"]
    #[doc = " modifier state of the `wlr_keyboard` and handle the updated state by"]
    #[doc = " sending it to clients."]
    pub modifiers: wl_signal,
    pub keymap: wl_signal,
    pub repeat_info: wl_signal,
}
#[test]
fn bindgen_test_layout_wlr_keyboard__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<wlr_keyboard__bindgen_ty_2>(),
        64usize,
        concat!("Size of: ", stringify!(wlr_keyboard__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_keyboard__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_keyboard__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_keyboard__bindgen_ty_2>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_keyboard__bindgen_ty_2),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_keyboard__bindgen_ty_2>())).modifiers as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_keyboard__bindgen_ty_2),
            "::",
            stringify!(modifiers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_keyboard__bindgen_ty_2>())).keymap as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_keyboard__bindgen_ty_2),
            "::",
            stringify!(keymap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_keyboard__bindgen_ty_2>())).repeat_info as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_keyboard__bindgen_ty_2),
            "::",
            stringify!(repeat_info)
        )
    );
}
#[test]
fn bindgen_test_layout_wlr_keyboard() {
    assert_eq!(
        ::std::mem::size_of::<wlr_keyboard>(),
        320usize,
        concat!("Size of: ", stringify!(wlr_keyboard))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_keyboard>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_keyboard))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_keyboard>())).impl_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_keyboard),
            "::",
            stringify!(impl_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_keyboard>())).keymap_string as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_keyboard),
            "::",
            stringify!(keymap_string)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_keyboard>())).keymap_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_keyboard),
            "::",
            stringify!(keymap_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_keyboard>())).keymap as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_keyboard),
            "::",
            stringify!(keymap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_keyboard>())).xkb_state as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_keyboard),
            "::",
            stringify!(xkb_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_keyboard>())).led_indexes as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_keyboard),
            "::",
            stringify!(led_indexes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_keyboard>())).mod_indexes as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_keyboard),
            "::",
            stringify!(mod_indexes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_keyboard>())).keycodes as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_keyboard),
            "::",
            stringify!(keycodes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_keyboard>())).num_keycodes as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_keyboard),
            "::",
            stringify!(num_keycodes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_keyboard>())).modifiers as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_keyboard),
            "::",
            stringify!(modifiers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_keyboard>())).repeat_info as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_keyboard),
            "::",
            stringify!(repeat_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_keyboard>())).events as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_keyboard),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_keyboard>())).data as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_keyboard),
            "::",
            stringify!(data)
        )
    );
}
pub mod wlr_key_state {
    pub type Type = u32;
    pub const WLR_KEY_RELEASED: Type = 0;
    pub const WLR_KEY_PRESSED: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_event_keyboard_key {
    pub time_msec: u32,
    pub keycode: u32,
    pub update_state: bool,
    pub state: wlr_key_state::Type,
}
#[test]
fn bindgen_test_layout_wlr_event_keyboard_key() {
    assert_eq!(
        ::std::mem::size_of::<wlr_event_keyboard_key>(),
        16usize,
        concat!("Size of: ", stringify!(wlr_event_keyboard_key))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_event_keyboard_key>(),
        4usize,
        concat!("Alignment of ", stringify!(wlr_event_keyboard_key))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_keyboard_key>())).time_msec as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_keyboard_key),
            "::",
            stringify!(time_msec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_event_keyboard_key>())).keycode as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_keyboard_key),
            "::",
            stringify!(keycode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_keyboard_key>())).update_state as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_keyboard_key),
            "::",
            stringify!(update_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_event_keyboard_key>())).state as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_keyboard_key),
            "::",
            stringify!(state)
        )
    );
}
extern "C" {
    pub fn wlr_keyboard_set_keymap(kb: *mut wlr_keyboard, keymap: *mut xkb_keymap);
}
extern "C" {
    #[doc = " Sets the keyboard repeat info. `rate` is in key repeats/second and delay is"]
    #[doc = " in milliseconds."]
    pub fn wlr_keyboard_set_repeat_info(kb: *mut wlr_keyboard, rate: i32, delay: i32);
}
extern "C" {
    pub fn wlr_keyboard_led_update(keyboard: *mut wlr_keyboard, leds: u32);
}
extern "C" {
    pub fn wlr_keyboard_get_modifiers(keyboard: *mut wlr_keyboard) -> u32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_pointer_impl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_pointer {
    pub impl_: *const wlr_pointer_impl,
    pub events: wlr_pointer__bindgen_ty_1,
    pub data: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_pointer__bindgen_ty_1 {
    pub motion: wl_signal,
    pub motion_absolute: wl_signal,
    pub button: wl_signal,
    pub axis: wl_signal,
    pub frame: wl_signal,
    pub swipe_begin: wl_signal,
    pub swipe_update: wl_signal,
    pub swipe_end: wl_signal,
    pub pinch_begin: wl_signal,
    pub pinch_update: wl_signal,
    pub pinch_end: wl_signal,
}
#[test]
fn bindgen_test_layout_wlr_pointer__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wlr_pointer__bindgen_ty_1>(),
        176usize,
        concat!("Size of: ", stringify!(wlr_pointer__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_pointer__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_pointer__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_pointer__bindgen_ty_1>())).motion as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_pointer__bindgen_ty_1),
            "::",
            stringify!(motion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_pointer__bindgen_ty_1>())).motion_absolute as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_pointer__bindgen_ty_1),
            "::",
            stringify!(motion_absolute)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_pointer__bindgen_ty_1>())).button as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_pointer__bindgen_ty_1),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_pointer__bindgen_ty_1>())).axis as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_pointer__bindgen_ty_1),
            "::",
            stringify!(axis)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_pointer__bindgen_ty_1>())).frame as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_pointer__bindgen_ty_1),
            "::",
            stringify!(frame)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_pointer__bindgen_ty_1>())).swipe_begin as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_pointer__bindgen_ty_1),
            "::",
            stringify!(swipe_begin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_pointer__bindgen_ty_1>())).swipe_update as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_pointer__bindgen_ty_1),
            "::",
            stringify!(swipe_update)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_pointer__bindgen_ty_1>())).swipe_end as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_pointer__bindgen_ty_1),
            "::",
            stringify!(swipe_end)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_pointer__bindgen_ty_1>())).pinch_begin as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_pointer__bindgen_ty_1),
            "::",
            stringify!(pinch_begin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_pointer__bindgen_ty_1>())).pinch_update as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_pointer__bindgen_ty_1),
            "::",
            stringify!(pinch_update)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_pointer__bindgen_ty_1>())).pinch_end as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_pointer__bindgen_ty_1),
            "::",
            stringify!(pinch_end)
        )
    );
}
#[test]
fn bindgen_test_layout_wlr_pointer() {
    assert_eq!(
        ::std::mem::size_of::<wlr_pointer>(),
        192usize,
        concat!("Size of: ", stringify!(wlr_pointer))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_pointer>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_pointer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_pointer>())).impl_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_pointer),
            "::",
            stringify!(impl_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_pointer>())).events as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_pointer),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_pointer>())).data as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_pointer),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_event_pointer_motion {
    pub device: *mut wlr_input_device,
    pub time_msec: u32,
    pub delta_x: f64,
    pub delta_y: f64,
    pub unaccel_dx: f64,
    pub unaccel_dy: f64,
}
#[test]
fn bindgen_test_layout_wlr_event_pointer_motion() {
    assert_eq!(
        ::std::mem::size_of::<wlr_event_pointer_motion>(),
        48usize,
        concat!("Size of: ", stringify!(wlr_event_pointer_motion))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_event_pointer_motion>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_event_pointer_motion))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_event_pointer_motion>())).device as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_pointer_motion),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_pointer_motion>())).time_msec as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_pointer_motion),
            "::",
            stringify!(time_msec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_pointer_motion>())).delta_x as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_pointer_motion),
            "::",
            stringify!(delta_x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_pointer_motion>())).delta_y as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_pointer_motion),
            "::",
            stringify!(delta_y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_pointer_motion>())).unaccel_dx as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_pointer_motion),
            "::",
            stringify!(unaccel_dx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_pointer_motion>())).unaccel_dy as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_pointer_motion),
            "::",
            stringify!(unaccel_dy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_event_pointer_motion_absolute {
    pub device: *mut wlr_input_device,
    pub time_msec: u32,
    pub x: f64,
    pub y: f64,
}
#[test]
fn bindgen_test_layout_wlr_event_pointer_motion_absolute() {
    assert_eq!(
        ::std::mem::size_of::<wlr_event_pointer_motion_absolute>(),
        32usize,
        concat!("Size of: ", stringify!(wlr_event_pointer_motion_absolute))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_event_pointer_motion_absolute>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(wlr_event_pointer_motion_absolute)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_pointer_motion_absolute>())).device as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_pointer_motion_absolute),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_pointer_motion_absolute>())).time_msec as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_pointer_motion_absolute),
            "::",
            stringify!(time_msec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_pointer_motion_absolute>())).x as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_pointer_motion_absolute),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_pointer_motion_absolute>())).y as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_pointer_motion_absolute),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_event_pointer_button {
    pub device: *mut wlr_input_device,
    pub time_msec: u32,
    pub button: u32,
    pub state: wlr_button_state::Type,
}
#[test]
fn bindgen_test_layout_wlr_event_pointer_button() {
    assert_eq!(
        ::std::mem::size_of::<wlr_event_pointer_button>(),
        24usize,
        concat!("Size of: ", stringify!(wlr_event_pointer_button))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_event_pointer_button>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_event_pointer_button))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_event_pointer_button>())).device as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_pointer_button),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_pointer_button>())).time_msec as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_pointer_button),
            "::",
            stringify!(time_msec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_event_pointer_button>())).button as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_pointer_button),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_event_pointer_button>())).state as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_pointer_button),
            "::",
            stringify!(state)
        )
    );
}
pub mod wlr_axis_source {
    pub type Type = u32;
    pub const WLR_AXIS_SOURCE_WHEEL: Type = 0;
    pub const WLR_AXIS_SOURCE_FINGER: Type = 1;
    pub const WLR_AXIS_SOURCE_CONTINUOUS: Type = 2;
    pub const WLR_AXIS_SOURCE_WHEEL_TILT: Type = 3;
}
pub mod wlr_axis_orientation {
    pub type Type = u32;
    pub const WLR_AXIS_ORIENTATION_VERTICAL: Type = 0;
    pub const WLR_AXIS_ORIENTATION_HORIZONTAL: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_event_pointer_axis {
    pub device: *mut wlr_input_device,
    pub time_msec: u32,
    pub source: wlr_axis_source::Type,
    pub orientation: wlr_axis_orientation::Type,
    pub delta: f64,
    pub delta_discrete: i32,
}
#[test]
fn bindgen_test_layout_wlr_event_pointer_axis() {
    assert_eq!(
        ::std::mem::size_of::<wlr_event_pointer_axis>(),
        40usize,
        concat!("Size of: ", stringify!(wlr_event_pointer_axis))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_event_pointer_axis>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_event_pointer_axis))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_event_pointer_axis>())).device as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_pointer_axis),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_pointer_axis>())).time_msec as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_pointer_axis),
            "::",
            stringify!(time_msec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_event_pointer_axis>())).source as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_pointer_axis),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_pointer_axis>())).orientation as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_pointer_axis),
            "::",
            stringify!(orientation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_event_pointer_axis>())).delta as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_pointer_axis),
            "::",
            stringify!(delta)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_pointer_axis>())).delta_discrete as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_pointer_axis),
            "::",
            stringify!(delta_discrete)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_event_pointer_swipe_begin {
    pub device: *mut wlr_input_device,
    pub time_msec: u32,
    pub fingers: u32,
}
#[test]
fn bindgen_test_layout_wlr_event_pointer_swipe_begin() {
    assert_eq!(
        ::std::mem::size_of::<wlr_event_pointer_swipe_begin>(),
        16usize,
        concat!("Size of: ", stringify!(wlr_event_pointer_swipe_begin))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_event_pointer_swipe_begin>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_event_pointer_swipe_begin))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_pointer_swipe_begin>())).device as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_pointer_swipe_begin),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_pointer_swipe_begin>())).time_msec as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_pointer_swipe_begin),
            "::",
            stringify!(time_msec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_pointer_swipe_begin>())).fingers as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_pointer_swipe_begin),
            "::",
            stringify!(fingers)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_event_pointer_swipe_update {
    pub device: *mut wlr_input_device,
    pub time_msec: u32,
    pub fingers: u32,
    pub dx: f64,
    pub dy: f64,
}
#[test]
fn bindgen_test_layout_wlr_event_pointer_swipe_update() {
    assert_eq!(
        ::std::mem::size_of::<wlr_event_pointer_swipe_update>(),
        32usize,
        concat!("Size of: ", stringify!(wlr_event_pointer_swipe_update))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_event_pointer_swipe_update>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_event_pointer_swipe_update))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_pointer_swipe_update>())).device as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_pointer_swipe_update),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_pointer_swipe_update>())).time_msec as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_pointer_swipe_update),
            "::",
            stringify!(time_msec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_pointer_swipe_update>())).fingers as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_pointer_swipe_update),
            "::",
            stringify!(fingers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_pointer_swipe_update>())).dx as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_pointer_swipe_update),
            "::",
            stringify!(dx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_pointer_swipe_update>())).dy as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_pointer_swipe_update),
            "::",
            stringify!(dy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_event_pointer_swipe_end {
    pub device: *mut wlr_input_device,
    pub time_msec: u32,
    pub cancelled: bool,
}
#[test]
fn bindgen_test_layout_wlr_event_pointer_swipe_end() {
    assert_eq!(
        ::std::mem::size_of::<wlr_event_pointer_swipe_end>(),
        16usize,
        concat!("Size of: ", stringify!(wlr_event_pointer_swipe_end))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_event_pointer_swipe_end>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_event_pointer_swipe_end))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_pointer_swipe_end>())).device as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_pointer_swipe_end),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_pointer_swipe_end>())).time_msec as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_pointer_swipe_end),
            "::",
            stringify!(time_msec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_pointer_swipe_end>())).cancelled as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_pointer_swipe_end),
            "::",
            stringify!(cancelled)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_event_pointer_pinch_begin {
    pub device: *mut wlr_input_device,
    pub time_msec: u32,
    pub fingers: u32,
}
#[test]
fn bindgen_test_layout_wlr_event_pointer_pinch_begin() {
    assert_eq!(
        ::std::mem::size_of::<wlr_event_pointer_pinch_begin>(),
        16usize,
        concat!("Size of: ", stringify!(wlr_event_pointer_pinch_begin))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_event_pointer_pinch_begin>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_event_pointer_pinch_begin))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_pointer_pinch_begin>())).device as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_pointer_pinch_begin),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_pointer_pinch_begin>())).time_msec as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_pointer_pinch_begin),
            "::",
            stringify!(time_msec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_pointer_pinch_begin>())).fingers as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_pointer_pinch_begin),
            "::",
            stringify!(fingers)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_event_pointer_pinch_update {
    pub device: *mut wlr_input_device,
    pub time_msec: u32,
    pub fingers: u32,
    pub dx: f64,
    pub dy: f64,
    pub scale: f64,
    pub rotation: f64,
}
#[test]
fn bindgen_test_layout_wlr_event_pointer_pinch_update() {
    assert_eq!(
        ::std::mem::size_of::<wlr_event_pointer_pinch_update>(),
        48usize,
        concat!("Size of: ", stringify!(wlr_event_pointer_pinch_update))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_event_pointer_pinch_update>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_event_pointer_pinch_update))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_pointer_pinch_update>())).device as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_pointer_pinch_update),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_pointer_pinch_update>())).time_msec as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_pointer_pinch_update),
            "::",
            stringify!(time_msec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_pointer_pinch_update>())).fingers as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_pointer_pinch_update),
            "::",
            stringify!(fingers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_pointer_pinch_update>())).dx as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_pointer_pinch_update),
            "::",
            stringify!(dx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_pointer_pinch_update>())).dy as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_pointer_pinch_update),
            "::",
            stringify!(dy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_pointer_pinch_update>())).scale as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_pointer_pinch_update),
            "::",
            stringify!(scale)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_pointer_pinch_update>())).rotation as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_pointer_pinch_update),
            "::",
            stringify!(rotation)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_event_pointer_pinch_end {
    pub device: *mut wlr_input_device,
    pub time_msec: u32,
    pub cancelled: bool,
}
#[test]
fn bindgen_test_layout_wlr_event_pointer_pinch_end() {
    assert_eq!(
        ::std::mem::size_of::<wlr_event_pointer_pinch_end>(),
        16usize,
        concat!("Size of: ", stringify!(wlr_event_pointer_pinch_end))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_event_pointer_pinch_end>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_event_pointer_pinch_end))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_pointer_pinch_end>())).device as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_pointer_pinch_end),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_pointer_pinch_end>())).time_msec as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_pointer_pinch_end),
            "::",
            stringify!(time_msec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_pointer_pinch_end>())).cancelled as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_pointer_pinch_end),
            "::",
            stringify!(cancelled)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_touch_impl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_touch {
    pub impl_: *const wlr_touch_impl,
    pub events: wlr_touch__bindgen_ty_1,
    pub data: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_touch__bindgen_ty_1 {
    pub down: wl_signal,
    pub up: wl_signal,
    pub motion: wl_signal,
    pub cancel: wl_signal,
}
#[test]
fn bindgen_test_layout_wlr_touch__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wlr_touch__bindgen_ty_1>(),
        64usize,
        concat!("Size of: ", stringify!(wlr_touch__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_touch__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_touch__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_touch__bindgen_ty_1>())).down as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_touch__bindgen_ty_1),
            "::",
            stringify!(down)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_touch__bindgen_ty_1>())).up as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_touch__bindgen_ty_1),
            "::",
            stringify!(up)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_touch__bindgen_ty_1>())).motion as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_touch__bindgen_ty_1),
            "::",
            stringify!(motion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_touch__bindgen_ty_1>())).cancel as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_touch__bindgen_ty_1),
            "::",
            stringify!(cancel)
        )
    );
}
#[test]
fn bindgen_test_layout_wlr_touch() {
    assert_eq!(
        ::std::mem::size_of::<wlr_touch>(),
        80usize,
        concat!("Size of: ", stringify!(wlr_touch))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_touch>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_touch))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_touch>())).impl_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_touch),
            "::",
            stringify!(impl_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_touch>())).events as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_touch),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_touch>())).data as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_touch),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_event_touch_down {
    pub device: *mut wlr_input_device,
    pub time_msec: u32,
    pub touch_id: i32,
    pub x: f64,
    pub y: f64,
}
#[test]
fn bindgen_test_layout_wlr_event_touch_down() {
    assert_eq!(
        ::std::mem::size_of::<wlr_event_touch_down>(),
        32usize,
        concat!("Size of: ", stringify!(wlr_event_touch_down))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_event_touch_down>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_event_touch_down))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_event_touch_down>())).device as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_touch_down),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_event_touch_down>())).time_msec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_touch_down),
            "::",
            stringify!(time_msec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_event_touch_down>())).touch_id as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_touch_down),
            "::",
            stringify!(touch_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_event_touch_down>())).x as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_touch_down),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_event_touch_down>())).y as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_touch_down),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_event_touch_up {
    pub device: *mut wlr_input_device,
    pub time_msec: u32,
    pub touch_id: i32,
}
#[test]
fn bindgen_test_layout_wlr_event_touch_up() {
    assert_eq!(
        ::std::mem::size_of::<wlr_event_touch_up>(),
        16usize,
        concat!("Size of: ", stringify!(wlr_event_touch_up))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_event_touch_up>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_event_touch_up))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_event_touch_up>())).device as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_touch_up),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_event_touch_up>())).time_msec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_touch_up),
            "::",
            stringify!(time_msec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_event_touch_up>())).touch_id as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_touch_up),
            "::",
            stringify!(touch_id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_event_touch_motion {
    pub device: *mut wlr_input_device,
    pub time_msec: u32,
    pub touch_id: i32,
    pub x: f64,
    pub y: f64,
}
#[test]
fn bindgen_test_layout_wlr_event_touch_motion() {
    assert_eq!(
        ::std::mem::size_of::<wlr_event_touch_motion>(),
        32usize,
        concat!("Size of: ", stringify!(wlr_event_touch_motion))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_event_touch_motion>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_event_touch_motion))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_event_touch_motion>())).device as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_touch_motion),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_touch_motion>())).time_msec as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_touch_motion),
            "::",
            stringify!(time_msec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_event_touch_motion>())).touch_id as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_touch_motion),
            "::",
            stringify!(touch_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_event_touch_motion>())).x as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_touch_motion),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_event_touch_motion>())).y as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_touch_motion),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_event_touch_cancel {
    pub device: *mut wlr_input_device,
    pub time_msec: u32,
    pub touch_id: i32,
}
#[test]
fn bindgen_test_layout_wlr_event_touch_cancel() {
    assert_eq!(
        ::std::mem::size_of::<wlr_event_touch_cancel>(),
        16usize,
        concat!("Size of: ", stringify!(wlr_event_touch_cancel))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_event_touch_cancel>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_event_touch_cancel))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_event_touch_cancel>())).device as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_touch_cancel),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_touch_cancel>())).time_msec as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_touch_cancel),
            "::",
            stringify!(time_msec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_event_touch_cancel>())).touch_id as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_touch_cancel),
            "::",
            stringify!(touch_id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_list {
    pub capacity: usize,
    pub length: usize,
    pub items: *mut *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_wlr_list() {
    assert_eq!(
        ::std::mem::size_of::<wlr_list>(),
        24usize,
        concat!("Size of: ", stringify!(wlr_list))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_list>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_list>())).capacity as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_list),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_list>())).length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_list),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_list>())).items as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_list),
            "::",
            stringify!(items)
        )
    );
}
extern "C" {
    #[doc = " Initialize a list. Returns true on success, false on failure."]
    pub fn wlr_list_init(list: *mut wlr_list) -> bool;
}
extern "C" {
    #[doc = " Deinitialize a list."]
    pub fn wlr_list_finish(list: *mut wlr_list);
}
extern "C" {
    #[doc = " Executes `callback` on each element in the list."]
    pub fn wlr_list_for_each(
        list: *mut wlr_list,
        callback: ::std::option::Option<unsafe extern "C" fn(item: *mut ::std::os::raw::c_void)>,
    );
}
extern "C" {
    #[doc = " Add `item` to the end of a list."]
    #[doc = " Returns: new list length or `-1` on failure."]
    pub fn wlr_list_push(list: *mut wlr_list, item: *mut ::std::os::raw::c_void) -> isize;
}
extern "C" {
    #[doc = " Place `item` into index `index` in the list."]
    #[doc = " Returns: new list length or `-1` on failure."]
    pub fn wlr_list_insert(
        list: *mut wlr_list,
        index: usize,
        item: *mut ::std::os::raw::c_void,
    ) -> isize;
}
extern "C" {
    #[doc = " Remove an item from the list."]
    pub fn wlr_list_del(list: *mut wlr_list, index: usize);
}
extern "C" {
    #[doc = " Remove and return an item from the end of the list."]
    pub fn wlr_list_pop(list: *mut wlr_list) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Get a reference to the last item of a list without removal."]
    pub fn wlr_list_peek(list: *mut wlr_list) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Append each item in `source` to `list`."]
    #[doc = " Does not modify `source`."]
    #[doc = " Returns: new list length or `-1` on failure."]
    pub fn wlr_list_cat(list: *mut wlr_list, source: *const wlr_list) -> isize;
}
extern "C" {
    #[doc = " Sort a list using `qsort`."]
    pub fn wlr_list_qsort(
        list: *mut wlr_list,
        compare: ::std::option::Option<
            unsafe extern "C" fn(
                left: *const ::std::os::raw::c_void,
                right: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    #[doc = " Return the index of the first item in the list that returns 0 for the given"]
    #[doc = " `compare` function, or -1 if none matches."]
    pub fn wlr_list_find(
        list: *mut wlr_list,
        compare: ::std::option::Option<
            unsafe extern "C" fn(
                item: *const ::std::os::raw::c_void,
                cmp_to: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        cmp_to: *const ::std::os::raw::c_void,
    ) -> isize;
}
pub mod wlr_tablet_tool_type {
    pub type Type = u32;
    #[doc = " A generic pen"]
    pub const WLR_TABLET_TOOL_TYPE_PEN: Type = 1;
    #[doc = " Eraser"]
    pub const WLR_TABLET_TOOL_TYPE_ERASER: Type = 2;
    #[doc = " A paintbrush-like tool"]
    pub const WLR_TABLET_TOOL_TYPE_BRUSH: Type = 3;
    #[doc = " Physical drawing tool, e.g. Wacom Inking Pen"]
    pub const WLR_TABLET_TOOL_TYPE_PENCIL: Type = 4;
    #[doc = " An airbrush-like tool"]
    pub const WLR_TABLET_TOOL_TYPE_AIRBRUSH: Type = 5;
    #[doc = " A mouse bound to the tablet"]
    pub const WLR_TABLET_TOOL_TYPE_MOUSE: Type = 6;
    #[doc = " A mouse tool with a lens"]
    pub const WLR_TABLET_TOOL_TYPE_LENS: Type = 7;
    #[doc = " A rotary device with positional and rotation data"]
    pub const WLR_TABLET_TOOL_TYPE_TOTEM: Type = 8;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_tablet_tool {
    pub type_: wlr_tablet_tool_type::Type,
    pub hardware_serial: u64,
    pub hardware_wacom: u64,
    pub tilt: bool,
    pub pressure: bool,
    pub distance: bool,
    pub rotation: bool,
    pub slider: bool,
    pub wheel: bool,
    pub events: wlr_tablet_tool__bindgen_ty_1,
    pub data: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_tablet_tool__bindgen_ty_1 {
    pub destroy: wl_signal,
}
#[test]
fn bindgen_test_layout_wlr_tablet_tool__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wlr_tablet_tool__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(wlr_tablet_tool__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_tablet_tool__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_tablet_tool__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_tablet_tool__bindgen_ty_1>())).destroy as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_tablet_tool__bindgen_ty_1),
            "::",
            stringify!(destroy)
        )
    );
}
#[test]
fn bindgen_test_layout_wlr_tablet_tool() {
    assert_eq!(
        ::std::mem::size_of::<wlr_tablet_tool>(),
        56usize,
        concat!("Size of: ", stringify!(wlr_tablet_tool))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_tablet_tool>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_tablet_tool))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_tablet_tool>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_tablet_tool),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_tablet_tool>())).hardware_serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_tablet_tool),
            "::",
            stringify!(hardware_serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_tablet_tool>())).hardware_wacom as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_tablet_tool),
            "::",
            stringify!(hardware_wacom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_tablet_tool>())).tilt as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_tablet_tool),
            "::",
            stringify!(tilt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_tablet_tool>())).pressure as *const _ as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_tablet_tool),
            "::",
            stringify!(pressure)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_tablet_tool>())).distance as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_tablet_tool),
            "::",
            stringify!(distance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_tablet_tool>())).rotation as *const _ as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_tablet_tool),
            "::",
            stringify!(rotation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_tablet_tool>())).slider as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_tablet_tool),
            "::",
            stringify!(slider)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_tablet_tool>())).wheel as *const _ as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_tablet_tool),
            "::",
            stringify!(wheel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_tablet_tool>())).events as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_tablet_tool),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_tablet_tool>())).data as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_tablet_tool),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_tablet_impl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_tablet {
    pub impl_: *mut wlr_tablet_impl,
    pub events: wlr_tablet__bindgen_ty_1,
    pub name: *const ::std::os::raw::c_char,
    pub paths: wlr_list,
    pub data: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_tablet__bindgen_ty_1 {
    pub axis: wl_signal,
    pub proximity: wl_signal,
    pub tip: wl_signal,
    pub button: wl_signal,
}
#[test]
fn bindgen_test_layout_wlr_tablet__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wlr_tablet__bindgen_ty_1>(),
        64usize,
        concat!("Size of: ", stringify!(wlr_tablet__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_tablet__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_tablet__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_tablet__bindgen_ty_1>())).axis as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_tablet__bindgen_ty_1),
            "::",
            stringify!(axis)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_tablet__bindgen_ty_1>())).proximity as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_tablet__bindgen_ty_1),
            "::",
            stringify!(proximity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_tablet__bindgen_ty_1>())).tip as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_tablet__bindgen_ty_1),
            "::",
            stringify!(tip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_tablet__bindgen_ty_1>())).button as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_tablet__bindgen_ty_1),
            "::",
            stringify!(button)
        )
    );
}
#[test]
fn bindgen_test_layout_wlr_tablet() {
    assert_eq!(
        ::std::mem::size_of::<wlr_tablet>(),
        112usize,
        concat!("Size of: ", stringify!(wlr_tablet))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_tablet>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_tablet))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_tablet>())).impl_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_tablet),
            "::",
            stringify!(impl_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_tablet>())).events as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_tablet),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_tablet>())).name as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_tablet),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_tablet>())).paths as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_tablet),
            "::",
            stringify!(paths)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_tablet>())).data as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_tablet),
            "::",
            stringify!(data)
        )
    );
}
pub mod wlr_tablet_tool_axes {
    pub type Type = u32;
    pub const WLR_TABLET_TOOL_AXIS_X: Type = 1;
    pub const WLR_TABLET_TOOL_AXIS_Y: Type = 2;
    pub const WLR_TABLET_TOOL_AXIS_DISTANCE: Type = 4;
    pub const WLR_TABLET_TOOL_AXIS_PRESSURE: Type = 8;
    pub const WLR_TABLET_TOOL_AXIS_TILT_X: Type = 16;
    pub const WLR_TABLET_TOOL_AXIS_TILT_Y: Type = 32;
    pub const WLR_TABLET_TOOL_AXIS_ROTATION: Type = 64;
    pub const WLR_TABLET_TOOL_AXIS_SLIDER: Type = 128;
    pub const WLR_TABLET_TOOL_AXIS_WHEEL: Type = 256;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_event_tablet_tool_axis {
    pub device: *mut wlr_input_device,
    pub tool: *mut wlr_tablet_tool,
    pub time_msec: u32,
    pub updated_axes: u32,
    pub x: f64,
    pub y: f64,
    pub dx: f64,
    pub dy: f64,
    pub pressure: f64,
    pub distance: f64,
    pub tilt_x: f64,
    pub tilt_y: f64,
    pub rotation: f64,
    pub slider: f64,
    pub wheel_delta: f64,
}
#[test]
fn bindgen_test_layout_wlr_event_tablet_tool_axis() {
    assert_eq!(
        ::std::mem::size_of::<wlr_event_tablet_tool_axis>(),
        112usize,
        concat!("Size of: ", stringify!(wlr_event_tablet_tool_axis))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_event_tablet_tool_axis>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_event_tablet_tool_axis))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_tablet_tool_axis>())).device as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_tablet_tool_axis),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_event_tablet_tool_axis>())).tool as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_tablet_tool_axis),
            "::",
            stringify!(tool)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_tablet_tool_axis>())).time_msec as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_tablet_tool_axis),
            "::",
            stringify!(time_msec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_tablet_tool_axis>())).updated_axes as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_tablet_tool_axis),
            "::",
            stringify!(updated_axes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_event_tablet_tool_axis>())).x as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_tablet_tool_axis),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_event_tablet_tool_axis>())).y as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_tablet_tool_axis),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_event_tablet_tool_axis>())).dx as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_tablet_tool_axis),
            "::",
            stringify!(dx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_event_tablet_tool_axis>())).dy as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_tablet_tool_axis),
            "::",
            stringify!(dy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_tablet_tool_axis>())).pressure as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_tablet_tool_axis),
            "::",
            stringify!(pressure)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_tablet_tool_axis>())).distance as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_tablet_tool_axis),
            "::",
            stringify!(distance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_tablet_tool_axis>())).tilt_x as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_tablet_tool_axis),
            "::",
            stringify!(tilt_x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_tablet_tool_axis>())).tilt_y as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_tablet_tool_axis),
            "::",
            stringify!(tilt_y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_tablet_tool_axis>())).rotation as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_tablet_tool_axis),
            "::",
            stringify!(rotation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_tablet_tool_axis>())).slider as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_tablet_tool_axis),
            "::",
            stringify!(slider)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_tablet_tool_axis>())).wheel_delta as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_tablet_tool_axis),
            "::",
            stringify!(wheel_delta)
        )
    );
}
pub mod wlr_tablet_tool_proximity_state {
    pub type Type = u32;
    pub const WLR_TABLET_TOOL_PROXIMITY_OUT: Type = 0;
    pub const WLR_TABLET_TOOL_PROXIMITY_IN: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_event_tablet_tool_proximity {
    pub device: *mut wlr_input_device,
    pub tool: *mut wlr_tablet_tool,
    pub time_msec: u32,
    pub x: f64,
    pub y: f64,
    pub state: wlr_tablet_tool_proximity_state::Type,
}
#[test]
fn bindgen_test_layout_wlr_event_tablet_tool_proximity() {
    assert_eq!(
        ::std::mem::size_of::<wlr_event_tablet_tool_proximity>(),
        48usize,
        concat!("Size of: ", stringify!(wlr_event_tablet_tool_proximity))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_event_tablet_tool_proximity>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_event_tablet_tool_proximity))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_tablet_tool_proximity>())).device as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_tablet_tool_proximity),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_tablet_tool_proximity>())).tool as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_tablet_tool_proximity),
            "::",
            stringify!(tool)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_tablet_tool_proximity>())).time_msec as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_tablet_tool_proximity),
            "::",
            stringify!(time_msec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_tablet_tool_proximity>())).x as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_tablet_tool_proximity),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_tablet_tool_proximity>())).y as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_tablet_tool_proximity),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_tablet_tool_proximity>())).state as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_tablet_tool_proximity),
            "::",
            stringify!(state)
        )
    );
}
pub mod wlr_tablet_tool_tip_state {
    pub type Type = u32;
    pub const WLR_TABLET_TOOL_TIP_UP: Type = 0;
    pub const WLR_TABLET_TOOL_TIP_DOWN: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_event_tablet_tool_tip {
    pub device: *mut wlr_input_device,
    pub tool: *mut wlr_tablet_tool,
    pub time_msec: u32,
    pub x: f64,
    pub y: f64,
    pub state: wlr_tablet_tool_tip_state::Type,
}
#[test]
fn bindgen_test_layout_wlr_event_tablet_tool_tip() {
    assert_eq!(
        ::std::mem::size_of::<wlr_event_tablet_tool_tip>(),
        48usize,
        concat!("Size of: ", stringify!(wlr_event_tablet_tool_tip))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_event_tablet_tool_tip>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_event_tablet_tool_tip))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_tablet_tool_tip>())).device as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_tablet_tool_tip),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_event_tablet_tool_tip>())).tool as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_tablet_tool_tip),
            "::",
            stringify!(tool)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_tablet_tool_tip>())).time_msec as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_tablet_tool_tip),
            "::",
            stringify!(time_msec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_event_tablet_tool_tip>())).x as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_tablet_tool_tip),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_event_tablet_tool_tip>())).y as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_tablet_tool_tip),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_event_tablet_tool_tip>())).state as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_tablet_tool_tip),
            "::",
            stringify!(state)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_event_tablet_tool_button {
    pub device: *mut wlr_input_device,
    pub tool: *mut wlr_tablet_tool,
    pub time_msec: u32,
    pub button: u32,
    pub state: wlr_button_state::Type,
}
#[test]
fn bindgen_test_layout_wlr_event_tablet_tool_button() {
    assert_eq!(
        ::std::mem::size_of::<wlr_event_tablet_tool_button>(),
        32usize,
        concat!("Size of: ", stringify!(wlr_event_tablet_tool_button))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_event_tablet_tool_button>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_event_tablet_tool_button))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_tablet_tool_button>())).device as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_tablet_tool_button),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_tablet_tool_button>())).tool as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_tablet_tool_button),
            "::",
            stringify!(tool)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_tablet_tool_button>())).time_msec as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_tablet_tool_button),
            "::",
            stringify!(time_msec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_tablet_tool_button>())).button as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_tablet_tool_button),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_tablet_tool_button>())).state as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_tablet_tool_button),
            "::",
            stringify!(state)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_tablet_pad_impl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_tablet_pad {
    pub impl_: *mut wlr_tablet_pad_impl,
    pub events: wlr_tablet_pad__bindgen_ty_1,
    pub button_count: usize,
    pub ring_count: usize,
    pub strip_count: usize,
    pub groups: wl_list,
    pub paths: wlr_list,
    pub data: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_tablet_pad__bindgen_ty_1 {
    pub button: wl_signal,
    pub ring: wl_signal,
    pub strip: wl_signal,
    pub attach_tablet: wl_signal,
}
#[test]
fn bindgen_test_layout_wlr_tablet_pad__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wlr_tablet_pad__bindgen_ty_1>(),
        64usize,
        concat!("Size of: ", stringify!(wlr_tablet_pad__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_tablet_pad__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_tablet_pad__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_tablet_pad__bindgen_ty_1>())).button as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_tablet_pad__bindgen_ty_1),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_tablet_pad__bindgen_ty_1>())).ring as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_tablet_pad__bindgen_ty_1),
            "::",
            stringify!(ring)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_tablet_pad__bindgen_ty_1>())).strip as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_tablet_pad__bindgen_ty_1),
            "::",
            stringify!(strip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_tablet_pad__bindgen_ty_1>())).attach_tablet as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_tablet_pad__bindgen_ty_1),
            "::",
            stringify!(attach_tablet)
        )
    );
}
#[test]
fn bindgen_test_layout_wlr_tablet_pad() {
    assert_eq!(
        ::std::mem::size_of::<wlr_tablet_pad>(),
        144usize,
        concat!("Size of: ", stringify!(wlr_tablet_pad))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_tablet_pad>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_tablet_pad))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_tablet_pad>())).impl_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_tablet_pad),
            "::",
            stringify!(impl_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_tablet_pad>())).events as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_tablet_pad),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_tablet_pad>())).button_count as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_tablet_pad),
            "::",
            stringify!(button_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_tablet_pad>())).ring_count as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_tablet_pad),
            "::",
            stringify!(ring_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_tablet_pad>())).strip_count as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_tablet_pad),
            "::",
            stringify!(strip_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_tablet_pad>())).groups as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_tablet_pad),
            "::",
            stringify!(groups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_tablet_pad>())).paths as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_tablet_pad),
            "::",
            stringify!(paths)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_tablet_pad>())).data as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_tablet_pad),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_tablet_pad_group {
    pub link: wl_list,
    pub button_count: usize,
    pub buttons: *mut ::std::os::raw::c_uint,
    pub strip_count: usize,
    pub strips: *mut ::std::os::raw::c_uint,
    pub ring_count: usize,
    pub rings: *mut ::std::os::raw::c_uint,
    pub mode_count: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_wlr_tablet_pad_group() {
    assert_eq!(
        ::std::mem::size_of::<wlr_tablet_pad_group>(),
        72usize,
        concat!("Size of: ", stringify!(wlr_tablet_pad_group))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_tablet_pad_group>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_tablet_pad_group))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_tablet_pad_group>())).link as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_tablet_pad_group),
            "::",
            stringify!(link)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_tablet_pad_group>())).button_count as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_tablet_pad_group),
            "::",
            stringify!(button_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_tablet_pad_group>())).buttons as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_tablet_pad_group),
            "::",
            stringify!(buttons)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_tablet_pad_group>())).strip_count as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_tablet_pad_group),
            "::",
            stringify!(strip_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_tablet_pad_group>())).strips as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_tablet_pad_group),
            "::",
            stringify!(strips)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_tablet_pad_group>())).ring_count as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_tablet_pad_group),
            "::",
            stringify!(ring_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_tablet_pad_group>())).rings as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_tablet_pad_group),
            "::",
            stringify!(rings)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_tablet_pad_group>())).mode_count as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_tablet_pad_group),
            "::",
            stringify!(mode_count)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_event_tablet_pad_button {
    pub time_msec: u32,
    pub button: u32,
    pub state: wlr_button_state::Type,
    pub mode: ::std::os::raw::c_uint,
    pub group: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_wlr_event_tablet_pad_button() {
    assert_eq!(
        ::std::mem::size_of::<wlr_event_tablet_pad_button>(),
        20usize,
        concat!("Size of: ", stringify!(wlr_event_tablet_pad_button))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_event_tablet_pad_button>(),
        4usize,
        concat!("Alignment of ", stringify!(wlr_event_tablet_pad_button))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_tablet_pad_button>())).time_msec as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_tablet_pad_button),
            "::",
            stringify!(time_msec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_tablet_pad_button>())).button as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_tablet_pad_button),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_tablet_pad_button>())).state as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_tablet_pad_button),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_tablet_pad_button>())).mode as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_tablet_pad_button),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_tablet_pad_button>())).group as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_tablet_pad_button),
            "::",
            stringify!(group)
        )
    );
}
pub mod wlr_tablet_pad_ring_source {
    pub type Type = u32;
    pub const WLR_TABLET_PAD_RING_SOURCE_UNKNOWN: Type = 0;
    pub const WLR_TABLET_PAD_RING_SOURCE_FINGER: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_event_tablet_pad_ring {
    pub time_msec: u32,
    pub source: wlr_tablet_pad_ring_source::Type,
    pub ring: u32,
    pub position: f64,
    pub mode: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_wlr_event_tablet_pad_ring() {
    assert_eq!(
        ::std::mem::size_of::<wlr_event_tablet_pad_ring>(),
        32usize,
        concat!("Size of: ", stringify!(wlr_event_tablet_pad_ring))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_event_tablet_pad_ring>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_event_tablet_pad_ring))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_tablet_pad_ring>())).time_msec as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_tablet_pad_ring),
            "::",
            stringify!(time_msec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_tablet_pad_ring>())).source as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_tablet_pad_ring),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_event_tablet_pad_ring>())).ring as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_tablet_pad_ring),
            "::",
            stringify!(ring)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_tablet_pad_ring>())).position as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_tablet_pad_ring),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_event_tablet_pad_ring>())).mode as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_tablet_pad_ring),
            "::",
            stringify!(mode)
        )
    );
}
pub mod wlr_tablet_pad_strip_source {
    pub type Type = u32;
    pub const WLR_TABLET_PAD_STRIP_SOURCE_UNKNOWN: Type = 0;
    pub const WLR_TABLET_PAD_STRIP_SOURCE_FINGER: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_event_tablet_pad_strip {
    pub time_msec: u32,
    pub source: wlr_tablet_pad_strip_source::Type,
    pub strip: u32,
    pub position: f64,
    pub mode: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_wlr_event_tablet_pad_strip() {
    assert_eq!(
        ::std::mem::size_of::<wlr_event_tablet_pad_strip>(),
        32usize,
        concat!("Size of: ", stringify!(wlr_event_tablet_pad_strip))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_event_tablet_pad_strip>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_event_tablet_pad_strip))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_tablet_pad_strip>())).time_msec as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_tablet_pad_strip),
            "::",
            stringify!(time_msec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_tablet_pad_strip>())).source as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_tablet_pad_strip),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_tablet_pad_strip>())).strip as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_tablet_pad_strip),
            "::",
            stringify!(strip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_tablet_pad_strip>())).position as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_tablet_pad_strip),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_event_tablet_pad_strip>())).mode as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_tablet_pad_strip),
            "::",
            stringify!(mode)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_switch_impl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_switch {
    pub impl_: *mut wlr_switch_impl,
    pub events: wlr_switch__bindgen_ty_1,
    pub data: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_switch__bindgen_ty_1 {
    pub toggle: wl_signal,
}
#[test]
fn bindgen_test_layout_wlr_switch__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wlr_switch__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(wlr_switch__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_switch__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_switch__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_switch__bindgen_ty_1>())).toggle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_switch__bindgen_ty_1),
            "::",
            stringify!(toggle)
        )
    );
}
#[test]
fn bindgen_test_layout_wlr_switch() {
    assert_eq!(
        ::std::mem::size_of::<wlr_switch>(),
        32usize,
        concat!("Size of: ", stringify!(wlr_switch))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_switch>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_switch))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_switch>())).impl_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_switch),
            "::",
            stringify!(impl_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_switch>())).events as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_switch),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_switch>())).data as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_switch),
            "::",
            stringify!(data)
        )
    );
}
pub mod wlr_switch_type {
    pub type Type = u32;
    pub const WLR_SWITCH_TYPE_LID: Type = 1;
    pub const WLR_SWITCH_TYPE_TABLET_MODE: Type = 2;
}
pub mod wlr_switch_state {
    pub type Type = u32;
    pub const WLR_SWITCH_STATE_OFF: Type = 0;
    pub const WLR_SWITCH_STATE_ON: Type = 1;
    pub const WLR_SWITCH_STATE_TOGGLE: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_event_switch_toggle {
    pub device: *mut wlr_input_device,
    pub time_msec: u32,
    pub switch_type: wlr_switch_type::Type,
    pub switch_state: wlr_switch_state::Type,
}
#[test]
fn bindgen_test_layout_wlr_event_switch_toggle() {
    assert_eq!(
        ::std::mem::size_of::<wlr_event_switch_toggle>(),
        24usize,
        concat!("Size of: ", stringify!(wlr_event_switch_toggle))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_event_switch_toggle>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_event_switch_toggle))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_event_switch_toggle>())).device as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_switch_toggle),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_switch_toggle>())).time_msec as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_switch_toggle),
            "::",
            stringify!(time_msec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_switch_toggle>())).switch_type as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_switch_toggle),
            "::",
            stringify!(switch_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_event_switch_toggle>())).switch_state as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_event_switch_toggle),
            "::",
            stringify!(switch_state)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_input_device_impl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wlr_input_device {
    pub impl_: *const wlr_input_device_impl,
    pub type_: wlr_input_device_type::Type,
    pub vendor: ::std::os::raw::c_uint,
    pub product: ::std::os::raw::c_uint,
    pub name: *mut ::std::os::raw::c_char,
    pub width_mm: f64,
    pub height_mm: f64,
    pub output_name: *mut ::std::os::raw::c_char,
    pub __bindgen_anon_1: wlr_input_device__bindgen_ty_1,
    pub events: wlr_input_device__bindgen_ty_2,
    pub data: *mut ::std::os::raw::c_void,
    pub link: wl_list,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union wlr_input_device__bindgen_ty_1 {
    pub _device: *mut ::std::os::raw::c_void,
    pub keyboard: *mut wlr_keyboard,
    pub pointer: *mut wlr_pointer,
    pub switch_device: *mut wlr_switch,
    pub touch: *mut wlr_touch,
    pub tablet: *mut wlr_tablet,
    pub tablet_pad: *mut wlr_tablet_pad,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_wlr_input_device__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wlr_input_device__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(wlr_input_device__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_input_device__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_input_device__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_input_device__bindgen_ty_1>()))._device as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_input_device__bindgen_ty_1),
            "::",
            stringify!(_device)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_input_device__bindgen_ty_1>())).keyboard as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_input_device__bindgen_ty_1),
            "::",
            stringify!(keyboard)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_input_device__bindgen_ty_1>())).pointer as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_input_device__bindgen_ty_1),
            "::",
            stringify!(pointer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_input_device__bindgen_ty_1>())).switch_device as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_input_device__bindgen_ty_1),
            "::",
            stringify!(switch_device)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_input_device__bindgen_ty_1>())).touch as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_input_device__bindgen_ty_1),
            "::",
            stringify!(touch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_input_device__bindgen_ty_1>())).tablet as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_input_device__bindgen_ty_1),
            "::",
            stringify!(tablet)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_input_device__bindgen_ty_1>())).tablet_pad as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_input_device__bindgen_ty_1),
            "::",
            stringify!(tablet_pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_input_device__bindgen_ty_2 {
    pub destroy: wl_signal,
}
#[test]
fn bindgen_test_layout_wlr_input_device__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<wlr_input_device__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(wlr_input_device__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_input_device__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_input_device__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_input_device__bindgen_ty_2>())).destroy as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_input_device__bindgen_ty_2),
            "::",
            stringify!(destroy)
        )
    );
}
#[test]
fn bindgen_test_layout_wlr_input_device() {
    assert_eq!(
        ::std::mem::size_of::<wlr_input_device>(),
        104usize,
        concat!("Size of: ", stringify!(wlr_input_device))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_input_device>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_input_device))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_input_device>())).impl_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_input_device),
            "::",
            stringify!(impl_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_input_device>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_input_device),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_input_device>())).vendor as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_input_device),
            "::",
            stringify!(vendor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_input_device>())).product as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_input_device),
            "::",
            stringify!(product)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_input_device>())).name as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_input_device),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_input_device>())).width_mm as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_input_device),
            "::",
            stringify!(width_mm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_input_device>())).height_mm as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_input_device),
            "::",
            stringify!(height_mm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_input_device>())).output_name as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_input_device),
            "::",
            stringify!(output_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_input_device>())).events as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_input_device),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_input_device>())).data as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_input_device),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_input_device>())).link as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_input_device),
            "::",
            stringify!(link)
        )
    );
}
extern "C" {
    pub fn wlr_libinput_backend_create(
        display: *mut wl_display,
        session: *mut wlr_session,
    ) -> *mut wlr_backend;
}
extern "C" {
    #[doc = " Gets the underlying libinput_device handle for the given wlr_input_device"]
    pub fn wlr_libinput_get_device_handle(dev: *mut wlr_input_device) -> *mut libinput_device;
}
extern "C" {
    pub fn wlr_backend_is_libinput(backend: *mut wlr_backend) -> bool;
}
extern "C" {
    pub fn wlr_input_device_is_libinput(device: *mut wlr_input_device) -> bool;
}
extern "C" {
    #[doc = " Creates a multi-backend. Multi-backends wrap an arbitrary number of backends"]
    #[doc = " and aggregate their new_output/new_input signals."]
    pub fn wlr_multi_backend_create(display: *mut wl_display) -> *mut wlr_backend;
}
extern "C" {
    #[doc = " Adds the given backend to the multi backend. This should be done before the"]
    #[doc = " new backend is started."]
    pub fn wlr_multi_backend_add(multi: *mut wlr_backend, backend: *mut wlr_backend) -> bool;
}
extern "C" {
    pub fn wlr_multi_backend_remove(multi: *mut wlr_backend, backend: *mut wlr_backend);
}
extern "C" {
    pub fn wlr_backend_is_multi(backend: *mut wlr_backend) -> bool;
}
extern "C" {
    pub fn wlr_multi_is_empty(backend: *mut wlr_backend) -> bool;
}
extern "C" {
    pub fn wlr_multi_for_each_backend(
        backend: *mut wlr_backend,
        callback: ::std::option::Option<
            unsafe extern "C" fn(backend: *mut wlr_backend, data: *mut ::std::os::raw::c_void),
        >,
        data: *mut ::std::os::raw::c_void,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_texture_impl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_texture {
    pub impl_: *const wlr_texture_impl,
}
#[test]
fn bindgen_test_layout_wlr_texture() {
    assert_eq!(
        ::std::mem::size_of::<wlr_texture>(),
        8usize,
        concat!("Size of: ", stringify!(wlr_texture))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_texture>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_texture))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_texture>())).impl_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_texture),
            "::",
            stringify!(impl_)
        )
    );
}
extern "C" {
    #[doc = " Create a new texture from raw pixel data. `stride` is in bytes. The returned"]
    #[doc = " texture is mutable."]
    pub fn wlr_texture_from_pixels(
        renderer: *mut wlr_renderer,
        wl_fmt: wl_shm_format::Type,
        stride: u32,
        width: u32,
        height: u32,
        data: *const ::std::os::raw::c_void,
    ) -> *mut wlr_texture;
}
extern "C" {
    #[doc = " Create a new texture from a wl_drm resource. The returned texture is"]
    #[doc = " immutable."]
    pub fn wlr_texture_from_wl_drm(
        renderer: *mut wlr_renderer,
        data: *mut wl_resource,
    ) -> *mut wlr_texture;
}
extern "C" {
    #[doc = " Create a new texture from a DMA-BUF. The returned texture is immutable."]
    pub fn wlr_texture_from_dmabuf(
        renderer: *mut wlr_renderer,
        attribs: *mut wlr_dmabuf_attributes,
    ) -> *mut wlr_texture;
}
extern "C" {
    #[doc = " Get the texture width and height."]
    pub fn wlr_texture_get_size(
        texture: *mut wlr_texture,
        width: *mut ::std::os::raw::c_int,
        height: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Returns true if this texture is using a fully opaque format."]
    pub fn wlr_texture_is_opaque(texture: *mut wlr_texture) -> bool;
}
extern "C" {
    #[doc = " Update a texture with raw pixels. The texture must be mutable, and the input"]
    #[doc = " data must have the same pixel format that the texture was created with."]
    pub fn wlr_texture_write_pixels(
        texture: *mut wlr_texture,
        stride: u32,
        width: u32,
        height: u32,
        src_x: u32,
        src_y: u32,
        dst_x: u32,
        dst_y: u32,
        data: *const ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    pub fn wlr_texture_to_dmabuf(
        texture: *mut wlr_texture,
        attribs: *mut wlr_dmabuf_attributes,
    ) -> bool;
}
extern "C" {
    #[doc = " Destroys this wlr_texture."]
    pub fn wlr_texture_destroy(texture: *mut wlr_texture);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_box {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_wlr_box() {
    assert_eq!(
        ::std::mem::size_of::<wlr_box>(),
        16usize,
        concat!("Size of: ", stringify!(wlr_box))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_box>(),
        4usize,
        concat!("Alignment of ", stringify!(wlr_box))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_box>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_box),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_box>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_box),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_box>())).width as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_box),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_box>())).height as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_box),
            "::",
            stringify!(height)
        )
    );
}
extern "C" {
    pub fn wlr_box_closest_point(
        box_: *const wlr_box,
        x: f64,
        y: f64,
        dest_x: *mut f64,
        dest_y: *mut f64,
    );
}
extern "C" {
    pub fn wlr_box_intersection(
        dest: *mut wlr_box,
        box_a: *const wlr_box,
        box_b: *const wlr_box,
    ) -> bool;
}
extern "C" {
    pub fn wlr_box_contains_point(box_: *const wlr_box, x: f64, y: f64) -> bool;
}
extern "C" {
    pub fn wlr_box_empty(box_: *const wlr_box) -> bool;
}
extern "C" {
    #[doc = " Transforms a box inside a `width` x `height` box."]
    pub fn wlr_box_transform(
        dest: *mut wlr_box,
        box_: *const wlr_box,
        transform: wl_output_transform::Type,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Creates the smallest box that contains the box rotated about its center."]
    pub fn wlr_box_rotated_bounds(dest: *mut wlr_box, box_: *const wlr_box, rotation: f32);
}
extern "C" {
    pub fn wlr_box_from_pixman_box32(dest: *mut wlr_box, box_: pixman_box32_t);
}
pub mod wlr_renderer_read_pixels_flags {
    pub type Type = u32;
    pub const WLR_RENDERER_READ_PIXELS_Y_INVERT: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_renderer_impl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_renderer {
    pub impl_: *const wlr_renderer_impl,
    pub events: wlr_renderer__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_renderer__bindgen_ty_1 {
    pub destroy: wl_signal,
}
#[test]
fn bindgen_test_layout_wlr_renderer__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wlr_renderer__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(wlr_renderer__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_renderer__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_renderer__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_renderer__bindgen_ty_1>())).destroy as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_renderer__bindgen_ty_1),
            "::",
            stringify!(destroy)
        )
    );
}
#[test]
fn bindgen_test_layout_wlr_renderer() {
    assert_eq!(
        ::std::mem::size_of::<wlr_renderer>(),
        24usize,
        concat!("Size of: ", stringify!(wlr_renderer))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_renderer>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_renderer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_renderer>())).impl_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_renderer),
            "::",
            stringify!(impl_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_renderer>())).events as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_renderer),
            "::",
            stringify!(events)
        )
    );
}
extern "C" {
    pub fn wlr_renderer_autocreate(
        egl: *mut wlr_egl,
        platform: EGLenum,
        remote_display: *mut ::std::os::raw::c_void,
        config_attribs: *mut EGLint,
        visual_id: EGLint,
    ) -> *mut wlr_renderer;
}
extern "C" {
    pub fn wlr_renderer_begin(
        r: *mut wlr_renderer,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn wlr_renderer_end(r: *mut wlr_renderer);
}
extern "C" {
    pub fn wlr_renderer_clear(r: *mut wlr_renderer, color: *const f32);
}
extern "C" {
    #[doc = " Defines a scissor box. Only pixels that lie within the scissor box can be"]
    #[doc = " modified by drawing functions. Providing a NULL `box` disables the scissor"]
    #[doc = " box."]
    pub fn wlr_renderer_scissor(r: *mut wlr_renderer, box_: *mut wlr_box);
}
extern "C" {
    #[doc = " Renders the requested texture."]
    pub fn wlr_render_texture(
        r: *mut wlr_renderer,
        texture: *mut wlr_texture,
        projection: *const f32,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        alpha: f32,
    ) -> bool;
}
extern "C" {
    #[doc = " Renders the requested texture using the provided matrix."]
    pub fn wlr_render_texture_with_matrix(
        r: *mut wlr_renderer,
        texture: *mut wlr_texture,
        matrix: *const f32,
        alpha: f32,
    ) -> bool;
}
extern "C" {
    #[doc = " Renders a solid rectangle in the specified color."]
    pub fn wlr_render_rect(
        r: *mut wlr_renderer,
        box_: *const wlr_box,
        color: *const f32,
        projection: *const f32,
    );
}
extern "C" {
    #[doc = " Renders a solid quadrangle in the specified color with the specified matrix."]
    pub fn wlr_render_quad_with_matrix(r: *mut wlr_renderer, color: *const f32, matrix: *const f32);
}
extern "C" {
    #[doc = " Renders a solid ellipse in the specified color."]
    pub fn wlr_render_ellipse(
        r: *mut wlr_renderer,
        box_: *const wlr_box,
        color: *const f32,
        projection: *const f32,
    );
}
extern "C" {
    #[doc = " Renders a solid ellipse in the specified color with the specified matrix."]
    pub fn wlr_render_ellipse_with_matrix(
        r: *mut wlr_renderer,
        color: *const f32,
        matrix: *const f32,
    );
}
extern "C" {
    #[doc = " Returns a list of pixel formats supported by this renderer."]
    pub fn wlr_renderer_get_formats(
        r: *mut wlr_renderer,
        len: *mut usize,
    ) -> *const wl_shm_format::Type;
}
extern "C" {
    #[doc = " Returns true if this wl_buffer is a wl_drm buffer."]
    pub fn wlr_renderer_resource_is_wl_drm_buffer(
        renderer: *mut wlr_renderer,
        buffer: *mut wl_resource,
    ) -> bool;
}
extern "C" {
    #[doc = " Gets the width and height of a wl_drm buffer."]
    pub fn wlr_renderer_wl_drm_buffer_get_size(
        renderer: *mut wlr_renderer,
        buffer: *mut wl_resource,
        width: *mut ::std::os::raw::c_int,
        height: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Get the available DMA-BUF formats."]
    pub fn wlr_renderer_get_dmabuf_formats(
        renderer: *mut wlr_renderer,
    ) -> *const wlr_drm_format_set;
}
extern "C" {
    #[doc = " Reads out of pixels of the currently bound surface into data. `stride` is in"]
    #[doc = " bytes."]
    #[doc = ""]
    #[doc = " If `flags` is not NULl, the caller indicates that it accepts frame flags"]
    #[doc = " defined in `enum wlr_renderer_read_pixels_flags`."]
    pub fn wlr_renderer_read_pixels(
        r: *mut wlr_renderer,
        fmt: wl_shm_format::Type,
        flags: *mut u32,
        stride: u32,
        width: u32,
        height: u32,
        src_x: u32,
        src_y: u32,
        dst_x: u32,
        dst_y: u32,
        data: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " Checks if a format is supported."]
    pub fn wlr_renderer_format_supported(r: *mut wlr_renderer, fmt: wl_shm_format::Type) -> bool;
}
extern "C" {
    pub fn wlr_renderer_init_wl_display(r: *mut wlr_renderer, wl_display: *mut wl_display);
}
extern "C" {
    #[doc = " Destroys this wlr_renderer. Textures must be destroyed separately."]
    pub fn wlr_renderer_destroy(renderer: *mut wlr_renderer);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_subcompositor {
    pub global: *mut wl_global,
    pub resources: wl_list,
    pub subsurface_resources: wl_list,
}
#[test]
fn bindgen_test_layout_wlr_subcompositor() {
    assert_eq!(
        ::std::mem::size_of::<wlr_subcompositor>(),
        40usize,
        concat!("Size of: ", stringify!(wlr_subcompositor))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_subcompositor>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_subcompositor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_subcompositor>())).global as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_subcompositor),
            "::",
            stringify!(global)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_subcompositor>())).resources as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_subcompositor),
            "::",
            stringify!(resources)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_subcompositor>())).subsurface_resources as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_subcompositor),
            "::",
            stringify!(subsurface_resources)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_compositor {
    pub global: *mut wl_global,
    pub resources: wl_list,
    pub renderer: *mut wlr_renderer,
    pub surface_resources: wl_list,
    pub region_resources: wl_list,
    pub subcompositor: wlr_subcompositor,
    pub display_destroy: wl_listener,
    pub events: wlr_compositor__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_compositor__bindgen_ty_1 {
    pub new_surface: wl_signal,
    pub destroy: wl_signal,
}
#[test]
fn bindgen_test_layout_wlr_compositor__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wlr_compositor__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(wlr_compositor__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_compositor__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_compositor__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_compositor__bindgen_ty_1>())).new_surface as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_compositor__bindgen_ty_1),
            "::",
            stringify!(new_surface)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_compositor__bindgen_ty_1>())).destroy as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_compositor__bindgen_ty_1),
            "::",
            stringify!(destroy)
        )
    );
}
#[test]
fn bindgen_test_layout_wlr_compositor() {
    assert_eq!(
        ::std::mem::size_of::<wlr_compositor>(),
        160usize,
        concat!("Size of: ", stringify!(wlr_compositor))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_compositor>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_compositor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_compositor>())).global as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_compositor),
            "::",
            stringify!(global)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_compositor>())).resources as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_compositor),
            "::",
            stringify!(resources)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_compositor>())).renderer as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_compositor),
            "::",
            stringify!(renderer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_compositor>())).surface_resources as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_compositor),
            "::",
            stringify!(surface_resources)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_compositor>())).region_resources as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_compositor),
            "::",
            stringify!(region_resources)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_compositor>())).subcompositor as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_compositor),
            "::",
            stringify!(subcompositor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_compositor>())).display_destroy as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_compositor),
            "::",
            stringify!(display_destroy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_compositor>())).events as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_compositor),
            "::",
            stringify!(events)
        )
    );
}
extern "C" {
    pub fn wlr_compositor_destroy(wlr_compositor: *mut wlr_compositor);
}
extern "C" {
    pub fn wlr_compositor_create(
        display: *mut wl_display,
        renderer: *mut wlr_renderer,
    ) -> *mut wlr_compositor;
}
extern "C" {
    pub fn wlr_surface_is_subsurface(surface: *mut wlr_surface) -> bool;
}
extern "C" {
    #[doc = " Get a subsurface from a surface. Can return NULL if the subsurface has been"]
    #[doc = " destroyed."]
    pub fn wlr_subsurface_from_wlr_surface(surface: *mut wlr_surface) -> *mut wlr_subsurface;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_hour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mday as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_year as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_wday as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_yday as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_isdst as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_gmtoff as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_zone as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__locales as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_b as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_tolower as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_toupper as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__names as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn strftime_l(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asctime_r(
        __tp: *const tm,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        __timer: *const time_t,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub static mut __daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub fn stime(__when: *const time_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::std::os::raw::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::std::os::raw::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(
        __ts: *mut timespec,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[doc = " A client buffer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_buffer {
    #[doc = " The buffer resource, if any. Will be NULL if the client destroys it."]
    pub resource: *mut wl_resource,
    #[doc = " The buffer's texture, if any. A buffer will not have a texture if the"]
    #[doc = " client destroys the buffer before it has been released."]
    pub texture: *mut wlr_texture,
    pub released: bool,
    pub n_refs: usize,
    pub resource_destroy: wl_listener,
}
#[test]
fn bindgen_test_layout_wlr_buffer() {
    assert_eq!(
        ::std::mem::size_of::<wlr_buffer>(),
        56usize,
        concat!("Size of: ", stringify!(wlr_buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_buffer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_buffer>())).resource as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_buffer),
            "::",
            stringify!(resource)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_buffer>())).texture as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_buffer),
            "::",
            stringify!(texture)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_buffer>())).released as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_buffer),
            "::",
            stringify!(released)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_buffer>())).n_refs as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_buffer),
            "::",
            stringify!(n_refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_buffer>())).resource_destroy as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_buffer),
            "::",
            stringify!(resource_destroy)
        )
    );
}
extern "C" {
    #[doc = " Check if a resource is a wl_buffer resource."]
    pub fn wlr_resource_is_buffer(resource: *mut wl_resource) -> bool;
}
extern "C" {
    #[doc = " Get the size of a wl_buffer resource."]
    pub fn wlr_buffer_get_resource_size(
        resource: *mut wl_resource,
        renderer: *mut wlr_renderer,
        width: *mut ::std::os::raw::c_int,
        height: *mut ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[doc = " Upload a buffer to the GPU and reference it."]
    pub fn wlr_buffer_create(
        renderer: *mut wlr_renderer,
        resource: *mut wl_resource,
    ) -> *mut wlr_buffer;
}
extern "C" {
    #[doc = " Reference the buffer."]
    pub fn wlr_buffer_ref(buffer: *mut wlr_buffer) -> *mut wlr_buffer;
}
extern "C" {
    #[doc = " Unreference the buffer. After this call, `buffer` may not be accessed"]
    #[doc = " anymore."]
    pub fn wlr_buffer_unref(buffer: *mut wlr_buffer);
}
extern "C" {
    #[doc = " Try to update the buffer's content. On success, returns the updated buffer"]
    #[doc = " and destroys the provided `buffer`. On error, `buffer` is intact and NULL is"]
    #[doc = " returned."]
    #[doc = ""]
    #[doc = " Fails if there's more than one reference to the buffer or if the texture"]
    #[doc = " isn't mutable."]
    pub fn wlr_buffer_apply_damage(
        buffer: *mut wlr_buffer,
        resource: *mut wl_resource,
        damage: *mut pixman_region32_t,
    ) -> *mut wlr_buffer;
}
extern "C" {
    #[doc = " Reads the DMA-BUF attributes of the buffer. If this buffer isn't a DMA-BUF,"]
    #[doc = " returns false."]
    pub fn wlr_buffer_get_dmabuf(
        buffer: *mut wlr_buffer,
        attribs: *mut wlr_dmabuf_attributes,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_output_mode {
    pub width: i32,
    pub height: i32,
    pub refresh: i32,
    pub preferred: bool,
    pub link: wl_list,
}
#[test]
fn bindgen_test_layout_wlr_output_mode() {
    assert_eq!(
        ::std::mem::size_of::<wlr_output_mode>(),
        32usize,
        concat!("Size of: ", stringify!(wlr_output_mode))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_output_mode>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_output_mode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output_mode>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output_mode),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output_mode>())).height as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output_mode),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output_mode>())).refresh as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output_mode),
            "::",
            stringify!(refresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output_mode>())).preferred as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output_mode),
            "::",
            stringify!(preferred)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output_mode>())).link as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output_mode),
            "::",
            stringify!(link)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_output_cursor {
    pub output: *mut wlr_output,
    pub x: f64,
    pub y: f64,
    pub enabled: bool,
    pub visible: bool,
    pub width: u32,
    pub height: u32,
    pub hotspot_x: i32,
    pub hotspot_y: i32,
    pub link: wl_list,
    pub texture: *mut wlr_texture,
    pub surface: *mut wlr_surface,
    pub surface_commit: wl_listener,
    pub surface_destroy: wl_listener,
    pub events: wlr_output_cursor__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_output_cursor__bindgen_ty_1 {
    pub destroy: wl_signal,
}
#[test]
fn bindgen_test_layout_wlr_output_cursor__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wlr_output_cursor__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(wlr_output_cursor__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_output_cursor__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_output_cursor__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_output_cursor__bindgen_ty_1>())).destroy as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output_cursor__bindgen_ty_1),
            "::",
            stringify!(destroy)
        )
    );
}
#[test]
fn bindgen_test_layout_wlr_output_cursor() {
    assert_eq!(
        ::std::mem::size_of::<wlr_output_cursor>(),
        144usize,
        concat!("Size of: ", stringify!(wlr_output_cursor))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_output_cursor>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_output_cursor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output_cursor>())).output as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output_cursor),
            "::",
            stringify!(output)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output_cursor>())).x as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output_cursor),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output_cursor>())).y as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output_cursor),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output_cursor>())).enabled as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output_cursor),
            "::",
            stringify!(enabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output_cursor>())).visible as *const _ as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output_cursor),
            "::",
            stringify!(visible)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output_cursor>())).width as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output_cursor),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output_cursor>())).height as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output_cursor),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output_cursor>())).hotspot_x as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output_cursor),
            "::",
            stringify!(hotspot_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output_cursor>())).hotspot_y as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output_cursor),
            "::",
            stringify!(hotspot_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output_cursor>())).link as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output_cursor),
            "::",
            stringify!(link)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output_cursor>())).texture as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output_cursor),
            "::",
            stringify!(texture)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output_cursor>())).surface as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output_cursor),
            "::",
            stringify!(surface)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_output_cursor>())).surface_commit as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output_cursor),
            "::",
            stringify!(surface_commit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_output_cursor>())).surface_destroy as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output_cursor),
            "::",
            stringify!(surface_destroy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output_cursor>())).events as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output_cursor),
            "::",
            stringify!(events)
        )
    );
}
pub mod wlr_output_state_field {
    pub type Type = u32;
    pub const WLR_OUTPUT_STATE_BUFFER: Type = 1;
    pub const WLR_OUTPUT_STATE_DAMAGE: Type = 2;
}
pub mod wlr_output_state_buffer_type {
    pub type Type = u32;
    pub const WLR_OUTPUT_STATE_BUFFER_RENDER: Type = 0;
    pub const WLR_OUTPUT_STATE_BUFFER_SCANOUT: Type = 1;
}
#[doc = " Holds the double-buffered output state."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_output_state {
    pub committed: u32,
    pub damage: pixman_region32_t,
    pub buffer_type: wlr_output_state_buffer_type::Type,
    pub buffer: *mut wlr_buffer,
}
#[test]
fn bindgen_test_layout_wlr_output_state() {
    assert_eq!(
        ::std::mem::size_of::<wlr_output_state>(),
        48usize,
        concat!("Size of: ", stringify!(wlr_output_state))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_output_state>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_output_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output_state>())).committed as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output_state),
            "::",
            stringify!(committed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output_state>())).damage as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output_state),
            "::",
            stringify!(damage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output_state>())).buffer_type as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output_state),
            "::",
            stringify!(buffer_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output_state>())).buffer as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output_state),
            "::",
            stringify!(buffer)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_output_impl {
    _unused: [u8; 0],
}
#[doc = " A compositor output region. This typically corresponds to a monitor that"]
#[doc = " displays part of the compositor space."]
#[doc = ""]
#[doc = " The `frame` event will be emitted when it is a good time for the compositor"]
#[doc = " to submit a new frame."]
#[doc = ""]
#[doc = " To render a new frame, compositors should call `wlr_output_attach_render`,"]
#[doc = " render and call `wlr_output_commit`. No rendering should happen outside a"]
#[doc = " `frame` event handler or before `wlr_output_attach_render`."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wlr_output {
    pub impl_: *const wlr_output_impl,
    pub backend: *mut wlr_backend,
    pub display: *mut wl_display,
    pub global: *mut wl_global,
    pub resources: wl_list,
    pub name: [::std::os::raw::c_char; 24usize],
    pub make: [::std::os::raw::c_char; 56usize],
    pub model: [::std::os::raw::c_char; 16usize],
    pub serial: [::std::os::raw::c_char; 16usize],
    pub phys_width: i32,
    pub phys_height: i32,
    pub modes: wl_list,
    pub current_mode: *mut wlr_output_mode,
    pub width: i32,
    pub height: i32,
    pub refresh: i32,
    pub enabled: bool,
    pub scale: f32,
    pub subpixel: wl_output_subpixel::Type,
    pub transform: wl_output_transform::Type,
    pub needs_frame: bool,
    pub damage: pixman_region32_t,
    pub frame_pending: bool,
    pub transform_matrix: [f32; 9usize],
    pub pending: wlr_output_state,
    pub events: wlr_output__bindgen_ty_1,
    pub idle_frame: *mut wl_event_source,
    pub idle_done: *mut wl_event_source,
    pub attach_render_locks: ::std::os::raw::c_int,
    pub cursors: wl_list,
    pub hardware_cursor: *mut wlr_output_cursor,
    pub software_cursor_locks: ::std::os::raw::c_int,
    pub display_destroy: wl_listener,
    pub data: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_output__bindgen_ty_1 {
    pub frame: wl_signal,
    pub needs_frame: wl_signal,
    pub precommit: wl_signal,
    pub commit: wl_signal,
    pub present: wl_signal,
    pub enable: wl_signal,
    pub mode: wl_signal,
    pub scale: wl_signal,
    pub transform: wl_signal,
    pub destroy: wl_signal,
}
#[test]
fn bindgen_test_layout_wlr_output__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wlr_output__bindgen_ty_1>(),
        160usize,
        concat!("Size of: ", stringify!(wlr_output__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_output__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_output__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output__bindgen_ty_1>())).frame as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output__bindgen_ty_1),
            "::",
            stringify!(frame)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_output__bindgen_ty_1>())).needs_frame as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output__bindgen_ty_1),
            "::",
            stringify!(needs_frame)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_output__bindgen_ty_1>())).precommit as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output__bindgen_ty_1),
            "::",
            stringify!(precommit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output__bindgen_ty_1>())).commit as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output__bindgen_ty_1),
            "::",
            stringify!(commit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_output__bindgen_ty_1>())).present as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output__bindgen_ty_1),
            "::",
            stringify!(present)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output__bindgen_ty_1>())).enable as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output__bindgen_ty_1),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output__bindgen_ty_1>())).mode as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output__bindgen_ty_1),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output__bindgen_ty_1>())).scale as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output__bindgen_ty_1),
            "::",
            stringify!(scale)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_output__bindgen_ty_1>())).transform as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output__bindgen_ty_1),
            "::",
            stringify!(transform)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_output__bindgen_ty_1>())).destroy as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output__bindgen_ty_1),
            "::",
            stringify!(destroy)
        )
    );
}
#[test]
fn bindgen_test_layout_wlr_output() {
    assert_eq!(
        ::std::mem::size_of::<wlr_output>(),
        584usize,
        concat!("Size of: ", stringify!(wlr_output))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_output>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_output))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output>())).impl_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output),
            "::",
            stringify!(impl_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output>())).backend as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output),
            "::",
            stringify!(backend)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output>())).display as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output>())).global as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output),
            "::",
            stringify!(global)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output>())).resources as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output),
            "::",
            stringify!(resources)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output>())).name as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output>())).make as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output),
            "::",
            stringify!(make)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output>())).model as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output),
            "::",
            stringify!(model)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output>())).serial as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output>())).phys_width as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output),
            "::",
            stringify!(phys_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output>())).phys_height as *const _ as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output),
            "::",
            stringify!(phys_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output>())).modes as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output),
            "::",
            stringify!(modes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output>())).current_mode as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output),
            "::",
            stringify!(current_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output>())).width as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output>())).height as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output>())).refresh as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output),
            "::",
            stringify!(refresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output>())).enabled as *const _ as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output),
            "::",
            stringify!(enabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output>())).scale as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output),
            "::",
            stringify!(scale)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output>())).subpixel as *const _ as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output),
            "::",
            stringify!(subpixel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output>())).transform as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output),
            "::",
            stringify!(transform)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output>())).needs_frame as *const _ as usize },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output),
            "::",
            stringify!(needs_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output>())).damage as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output),
            "::",
            stringify!(damage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output>())).frame_pending as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output),
            "::",
            stringify!(frame_pending)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output>())).transform_matrix as *const _ as usize },
        252usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output),
            "::",
            stringify!(transform_matrix)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output>())).pending as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output),
            "::",
            stringify!(pending)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output>())).events as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output>())).idle_frame as *const _ as usize },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output),
            "::",
            stringify!(idle_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output>())).idle_done as *const _ as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output),
            "::",
            stringify!(idle_done)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output>())).attach_render_locks as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output),
            "::",
            stringify!(attach_render_locks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output>())).cursors as *const _ as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output),
            "::",
            stringify!(cursors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output>())).hardware_cursor as *const _ as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output),
            "::",
            stringify!(hardware_cursor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_output>())).software_cursor_locks as *const _ as usize
        },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output),
            "::",
            stringify!(software_cursor_locks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output>())).display_destroy as *const _ as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output),
            "::",
            stringify!(display_destroy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output>())).data as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_output_event_precommit {
    pub output: *mut wlr_output,
    pub when: *mut timespec,
}
#[test]
fn bindgen_test_layout_wlr_output_event_precommit() {
    assert_eq!(
        ::std::mem::size_of::<wlr_output_event_precommit>(),
        16usize,
        concat!("Size of: ", stringify!(wlr_output_event_precommit))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_output_event_precommit>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_output_event_precommit))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_output_event_precommit>())).output as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output_event_precommit),
            "::",
            stringify!(output)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output_event_precommit>())).when as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output_event_precommit),
            "::",
            stringify!(when)
        )
    );
}
pub mod wlr_output_present_flag {
    pub type Type = u32;
    pub const WLR_OUTPUT_PRESENT_VSYNC: Type = 1;
    pub const WLR_OUTPUT_PRESENT_HW_CLOCK: Type = 2;
    pub const WLR_OUTPUT_PRESENT_HW_COMPLETION: Type = 4;
    pub const WLR_OUTPUT_PRESENT_ZERO_COPY: Type = 8;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_output_event_present {
    pub output: *mut wlr_output,
    pub when: *mut timespec,
    pub seq: ::std::os::raw::c_uint,
    pub refresh: ::std::os::raw::c_int,
    pub flags: u32,
}
#[test]
fn bindgen_test_layout_wlr_output_event_present() {
    assert_eq!(
        ::std::mem::size_of::<wlr_output_event_present>(),
        32usize,
        concat!("Size of: ", stringify!(wlr_output_event_present))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_output_event_present>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_output_event_present))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output_event_present>())).output as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output_event_present),
            "::",
            stringify!(output)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output_event_present>())).when as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output_event_present),
            "::",
            stringify!(when)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output_event_present>())).seq as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output_event_present),
            "::",
            stringify!(seq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_output_event_present>())).refresh as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output_event_present),
            "::",
            stringify!(refresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output_event_present>())).flags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output_event_present),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    #[doc = " Enables or disables the output. A disabled output is turned off and doesn't"]
    #[doc = " emit `frame` events."]
    pub fn wlr_output_enable(output: *mut wlr_output, enable: bool) -> bool;
}
extern "C" {
    pub fn wlr_output_create_global(output: *mut wlr_output);
}
extern "C" {
    pub fn wlr_output_destroy_global(output: *mut wlr_output);
}
extern "C" {
    #[doc = " Returns the preferred mode for this output. If the output doesn't support"]
    #[doc = " modes, returns NULL."]
    pub fn wlr_output_preferred_mode(output: *mut wlr_output) -> *mut wlr_output_mode;
}
extern "C" {
    #[doc = " Sets the output mode. Enables the output if it's currently disabled."]
    pub fn wlr_output_set_mode(output: *mut wlr_output, mode: *mut wlr_output_mode) -> bool;
}
extern "C" {
    #[doc = " Sets a custom mode on the output. If modes are available, they are preferred."]
    #[doc = " Setting `refresh` to zero lets the backend pick a preferred value."]
    pub fn wlr_output_set_custom_mode(
        output: *mut wlr_output,
        width: i32,
        height: i32,
        refresh: i32,
    ) -> bool;
}
extern "C" {
    pub fn wlr_output_set_transform(output: *mut wlr_output, transform: wl_output_transform::Type);
}
extern "C" {
    pub fn wlr_output_set_scale(output: *mut wlr_output, scale: f32);
}
extern "C" {
    pub fn wlr_output_set_subpixel(output: *mut wlr_output, subpixel: wl_output_subpixel::Type);
}
extern "C" {
    #[doc = " Schedule a done event."]
    #[doc = ""]
    #[doc = " This is intended to be used by wl_output add-on interfaces."]
    pub fn wlr_output_schedule_done(output: *mut wlr_output);
}
extern "C" {
    pub fn wlr_output_destroy(output: *mut wlr_output);
}
extern "C" {
    #[doc = " Computes the transformed output resolution."]
    pub fn wlr_output_transformed_resolution(
        output: *mut wlr_output,
        width: *mut ::std::os::raw::c_int,
        height: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Computes the transformed and scaled output resolution."]
    pub fn wlr_output_effective_resolution(
        output: *mut wlr_output,
        width: *mut ::std::os::raw::c_int,
        height: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Attach the renderer's buffer to the output. Compositors must call this"]
    #[doc = " function before rendering. After they are done rendering, they should call"]
    #[doc = " `wlr_output_commit` to submit the new frame."]
    #[doc = ""]
    #[doc = " If non-NULL, `buffer_age` is set to the drawing buffer age in number of"]
    #[doc = " frames or -1 if unknown. This is useful for damage tracking."]
    pub fn wlr_output_attach_render(
        output: *mut wlr_output,
        buffer_age: *mut ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[doc = " Attach a buffer to the output. Compositors should call `wlr_output_commit`"]
    #[doc = " to submit the new frame."]
    pub fn wlr_output_attach_buffer(output: *mut wlr_output, buffer: *mut wlr_buffer) -> bool;
}
extern "C" {
    #[doc = " Get the preferred format for reading pixels."]
    #[doc = " This function might change the current rendering context."]
    pub fn wlr_output_preferred_read_format(
        output: *mut wlr_output,
        fmt: *mut wl_shm_format::Type,
    ) -> bool;
}
extern "C" {
    #[doc = " Set the damage region for the frame to be submitted. This is the region of"]
    #[doc = " the screen that has changed since the last frame."]
    #[doc = ""]
    #[doc = " Compositors implementing damage tracking should call this function with the"]
    #[doc = " damaged region in output-buffer-local coordinates (ie. scaled and"]
    #[doc = " transformed)."]
    #[doc = ""]
    #[doc = " This region is not to be confused with the renderer's buffer damage, ie. the"]
    #[doc = " region compositors need to repaint. Compositors usually need to repaint more"]
    #[doc = " than what changed since last frame since multiple render buffers are used."]
    pub fn wlr_output_set_damage(output: *mut wlr_output, damage: *mut pixman_region32_t);
}
extern "C" {
    #[doc = " Commit the pending output state. If `wlr_output_attach_render` has been"]
    #[doc = " called, the pending frame will be submitted for display."]
    #[doc = ""]
    #[doc = " This function schedules a `frame` event."]
    pub fn wlr_output_commit(output: *mut wlr_output) -> bool;
}
extern "C" {
    #[doc = " Manually schedules a `frame` event. If a `frame` event is already pending,"]
    #[doc = " it is a no-op."]
    pub fn wlr_output_schedule_frame(output: *mut wlr_output);
}
extern "C" {
    #[doc = " Returns the maximum length of each gamma ramp, or 0 if unsupported."]
    pub fn wlr_output_get_gamma_size(output: *mut wlr_output) -> usize;
}
extern "C" {
    #[doc = " Sets the gamma table for this output. `r`, `g` and `b` are gamma ramps for"]
    #[doc = " red, green and blue. `size` is the length of the ramps and must not exceed"]
    #[doc = " the value returned by `wlr_output_get_gamma_size`."]
    #[doc = ""]
    #[doc = " Providing zero-sized ramps resets the gamma table."]
    pub fn wlr_output_set_gamma(
        output: *mut wlr_output,
        size: usize,
        r: *const u16,
        g: *const u16,
        b: *const u16,
    ) -> bool;
}
extern "C" {
    pub fn wlr_output_export_dmabuf(
        output: *mut wlr_output,
        attribs: *mut wlr_dmabuf_attributes,
    ) -> bool;
}
extern "C" {
    pub fn wlr_output_from_resource(resource: *mut wl_resource) -> *mut wlr_output;
}
extern "C" {
    #[doc = " Locks the output to only use rendering instead of direct scan-out. This is"]
    #[doc = " useful if direct scan-out needs to be temporarily disabled (e.g. during"]
    #[doc = " screen capture). There must be as many unlocks as there have been locks to"]
    #[doc = " restore the original state. There should never be an unlock before a lock."]
    pub fn wlr_output_lock_attach_render(output: *mut wlr_output, lock: bool);
}
extern "C" {
    #[doc = " Locks the output to only use software cursors instead of hardware cursors."]
    #[doc = " This is useful if hardware cursors need to be temporarily disabled (e.g."]
    #[doc = " during screen capture). There must be as many unlocks as there have been"]
    #[doc = " locks to restore the original state. There should never be an unlock before"]
    #[doc = " a lock."]
    pub fn wlr_output_lock_software_cursors(output: *mut wlr_output, lock: bool);
}
extern "C" {
    #[doc = " Renders software cursors. This is a utility function that can be called when"]
    #[doc = " compositors render."]
    pub fn wlr_output_render_software_cursors(
        output: *mut wlr_output,
        damage: *mut pixman_region32_t,
    );
}
extern "C" {
    pub fn wlr_output_cursor_create(output: *mut wlr_output) -> *mut wlr_output_cursor;
}
extern "C" {
    #[doc = " Sets the cursor image. The image must be already scaled for the output."]
    pub fn wlr_output_cursor_set_image(
        cursor: *mut wlr_output_cursor,
        pixels: *const u8,
        stride: i32,
        width: u32,
        height: u32,
        hotspot_x: i32,
        hotspot_y: i32,
    ) -> bool;
}
extern "C" {
    pub fn wlr_output_cursor_set_surface(
        cursor: *mut wlr_output_cursor,
        surface: *mut wlr_surface,
        hotspot_x: i32,
        hotspot_y: i32,
    );
}
extern "C" {
    pub fn wlr_output_cursor_move(cursor: *mut wlr_output_cursor, x: f64, y: f64) -> bool;
}
extern "C" {
    pub fn wlr_output_cursor_destroy(cursor: *mut wlr_output_cursor);
}
extern "C" {
    #[doc = " Returns the transform that, when composed with `tr`, gives"]
    #[doc = " `WL_OUTPUT_TRANSFORM_NORMAL`."]
    pub fn wlr_output_transform_invert(tr: wl_output_transform::Type) -> wl_output_transform::Type;
}
extern "C" {
    #[doc = " Returns a transform that, when applied, has the same effect as applying"]
    #[doc = " sequentially `tr_a` and `tr_b`."]
    pub fn wlr_output_transform_compose(
        tr_a: wl_output_transform::Type,
        tr_b: wl_output_transform::Type,
    ) -> wl_output_transform::Type;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_output_layout_state {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_output_layout {
    pub outputs: wl_list,
    pub state: *mut wlr_output_layout_state,
    pub events: wlr_output_layout__bindgen_ty_1,
    pub data: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_output_layout__bindgen_ty_1 {
    pub add: wl_signal,
    pub change: wl_signal,
    pub destroy: wl_signal,
}
#[test]
fn bindgen_test_layout_wlr_output_layout__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wlr_output_layout__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(wlr_output_layout__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_output_layout__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_output_layout__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_output_layout__bindgen_ty_1>())).add as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output_layout__bindgen_ty_1),
            "::",
            stringify!(add)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_output_layout__bindgen_ty_1>())).change as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output_layout__bindgen_ty_1),
            "::",
            stringify!(change)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_output_layout__bindgen_ty_1>())).destroy as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output_layout__bindgen_ty_1),
            "::",
            stringify!(destroy)
        )
    );
}
#[test]
fn bindgen_test_layout_wlr_output_layout() {
    assert_eq!(
        ::std::mem::size_of::<wlr_output_layout>(),
        80usize,
        concat!("Size of: ", stringify!(wlr_output_layout))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_output_layout>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_output_layout))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output_layout>())).outputs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output_layout),
            "::",
            stringify!(outputs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output_layout>())).state as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output_layout),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output_layout>())).events as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output_layout),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output_layout>())).data as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output_layout),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_output_layout_output_state {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_output_layout_output {
    pub output: *mut wlr_output,
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub link: wl_list,
    pub state: *mut wlr_output_layout_output_state,
    pub events: wlr_output_layout_output__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_output_layout_output__bindgen_ty_1 {
    pub destroy: wl_signal,
}
#[test]
fn bindgen_test_layout_wlr_output_layout_output__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wlr_output_layout_output__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(wlr_output_layout_output__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_output_layout_output__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(wlr_output_layout_output__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_output_layout_output__bindgen_ty_1>())).destroy as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output_layout_output__bindgen_ty_1),
            "::",
            stringify!(destroy)
        )
    );
}
#[test]
fn bindgen_test_layout_wlr_output_layout_output() {
    assert_eq!(
        ::std::mem::size_of::<wlr_output_layout_output>(),
        56usize,
        concat!("Size of: ", stringify!(wlr_output_layout_output))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_output_layout_output>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_output_layout_output))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output_layout_output>())).output as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output_layout_output),
            "::",
            stringify!(output)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output_layout_output>())).x as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output_layout_output),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output_layout_output>())).y as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output_layout_output),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output_layout_output>())).link as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output_layout_output),
            "::",
            stringify!(link)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output_layout_output>())).state as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output_layout_output),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output_layout_output>())).events as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output_layout_output),
            "::",
            stringify!(events)
        )
    );
}
extern "C" {
    #[doc = " Creates a wlr_output_layout, which can be used to describing outputs in"]
    #[doc = " physical space relative to one another, and perform various useful operations"]
    #[doc = " on that state."]
    pub fn wlr_output_layout_create() -> *mut wlr_output_layout;
}
extern "C" {
    pub fn wlr_output_layout_destroy(layout: *mut wlr_output_layout);
}
extern "C" {
    pub fn wlr_output_layout_get(
        layout: *mut wlr_output_layout,
        reference: *mut wlr_output,
    ) -> *mut wlr_output_layout_output;
}
extern "C" {
    pub fn wlr_output_layout_output_at(
        layout: *mut wlr_output_layout,
        lx: f64,
        ly: f64,
    ) -> *mut wlr_output;
}
extern "C" {
    pub fn wlr_output_layout_add(
        layout: *mut wlr_output_layout,
        output: *mut wlr_output,
        lx: ::std::os::raw::c_int,
        ly: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn wlr_output_layout_move(
        layout: *mut wlr_output_layout,
        output: *mut wlr_output,
        lx: ::std::os::raw::c_int,
        ly: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn wlr_output_layout_remove(layout: *mut wlr_output_layout, output: *mut wlr_output);
}
extern "C" {
    #[doc = " Given x and y in layout coordinates, adjusts them to local output"]
    #[doc = " coordinates relative to the given reference output."]
    pub fn wlr_output_layout_output_coords(
        layout: *mut wlr_output_layout,
        reference: *mut wlr_output,
        lx: *mut f64,
        ly: *mut f64,
    );
}
extern "C" {
    pub fn wlr_output_layout_contains_point(
        layout: *mut wlr_output_layout,
        reference: *mut wlr_output,
        lx: ::std::os::raw::c_int,
        ly: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn wlr_output_layout_intersects(
        layout: *mut wlr_output_layout,
        reference: *mut wlr_output,
        target_lbox: *const wlr_box,
    ) -> bool;
}
extern "C" {
    #[doc = " Get the closest point on this layout from the given point from the reference"]
    #[doc = " output. If reference is NULL, gets the closest point from the entire layout."]
    pub fn wlr_output_layout_closest_point(
        layout: *mut wlr_output_layout,
        reference: *mut wlr_output,
        lx: f64,
        ly: f64,
        dest_lx: *mut f64,
        dest_ly: *mut f64,
    );
}
extern "C" {
    #[doc = " Get the box of the layout for the given reference output in layout"]
    #[doc = " coordinates. If `reference` is NULL, the box will be for the extents of the"]
    #[doc = " entire layout."]
    pub fn wlr_output_layout_get_box(
        layout: *mut wlr_output_layout,
        reference: *mut wlr_output,
    ) -> *mut wlr_box;
}
extern "C" {
    #[doc = " Add an auto configured output to the layout. This will place the output in a"]
    #[doc = " sensible location in the layout. The coordinates of the output in the layout"]
    #[doc = " may adjust dynamically when the layout changes. If the output is already in"]
    #[doc = " the layout, it will become auto configured. If the position of the output is"]
    #[doc = " set such as with `wlr_output_layout_move()`, the output will become manually"]
    #[doc = " configured."]
    pub fn wlr_output_layout_add_auto(layout: *mut wlr_output_layout, output: *mut wlr_output);
}
extern "C" {
    #[doc = " Get the output closest to the center of the layout extents."]
    pub fn wlr_output_layout_get_center_output(layout: *mut wlr_output_layout) -> *mut wlr_output;
}
pub mod wlr_direction {
    pub type Type = u32;
    pub const WLR_DIRECTION_UP: Type = 1;
    pub const WLR_DIRECTION_DOWN: Type = 2;
    pub const WLR_DIRECTION_LEFT: Type = 4;
    pub const WLR_DIRECTION_RIGHT: Type = 8;
}
extern "C" {
    #[doc = " Get the closest adjacent output to the reference output from the reference"]
    #[doc = " point in the given direction."]
    pub fn wlr_output_layout_adjacent_output(
        layout: *mut wlr_output_layout,
        direction: wlr_direction::Type,
        reference: *mut wlr_output,
        ref_lx: f64,
        ref_ly: f64,
    ) -> *mut wlr_output;
}
extern "C" {
    pub fn wlr_output_layout_farthest_output(
        layout: *mut wlr_output_layout,
        direction: wlr_direction::Type,
        reference: *mut wlr_output,
        ref_lx: f64,
        ref_ly: f64,
    ) -> *mut wlr_output;
}
#[doc = " wlr_cursor implements the behavior of the \"cursor\", that is, the image on the"]
#[doc = " screen typically moved about with a mouse or so. It provides tracking for"]
#[doc = " this in global coordinates, and integrates with wlr_output,"]
#[doc = " wlr_output_layout, and wlr_input_device. You can use it to abstract multiple"]
#[doc = " input devices over a single cursor, constrain cursor movement to the usable"]
#[doc = " area of a wlr_output_layout and communicate position updates to the hardware"]
#[doc = " cursor, constrain specific input devices to specific outputs or regions of"]
#[doc = " the screen, and so on."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_cursor_state {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_cursor {
    pub state: *mut wlr_cursor_state,
    pub x: f64,
    pub y: f64,
    pub events: wlr_cursor__bindgen_ty_1,
    pub data: *mut ::std::os::raw::c_void,
}
#[doc = " The interpretation of these signals is the responsibility of the"]
#[doc = " compositor, but some helpers are provided for your benefit. If you"]
#[doc = " receive a relative motion event, for example, you may want to call"]
#[doc = " wlr_cursor_move. If you receive an absolute event, call"]
#[doc = " wlr_cursor_warp_absolute. If you pass an input device into these"]
#[doc = " functions, it will apply the region/output constraints associated with"]
#[doc = " that device to the resulting cursor motion. If an output layout is"]
#[doc = " attached, these functions will constrain the resulting cursor motion to"]
#[doc = " within the usable space of the output layout."]
#[doc = ""]
#[doc = " Re-broadcasting these signals to, for example, a wlr_seat, is also your"]
#[doc = " responsibility."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_cursor__bindgen_ty_1 {
    pub motion: wl_signal,
    pub motion_absolute: wl_signal,
    pub button: wl_signal,
    pub axis: wl_signal,
    pub frame: wl_signal,
    pub swipe_begin: wl_signal,
    pub swipe_update: wl_signal,
    pub swipe_end: wl_signal,
    pub pinch_begin: wl_signal,
    pub pinch_update: wl_signal,
    pub pinch_end: wl_signal,
    pub touch_up: wl_signal,
    pub touch_down: wl_signal,
    pub touch_motion: wl_signal,
    pub touch_cancel: wl_signal,
    pub tablet_tool_axis: wl_signal,
    pub tablet_tool_proximity: wl_signal,
    pub tablet_tool_tip: wl_signal,
    pub tablet_tool_button: wl_signal,
}
#[test]
fn bindgen_test_layout_wlr_cursor__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wlr_cursor__bindgen_ty_1>(),
        304usize,
        concat!("Size of: ", stringify!(wlr_cursor__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_cursor__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_cursor__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_cursor__bindgen_ty_1>())).motion as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_cursor__bindgen_ty_1),
            "::",
            stringify!(motion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_cursor__bindgen_ty_1>())).motion_absolute as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_cursor__bindgen_ty_1),
            "::",
            stringify!(motion_absolute)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_cursor__bindgen_ty_1>())).button as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_cursor__bindgen_ty_1),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_cursor__bindgen_ty_1>())).axis as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_cursor__bindgen_ty_1),
            "::",
            stringify!(axis)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_cursor__bindgen_ty_1>())).frame as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_cursor__bindgen_ty_1),
            "::",
            stringify!(frame)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_cursor__bindgen_ty_1>())).swipe_begin as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_cursor__bindgen_ty_1),
            "::",
            stringify!(swipe_begin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_cursor__bindgen_ty_1>())).swipe_update as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_cursor__bindgen_ty_1),
            "::",
            stringify!(swipe_update)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_cursor__bindgen_ty_1>())).swipe_end as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_cursor__bindgen_ty_1),
            "::",
            stringify!(swipe_end)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_cursor__bindgen_ty_1>())).pinch_begin as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_cursor__bindgen_ty_1),
            "::",
            stringify!(pinch_begin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_cursor__bindgen_ty_1>())).pinch_update as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_cursor__bindgen_ty_1),
            "::",
            stringify!(pinch_update)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_cursor__bindgen_ty_1>())).pinch_end as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_cursor__bindgen_ty_1),
            "::",
            stringify!(pinch_end)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_cursor__bindgen_ty_1>())).touch_up as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_cursor__bindgen_ty_1),
            "::",
            stringify!(touch_up)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_cursor__bindgen_ty_1>())).touch_down as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_cursor__bindgen_ty_1),
            "::",
            stringify!(touch_down)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_cursor__bindgen_ty_1>())).touch_motion as *const _ as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_cursor__bindgen_ty_1),
            "::",
            stringify!(touch_motion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_cursor__bindgen_ty_1>())).touch_cancel as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_cursor__bindgen_ty_1),
            "::",
            stringify!(touch_cancel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_cursor__bindgen_ty_1>())).tablet_tool_axis as *const _
                as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_cursor__bindgen_ty_1),
            "::",
            stringify!(tablet_tool_axis)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_cursor__bindgen_ty_1>())).tablet_tool_proximity as *const _
                as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_cursor__bindgen_ty_1),
            "::",
            stringify!(tablet_tool_proximity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_cursor__bindgen_ty_1>())).tablet_tool_tip as *const _
                as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_cursor__bindgen_ty_1),
            "::",
            stringify!(tablet_tool_tip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_cursor__bindgen_ty_1>())).tablet_tool_button as *const _
                as usize
        },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_cursor__bindgen_ty_1),
            "::",
            stringify!(tablet_tool_button)
        )
    );
}
#[test]
fn bindgen_test_layout_wlr_cursor() {
    assert_eq!(
        ::std::mem::size_of::<wlr_cursor>(),
        336usize,
        concat!("Size of: ", stringify!(wlr_cursor))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_cursor>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_cursor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_cursor>())).state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_cursor),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_cursor>())).x as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_cursor),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_cursor>())).y as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_cursor),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_cursor>())).events as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_cursor),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_cursor>())).data as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_cursor),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    pub fn wlr_cursor_create() -> *mut wlr_cursor;
}
extern "C" {
    pub fn wlr_cursor_destroy(cur: *mut wlr_cursor);
}
extern "C" {
    #[doc = " Warp the cursor to the given x and y in layout coordinates. If x and y are"]
    #[doc = " out of the layout boundaries or constraints, no warp will happen."]
    #[doc = ""]
    #[doc = " `dev` may be passed to respect device mapping constraints. If `dev` is NULL,"]
    #[doc = " device mapping constraints will be ignored."]
    #[doc = ""]
    #[doc = " Returns true when the cursor warp was successful."]
    pub fn wlr_cursor_warp(
        cur: *mut wlr_cursor,
        dev: *mut wlr_input_device,
        lx: f64,
        ly: f64,
    ) -> bool;
}
extern "C" {
    #[doc = " Convert absolute 0..1 coordinates to layout coordinates."]
    #[doc = ""]
    #[doc = " `dev` may be passed to respect device mapping constraints. If `dev` is NULL,"]
    #[doc = " device mapping constraints will be ignored."]
    pub fn wlr_cursor_absolute_to_layout_coords(
        cur: *mut wlr_cursor,
        dev: *mut wlr_input_device,
        x: f64,
        y: f64,
        lx: *mut f64,
        ly: *mut f64,
    );
}
extern "C" {
    #[doc = " Warp the cursor to the given x and y coordinates. If the given point is out"]
    #[doc = " of the layout boundaries or constraints, the closest point will be used."]
    #[doc = " If one coordinate is NAN, it will be ignored."]
    #[doc = ""]
    #[doc = " `dev` may be passed to respect device mapping constraints. If `dev` is NULL,"]
    #[doc = " device mapping constraints will be ignored."]
    pub fn wlr_cursor_warp_closest(
        cur: *mut wlr_cursor,
        dev: *mut wlr_input_device,
        x: f64,
        y: f64,
    );
}
extern "C" {
    #[doc = " Warp the cursor to the given x and y in absolute 0..1 coordinates. If the"]
    #[doc = " given point is out of the layout boundaries or constraints, the closest point"]
    #[doc = " will be used. If one coordinate is NAN, it will be ignored."]
    #[doc = ""]
    #[doc = " `dev` may be passed to respect device mapping constraints. If `dev` is NULL,"]
    #[doc = " device mapping constraints will be ignored."]
    pub fn wlr_cursor_warp_absolute(
        cur: *mut wlr_cursor,
        dev: *mut wlr_input_device,
        x: f64,
        y: f64,
    );
}
extern "C" {
    #[doc = " Move the cursor in the direction of the given x and y layout coordinates. If"]
    #[doc = " one coordinate is NAN, it will be ignored."]
    #[doc = ""]
    #[doc = " `dev` may be passed to respect device mapping constraints. If `dev` is NULL,"]
    #[doc = " device mapping constraints will be ignored."]
    pub fn wlr_cursor_move(
        cur: *mut wlr_cursor,
        dev: *mut wlr_input_device,
        delta_x: f64,
        delta_y: f64,
    );
}
extern "C" {
    #[doc = " Set the cursor image. stride is given in bytes. If pixels is NULL, hides the"]
    #[doc = " cursor."]
    #[doc = ""]
    #[doc = " If scale isn't zero, the image is only set on outputs having the provided"]
    #[doc = " scale."]
    pub fn wlr_cursor_set_image(
        cur: *mut wlr_cursor,
        pixels: *const u8,
        stride: i32,
        width: u32,
        height: u32,
        hotspot_x: i32,
        hotspot_y: i32,
        scale: f32,
    );
}
extern "C" {
    #[doc = " Set the cursor surface. The surface can be committed to update the cursor"]
    #[doc = " image. The surface position is subtracted from the hotspot. A NULL surface"]
    #[doc = " commit hides the cursor."]
    pub fn wlr_cursor_set_surface(
        cur: *mut wlr_cursor,
        surface: *mut wlr_surface,
        hotspot_x: i32,
        hotspot_y: i32,
    );
}
extern "C" {
    #[doc = " Attaches this input device to this cursor. The input device must be one of:"]
    #[doc = ""]
    #[doc = " - WLR_INPUT_DEVICE_POINTER"]
    #[doc = " - WLR_INPUT_DEVICE_TOUCH"]
    #[doc = " - WLR_INPUT_DEVICE_TABLET_TOOL"]
    pub fn wlr_cursor_attach_input_device(cur: *mut wlr_cursor, dev: *mut wlr_input_device);
}
extern "C" {
    pub fn wlr_cursor_detach_input_device(cur: *mut wlr_cursor, dev: *mut wlr_input_device);
}
extern "C" {
    #[doc = " Uses the given layout to establish the boundaries and movement semantics of"]
    #[doc = " this cursor. Cursors without an output layout allow infinite movement in any"]
    #[doc = " direction and do not support absolute input events."]
    pub fn wlr_cursor_attach_output_layout(cur: *mut wlr_cursor, l: *mut wlr_output_layout);
}
extern "C" {
    #[doc = " Attaches this cursor to the given output, which must be among the outputs in"]
    #[doc = " the current output_layout for this cursor. This call is invalid for a cursor"]
    #[doc = " without an associated output layout."]
    pub fn wlr_cursor_map_to_output(cur: *mut wlr_cursor, output: *mut wlr_output);
}
extern "C" {
    #[doc = " Maps all input from a specific input device to a given output. The input"]
    #[doc = " device must be attached to this cursor and the output must be among the"]
    #[doc = " outputs in the attached output layout."]
    pub fn wlr_cursor_map_input_to_output(
        cur: *mut wlr_cursor,
        dev: *mut wlr_input_device,
        output: *mut wlr_output,
    );
}
extern "C" {
    #[doc = " Maps this cursor to an arbitrary region on the associated wlr_output_layout."]
    pub fn wlr_cursor_map_to_region(cur: *mut wlr_cursor, box_: *mut wlr_box);
}
extern "C" {
    #[doc = " Maps inputs from this input device to an arbitrary region on the associated"]
    #[doc = " wlr_output_layout."]
    pub fn wlr_cursor_map_input_to_region(
        cur: *mut wlr_cursor,
        dev: *mut wlr_input_device,
        box_: *mut wlr_box,
    );
}
pub mod wlr_surface_state_field {
    pub type Type = u32;
    pub const WLR_SURFACE_STATE_BUFFER: Type = 1;
    pub const WLR_SURFACE_STATE_SURFACE_DAMAGE: Type = 2;
    pub const WLR_SURFACE_STATE_BUFFER_DAMAGE: Type = 4;
    pub const WLR_SURFACE_STATE_OPAQUE_REGION: Type = 8;
    pub const WLR_SURFACE_STATE_INPUT_REGION: Type = 16;
    pub const WLR_SURFACE_STATE_TRANSFORM: Type = 32;
    pub const WLR_SURFACE_STATE_SCALE: Type = 64;
    pub const WLR_SURFACE_STATE_FRAME_CALLBACK_LIST: Type = 128;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_surface_state {
    pub committed: u32,
    pub buffer_resource: *mut wl_resource,
    pub dx: i32,
    pub dy: i32,
    pub surface_damage: pixman_region32_t,
    pub buffer_damage: pixman_region32_t,
    pub opaque: pixman_region32_t,
    pub input: pixman_region32_t,
    pub transform: wl_output_transform::Type,
    pub scale: i32,
    pub frame_callback_list: wl_list,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    pub buffer_width: ::std::os::raw::c_int,
    pub buffer_height: ::std::os::raw::c_int,
    pub buffer_destroy: wl_listener,
}
#[test]
fn bindgen_test_layout_wlr_surface_state() {
    assert_eq!(
        ::std::mem::size_of::<wlr_surface_state>(),
        184usize,
        concat!("Size of: ", stringify!(wlr_surface_state))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_surface_state>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_surface_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_surface_state>())).committed as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_surface_state),
            "::",
            stringify!(committed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_surface_state>())).buffer_resource as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_surface_state),
            "::",
            stringify!(buffer_resource)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_surface_state>())).dx as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_surface_state),
            "::",
            stringify!(dx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_surface_state>())).dy as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_surface_state),
            "::",
            stringify!(dy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_surface_state>())).surface_damage as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_surface_state),
            "::",
            stringify!(surface_damage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_surface_state>())).buffer_damage as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_surface_state),
            "::",
            stringify!(buffer_damage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_surface_state>())).opaque as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_surface_state),
            "::",
            stringify!(opaque)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_surface_state>())).input as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_surface_state),
            "::",
            stringify!(input)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_surface_state>())).transform as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_surface_state),
            "::",
            stringify!(transform)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_surface_state>())).scale as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_surface_state),
            "::",
            stringify!(scale)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_surface_state>())).frame_callback_list as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_surface_state),
            "::",
            stringify!(frame_callback_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_surface_state>())).width as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_surface_state),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_surface_state>())).height as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_surface_state),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_surface_state>())).buffer_width as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_surface_state),
            "::",
            stringify!(buffer_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_surface_state>())).buffer_height as *const _ as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_surface_state),
            "::",
            stringify!(buffer_height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_surface_state>())).buffer_destroy as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_surface_state),
            "::",
            stringify!(buffer_destroy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_surface_role {
    pub name: *const ::std::os::raw::c_char,
    pub commit: ::std::option::Option<unsafe extern "C" fn(surface: *mut wlr_surface)>,
    pub precommit: ::std::option::Option<unsafe extern "C" fn(surface: *mut wlr_surface)>,
}
#[test]
fn bindgen_test_layout_wlr_surface_role() {
    assert_eq!(
        ::std::mem::size_of::<wlr_surface_role>(),
        24usize,
        concat!("Size of: ", stringify!(wlr_surface_role))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_surface_role>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_surface_role))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_surface_role>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_surface_role),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_surface_role>())).commit as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_surface_role),
            "::",
            stringify!(commit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_surface_role>())).precommit as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_surface_role),
            "::",
            stringify!(precommit)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_surface {
    pub resource: *mut wl_resource,
    pub renderer: *mut wlr_renderer,
    #[doc = " The surface's buffer, if any. A surface has an attached buffer when it"]
    #[doc = " commits with a non-null buffer in its pending state. A surface will not"]
    #[doc = " have a buffer if it has never committed one, has committed a null buffer,"]
    #[doc = " or something went wrong with uploading the buffer."]
    pub buffer: *mut wlr_buffer,
    #[doc = " The buffer position, in surface-local units."]
    pub sx: ::std::os::raw::c_int,
    #[doc = " The buffer position, in surface-local units."]
    pub sy: ::std::os::raw::c_int,
    #[doc = " The last commit's buffer damage, in buffer-local coordinates. This"]
    #[doc = " contains both the damage accumulated by the client via"]
    #[doc = " `wlr_surface_state.surface_damage` and `wlr_surface_state.buffer_damage`."]
    #[doc = " If the buffer has been resized, the whole buffer is damaged."]
    #[doc = ""]
    #[doc = " This region needs to be scaled and transformed into output coordinates,"]
    #[doc = " just like the buffer's texture. In addition, if the buffer has shrunk the"]
    #[doc = " old size needs to be damaged and if the buffer has moved the old and new"]
    #[doc = " positions need to be damaged."]
    pub buffer_damage: pixman_region32_t,
    #[doc = " The current opaque region, in surface-local coordinates. It is clipped to"]
    #[doc = " the surface bounds. If the surface's buffer is using a fully opaque"]
    #[doc = " format, this is set to the whole surface."]
    pub opaque_region: pixman_region32_t,
    #[doc = " The current input region, in surface-local coordinates. It is clipped to"]
    #[doc = " the surface bounds."]
    pub input_region: pixman_region32_t,
    #[doc = " `current` contains the current, committed surface state. `pending`"]
    #[doc = " accumulates state changes from the client between commits and shouldn't"]
    #[doc = " be accessed by the compositor directly. `previous` contains the state of"]
    #[doc = " the previous commit."]
    pub current: wlr_surface_state,
    #[doc = " `current` contains the current, committed surface state. `pending`"]
    #[doc = " accumulates state changes from the client between commits and shouldn't"]
    #[doc = " be accessed by the compositor directly. `previous` contains the state of"]
    #[doc = " the previous commit."]
    pub pending: wlr_surface_state,
    #[doc = " `current` contains the current, committed surface state. `pending`"]
    #[doc = " accumulates state changes from the client between commits and shouldn't"]
    #[doc = " be accessed by the compositor directly. `previous` contains the state of"]
    #[doc = " the previous commit."]
    pub previous: wlr_surface_state,
    pub role: *const wlr_surface_role,
    pub role_data: *mut ::std::os::raw::c_void,
    pub events: wlr_surface__bindgen_ty_1,
    pub subsurfaces: wl_list,
    pub subsurface_pending_list: wl_list,
    pub renderer_destroy: wl_listener,
    pub data: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_surface__bindgen_ty_1 {
    pub commit: wl_signal,
    pub new_subsurface: wl_signal,
    pub destroy: wl_signal,
}
#[test]
fn bindgen_test_layout_wlr_surface__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wlr_surface__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(wlr_surface__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_surface__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_surface__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_surface__bindgen_ty_1>())).commit as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_surface__bindgen_ty_1),
            "::",
            stringify!(commit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_surface__bindgen_ty_1>())).new_subsurface as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_surface__bindgen_ty_1),
            "::",
            stringify!(new_subsurface)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_surface__bindgen_ty_1>())).destroy as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_surface__bindgen_ty_1),
            "::",
            stringify!(destroy)
        )
    );
}
#[test]
fn bindgen_test_layout_wlr_surface() {
    assert_eq!(
        ::std::mem::size_of::<wlr_surface>(),
        784usize,
        concat!("Size of: ", stringify!(wlr_surface))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_surface>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_surface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_surface>())).resource as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_surface),
            "::",
            stringify!(resource)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_surface>())).renderer as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_surface),
            "::",
            stringify!(renderer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_surface>())).buffer as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_surface),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_surface>())).sx as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_surface),
            "::",
            stringify!(sx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_surface>())).sy as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_surface),
            "::",
            stringify!(sy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_surface>())).buffer_damage as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_surface),
            "::",
            stringify!(buffer_damage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_surface>())).opaque_region as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_surface),
            "::",
            stringify!(opaque_region)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_surface>())).input_region as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_surface),
            "::",
            stringify!(input_region)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_surface>())).current as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_surface),
            "::",
            stringify!(current)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_surface>())).pending as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_surface),
            "::",
            stringify!(pending)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_surface>())).previous as *const _ as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_surface),
            "::",
            stringify!(previous)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_surface>())).role as *const _ as usize },
        656usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_surface),
            "::",
            stringify!(role)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_surface>())).role_data as *const _ as usize },
        664usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_surface),
            "::",
            stringify!(role_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_surface>())).events as *const _ as usize },
        672usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_surface),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_surface>())).subsurfaces as *const _ as usize },
        720usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_surface),
            "::",
            stringify!(subsurfaces)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_surface>())).subsurface_pending_list as *const _ as usize
        },
        736usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_surface),
            "::",
            stringify!(subsurface_pending_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_surface>())).renderer_destroy as *const _ as usize },
        752usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_surface),
            "::",
            stringify!(renderer_destroy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_surface>())).data as *const _ as usize },
        776usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_surface),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_subsurface_state {
    pub x: i32,
    pub y: i32,
}
#[test]
fn bindgen_test_layout_wlr_subsurface_state() {
    assert_eq!(
        ::std::mem::size_of::<wlr_subsurface_state>(),
        8usize,
        concat!("Size of: ", stringify!(wlr_subsurface_state))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_subsurface_state>(),
        4usize,
        concat!("Alignment of ", stringify!(wlr_subsurface_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_subsurface_state>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_subsurface_state),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_subsurface_state>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_subsurface_state),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_subsurface {
    pub resource: *mut wl_resource,
    pub surface: *mut wlr_surface,
    pub parent: *mut wlr_surface,
    pub current: wlr_subsurface_state,
    pub pending: wlr_subsurface_state,
    pub cached: wlr_surface_state,
    pub has_cache: bool,
    pub synchronized: bool,
    pub reordered: bool,
    pub mapped: bool,
    pub parent_link: wl_list,
    pub parent_pending_link: wl_list,
    pub surface_destroy: wl_listener,
    pub parent_destroy: wl_listener,
    pub events: wlr_subsurface__bindgen_ty_1,
    pub data: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_subsurface__bindgen_ty_1 {
    pub destroy: wl_signal,
    pub map: wl_signal,
    pub unmap: wl_signal,
}
#[test]
fn bindgen_test_layout_wlr_subsurface__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wlr_subsurface__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(wlr_subsurface__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_subsurface__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_subsurface__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_subsurface__bindgen_ty_1>())).destroy as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_subsurface__bindgen_ty_1),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_subsurface__bindgen_ty_1>())).map as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_subsurface__bindgen_ty_1),
            "::",
            stringify!(map)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_subsurface__bindgen_ty_1>())).unmap as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_subsurface__bindgen_ty_1),
            "::",
            stringify!(unmap)
        )
    );
}
#[test]
fn bindgen_test_layout_wlr_subsurface() {
    assert_eq!(
        ::std::mem::size_of::<wlr_subsurface>(),
        368usize,
        concat!("Size of: ", stringify!(wlr_subsurface))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_subsurface>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_subsurface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_subsurface>())).resource as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_subsurface),
            "::",
            stringify!(resource)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_subsurface>())).surface as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_subsurface),
            "::",
            stringify!(surface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_subsurface>())).parent as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_subsurface),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_subsurface>())).current as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_subsurface),
            "::",
            stringify!(current)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_subsurface>())).pending as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_subsurface),
            "::",
            stringify!(pending)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_subsurface>())).cached as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_subsurface),
            "::",
            stringify!(cached)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_subsurface>())).has_cache as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_subsurface),
            "::",
            stringify!(has_cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_subsurface>())).synchronized as *const _ as usize },
        225usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_subsurface),
            "::",
            stringify!(synchronized)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_subsurface>())).reordered as *const _ as usize },
        226usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_subsurface),
            "::",
            stringify!(reordered)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_subsurface>())).mapped as *const _ as usize },
        227usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_subsurface),
            "::",
            stringify!(mapped)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_subsurface>())).parent_link as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_subsurface),
            "::",
            stringify!(parent_link)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_subsurface>())).parent_pending_link as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_subsurface),
            "::",
            stringify!(parent_pending_link)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_subsurface>())).surface_destroy as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_subsurface),
            "::",
            stringify!(surface_destroy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_subsurface>())).parent_destroy as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_subsurface),
            "::",
            stringify!(parent_destroy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_subsurface>())).events as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_subsurface),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_subsurface>())).data as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_subsurface),
            "::",
            stringify!(data)
        )
    );
}
pub type wlr_surface_iterator_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        surface: *mut wlr_surface,
        sx: ::std::os::raw::c_int,
        sy: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " Create a new surface resource with the provided new ID. If `resource_list`"]
    #[doc = " is non-NULL, adds the surface's resource to the list."]
    pub fn wlr_surface_create(
        client: *mut wl_client,
        version: u32,
        id: u32,
        renderer: *mut wlr_renderer,
        resource_list: *mut wl_list,
    ) -> *mut wlr_surface;
}
extern "C" {
    #[doc = " Set the lifetime role for this surface. Returns 0 on success or -1 if the"]
    #[doc = " role cannot be set."]
    pub fn wlr_surface_set_role(
        surface: *mut wlr_surface,
        role: *const wlr_surface_role,
        role_data: *mut ::std::os::raw::c_void,
        error_resource: *mut wl_resource,
        error_code: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Whether or not this surface currently has an attached buffer. A surface has"]
    #[doc = " an attached buffer when it commits with a non-null buffer in its pending"]
    #[doc = " state. A surface will not have a buffer if it has never committed one, has"]
    #[doc = " committed a null buffer, or something went wrong with uploading the buffer."]
    pub fn wlr_surface_has_buffer(surface: *mut wlr_surface) -> bool;
}
extern "C" {
    #[doc = " Get the texture of the buffer currently attached to this surface. Returns"]
    #[doc = " NULL if no buffer is currently attached or if something went wrong with"]
    #[doc = " uploading the buffer."]
    pub fn wlr_surface_get_texture(surface: *mut wlr_surface) -> *mut wlr_texture;
}
extern "C" {
    #[doc = " Create a new subsurface resource with the provided new ID. If `resource_list`"]
    #[doc = " is non-NULL, adds the subsurface's resource to the list."]
    pub fn wlr_subsurface_create(
        surface: *mut wlr_surface,
        parent: *mut wlr_surface,
        version: u32,
        id: u32,
        resource_list: *mut wl_list,
    ) -> *mut wlr_subsurface;
}
extern "C" {
    #[doc = " Get the root of the subsurface tree for this surface."]
    pub fn wlr_surface_get_root_surface(surface: *mut wlr_surface) -> *mut wlr_surface;
}
extern "C" {
    #[doc = " Check if the surface accepts input events at the given surface-local"]
    #[doc = " coordinates. Does not check the surface's subsurfaces."]
    pub fn wlr_surface_point_accepts_input(surface: *mut wlr_surface, sx: f64, sy: f64) -> bool;
}
extern "C" {
    #[doc = " Find a surface in this surface's tree that accepts input events at the given"]
    #[doc = " surface-local coordinates. Returns the surface and coordinates in the leaf"]
    #[doc = " surface coordinate system or NULL if no surface is found at that location."]
    pub fn wlr_surface_surface_at(
        surface: *mut wlr_surface,
        sx: f64,
        sy: f64,
        sub_x: *mut f64,
        sub_y: *mut f64,
    ) -> *mut wlr_surface;
}
extern "C" {
    pub fn wlr_surface_send_enter(surface: *mut wlr_surface, output: *mut wlr_output);
}
extern "C" {
    pub fn wlr_surface_send_leave(surface: *mut wlr_surface, output: *mut wlr_output);
}
extern "C" {
    pub fn wlr_surface_send_frame_done(surface: *mut wlr_surface, when: *const timespec);
}
extern "C" {
    #[doc = " Get the bounding box that contains the surface and all subsurfaces in"]
    #[doc = " surface coordinates."]
    #[doc = " X and y may be negative, if there are subsurfaces with negative position."]
    pub fn wlr_surface_get_extends(surface: *mut wlr_surface, box_: *mut wlr_box);
}
extern "C" {
    pub fn wlr_surface_from_resource(resource: *mut wl_resource) -> *mut wlr_surface;
}
extern "C" {
    #[doc = " Call `iterator` on each surface in the surface tree, with the surface's"]
    #[doc = " position relative to the root surface. The function is called from root to"]
    #[doc = " leaves (in rendering order)."]
    pub fn wlr_surface_for_each_surface(
        surface: *mut wlr_surface,
        iterator: wlr_surface_iterator_func_t,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Get the effective damage to the surface in terms of surface local"]
    #[doc = " coordinates. This includes damage induced by resizing and moving the"]
    #[doc = " surface. The damage is not expected to be bounded by the surface itself."]
    pub fn wlr_surface_get_effective_damage(
        surface: *mut wlr_surface,
        damage: *mut pixman_region32_t,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_serial_range {
    pub min_incl: u32,
    pub max_incl: u32,
}
#[test]
fn bindgen_test_layout_wlr_serial_range() {
    assert_eq!(
        ::std::mem::size_of::<wlr_serial_range>(),
        8usize,
        concat!("Size of: ", stringify!(wlr_serial_range))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_serial_range>(),
        4usize,
        concat!("Alignment of ", stringify!(wlr_serial_range))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_serial_range>())).min_incl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_serial_range),
            "::",
            stringify!(min_incl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_serial_range>())).max_incl as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_serial_range),
            "::",
            stringify!(max_incl)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wlr_serial_ringset {
    pub data: [wlr_serial_range; 128usize],
    pub end: ::std::os::raw::c_int,
    pub count: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_wlr_serial_ringset() {
    assert_eq!(
        ::std::mem::size_of::<wlr_serial_ringset>(),
        1032usize,
        concat!("Size of: ", stringify!(wlr_serial_ringset))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_serial_ringset>(),
        4usize,
        concat!("Alignment of ", stringify!(wlr_serial_ringset))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_serial_ringset>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_serial_ringset),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_serial_ringset>())).end as *const _ as usize },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_serial_ringset),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_serial_ringset>())).count as *const _ as usize },
        1028usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_serial_ringset),
            "::",
            stringify!(count)
        )
    );
}
#[doc = " Contains state for a single client's bound wl_seat resource and can be used"]
#[doc = " to issue input events to that client. The lifetime of these objects is"]
#[doc = " managed by wlr_seat; some may be NULL."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wlr_seat_client {
    pub client: *mut wl_client,
    pub seat: *mut wlr_seat,
    pub link: wl_list,
    pub resources: wl_list,
    pub pointers: wl_list,
    pub keyboards: wl_list,
    pub touches: wl_list,
    pub data_devices: wl_list,
    pub events: wlr_seat_client__bindgen_ty_1,
    pub serials: wlr_serial_ringset,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_seat_client__bindgen_ty_1 {
    pub destroy: wl_signal,
}
#[test]
fn bindgen_test_layout_wlr_seat_client__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wlr_seat_client__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(wlr_seat_client__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_seat_client__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_seat_client__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_seat_client__bindgen_ty_1>())).destroy as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_client__bindgen_ty_1),
            "::",
            stringify!(destroy)
        )
    );
}
#[test]
fn bindgen_test_layout_wlr_seat_client() {
    assert_eq!(
        ::std::mem::size_of::<wlr_seat_client>(),
        1160usize,
        concat!("Size of: ", stringify!(wlr_seat_client))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_seat_client>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_seat_client))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_seat_client>())).client as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_client),
            "::",
            stringify!(client)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_seat_client>())).seat as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_client),
            "::",
            stringify!(seat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_seat_client>())).link as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_client),
            "::",
            stringify!(link)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_seat_client>())).resources as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_client),
            "::",
            stringify!(resources)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_seat_client>())).pointers as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_client),
            "::",
            stringify!(pointers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_seat_client>())).keyboards as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_client),
            "::",
            stringify!(keyboards)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_seat_client>())).touches as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_client),
            "::",
            stringify!(touches)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_seat_client>())).data_devices as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_client),
            "::",
            stringify!(data_devices)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_seat_client>())).events as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_client),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_seat_client>())).serials as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_client),
            "::",
            stringify!(serials)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_touch_point {
    pub touch_id: i32,
    pub surface: *mut wlr_surface,
    pub client: *mut wlr_seat_client,
    pub focus_surface: *mut wlr_surface,
    pub focus_client: *mut wlr_seat_client,
    pub sx: f64,
    pub sy: f64,
    pub surface_destroy: wl_listener,
    pub focus_surface_destroy: wl_listener,
    pub events: wlr_touch_point__bindgen_ty_1,
    pub link: wl_list,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_touch_point__bindgen_ty_1 {
    pub destroy: wl_signal,
}
#[test]
fn bindgen_test_layout_wlr_touch_point__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wlr_touch_point__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(wlr_touch_point__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_touch_point__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_touch_point__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_touch_point__bindgen_ty_1>())).destroy as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_touch_point__bindgen_ty_1),
            "::",
            stringify!(destroy)
        )
    );
}
#[test]
fn bindgen_test_layout_wlr_touch_point() {
    assert_eq!(
        ::std::mem::size_of::<wlr_touch_point>(),
        136usize,
        concat!("Size of: ", stringify!(wlr_touch_point))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_touch_point>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_touch_point))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_touch_point>())).touch_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_touch_point),
            "::",
            stringify!(touch_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_touch_point>())).surface as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_touch_point),
            "::",
            stringify!(surface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_touch_point>())).client as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_touch_point),
            "::",
            stringify!(client)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_touch_point>())).focus_surface as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_touch_point),
            "::",
            stringify!(focus_surface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_touch_point>())).focus_client as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_touch_point),
            "::",
            stringify!(focus_client)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_touch_point>())).sx as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_touch_point),
            "::",
            stringify!(sx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_touch_point>())).sy as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_touch_point),
            "::",
            stringify!(sy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_touch_point>())).surface_destroy as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_touch_point),
            "::",
            stringify!(surface_destroy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_touch_point>())).focus_surface_destroy as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_touch_point),
            "::",
            stringify!(focus_surface_destroy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_touch_point>())).events as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_touch_point),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_touch_point>())).link as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_touch_point),
            "::",
            stringify!(link)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_pointer_grab_interface {
    pub enter: ::std::option::Option<
        unsafe extern "C" fn(
            grab: *mut wlr_seat_pointer_grab,
            surface: *mut wlr_surface,
            sx: f64,
            sy: f64,
        ),
    >,
    pub motion: ::std::option::Option<
        unsafe extern "C" fn(grab: *mut wlr_seat_pointer_grab, time_msec: u32, sx: f64, sy: f64),
    >,
    pub button: ::std::option::Option<
        unsafe extern "C" fn(
            grab: *mut wlr_seat_pointer_grab,
            time_msec: u32,
            button: u32,
            state: wlr_button_state::Type,
        ) -> u32,
    >,
    pub axis: ::std::option::Option<
        unsafe extern "C" fn(
            grab: *mut wlr_seat_pointer_grab,
            time_msec: u32,
            orientation: wlr_axis_orientation::Type,
            value: f64,
            value_discrete: i32,
            source: wlr_axis_source::Type,
        ),
    >,
    pub frame: ::std::option::Option<unsafe extern "C" fn(grab: *mut wlr_seat_pointer_grab)>,
    pub cancel: ::std::option::Option<unsafe extern "C" fn(grab: *mut wlr_seat_pointer_grab)>,
}
#[test]
fn bindgen_test_layout_wlr_pointer_grab_interface() {
    assert_eq!(
        ::std::mem::size_of::<wlr_pointer_grab_interface>(),
        48usize,
        concat!("Size of: ", stringify!(wlr_pointer_grab_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_pointer_grab_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_pointer_grab_interface))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_pointer_grab_interface>())).enter as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_pointer_grab_interface),
            "::",
            stringify!(enter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_pointer_grab_interface>())).motion as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_pointer_grab_interface),
            "::",
            stringify!(motion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_pointer_grab_interface>())).button as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_pointer_grab_interface),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_pointer_grab_interface>())).axis as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_pointer_grab_interface),
            "::",
            stringify!(axis)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_pointer_grab_interface>())).frame as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_pointer_grab_interface),
            "::",
            stringify!(frame)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_pointer_grab_interface>())).cancel as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_pointer_grab_interface),
            "::",
            stringify!(cancel)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_keyboard_grab_interface {
    pub enter: ::std::option::Option<
        unsafe extern "C" fn(
            grab: *mut wlr_seat_keyboard_grab,
            surface: *mut wlr_surface,
            keycodes: *mut u32,
            num_keycodes: usize,
            modifiers: *mut wlr_keyboard_modifiers,
        ),
    >,
    pub key: ::std::option::Option<
        unsafe extern "C" fn(
            grab: *mut wlr_seat_keyboard_grab,
            time_msec: u32,
            key: u32,
            state: u32,
        ),
    >,
    pub modifiers: ::std::option::Option<
        unsafe extern "C" fn(
            grab: *mut wlr_seat_keyboard_grab,
            modifiers: *mut wlr_keyboard_modifiers,
        ),
    >,
    pub cancel: ::std::option::Option<unsafe extern "C" fn(grab: *mut wlr_seat_keyboard_grab)>,
}
#[test]
fn bindgen_test_layout_wlr_keyboard_grab_interface() {
    assert_eq!(
        ::std::mem::size_of::<wlr_keyboard_grab_interface>(),
        32usize,
        concat!("Size of: ", stringify!(wlr_keyboard_grab_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_keyboard_grab_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_keyboard_grab_interface))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_keyboard_grab_interface>())).enter as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_keyboard_grab_interface),
            "::",
            stringify!(enter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_keyboard_grab_interface>())).key as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_keyboard_grab_interface),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_keyboard_grab_interface>())).modifiers as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_keyboard_grab_interface),
            "::",
            stringify!(modifiers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_keyboard_grab_interface>())).cancel as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_keyboard_grab_interface),
            "::",
            stringify!(cancel)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_touch_grab_interface {
    pub down: ::std::option::Option<
        unsafe extern "C" fn(
            grab: *mut wlr_seat_touch_grab,
            time_msec: u32,
            point: *mut wlr_touch_point,
        ) -> u32,
    >,
    pub up: ::std::option::Option<
        unsafe extern "C" fn(
            grab: *mut wlr_seat_touch_grab,
            time_msec: u32,
            point: *mut wlr_touch_point,
        ),
    >,
    pub motion: ::std::option::Option<
        unsafe extern "C" fn(
            grab: *mut wlr_seat_touch_grab,
            time_msec: u32,
            point: *mut wlr_touch_point,
        ),
    >,
    pub enter: ::std::option::Option<
        unsafe extern "C" fn(
            grab: *mut wlr_seat_touch_grab,
            time_msec: u32,
            point: *mut wlr_touch_point,
        ),
    >,
    pub cancel: ::std::option::Option<unsafe extern "C" fn(grab: *mut wlr_seat_touch_grab)>,
}
#[test]
fn bindgen_test_layout_wlr_touch_grab_interface() {
    assert_eq!(
        ::std::mem::size_of::<wlr_touch_grab_interface>(),
        40usize,
        concat!("Size of: ", stringify!(wlr_touch_grab_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_touch_grab_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_touch_grab_interface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_touch_grab_interface>())).down as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_touch_grab_interface),
            "::",
            stringify!(down)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_touch_grab_interface>())).up as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_touch_grab_interface),
            "::",
            stringify!(up)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_touch_grab_interface>())).motion as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_touch_grab_interface),
            "::",
            stringify!(motion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_touch_grab_interface>())).enter as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_touch_grab_interface),
            "::",
            stringify!(enter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_touch_grab_interface>())).cancel as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_touch_grab_interface),
            "::",
            stringify!(cancel)
        )
    );
}
#[doc = " Passed to `wlr_seat_touch_start_grab()` to start a grab of the touch device."]
#[doc = " The grabber is responsible for handling touch events for the seat."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_seat_touch_grab {
    pub interface: *const wlr_touch_grab_interface,
    pub seat: *mut wlr_seat,
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_wlr_seat_touch_grab() {
    assert_eq!(
        ::std::mem::size_of::<wlr_seat_touch_grab>(),
        24usize,
        concat!("Size of: ", stringify!(wlr_seat_touch_grab))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_seat_touch_grab>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_seat_touch_grab))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_seat_touch_grab>())).interface as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_touch_grab),
            "::",
            stringify!(interface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_seat_touch_grab>())).seat as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_touch_grab),
            "::",
            stringify!(seat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_seat_touch_grab>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_touch_grab),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " Passed to `wlr_seat_keyboard_start_grab()` to start a grab of the keyboard."]
#[doc = " The grabber is responsible for handling keyboard events for the seat."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_seat_keyboard_grab {
    pub interface: *const wlr_keyboard_grab_interface,
    pub seat: *mut wlr_seat,
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_wlr_seat_keyboard_grab() {
    assert_eq!(
        ::std::mem::size_of::<wlr_seat_keyboard_grab>(),
        24usize,
        concat!("Size of: ", stringify!(wlr_seat_keyboard_grab))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_seat_keyboard_grab>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_seat_keyboard_grab))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_seat_keyboard_grab>())).interface as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_keyboard_grab),
            "::",
            stringify!(interface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_seat_keyboard_grab>())).seat as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_keyboard_grab),
            "::",
            stringify!(seat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_seat_keyboard_grab>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_keyboard_grab),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " Passed to `wlr_seat_pointer_start_grab()` to start a grab of the pointer. The"]
#[doc = " grabber is responsible for handling pointer events for the seat."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_seat_pointer_grab {
    pub interface: *const wlr_pointer_grab_interface,
    pub seat: *mut wlr_seat,
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_wlr_seat_pointer_grab() {
    assert_eq!(
        ::std::mem::size_of::<wlr_seat_pointer_grab>(),
        24usize,
        concat!("Size of: ", stringify!(wlr_seat_pointer_grab))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_seat_pointer_grab>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_seat_pointer_grab))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_seat_pointer_grab>())).interface as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_pointer_grab),
            "::",
            stringify!(interface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_seat_pointer_grab>())).seat as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_pointer_grab),
            "::",
            stringify!(seat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_seat_pointer_grab>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_pointer_grab),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_seat_pointer_state {
    pub seat: *mut wlr_seat,
    pub focused_client: *mut wlr_seat_client,
    pub focused_surface: *mut wlr_surface,
    pub sx: f64,
    pub sy: f64,
    pub grab: *mut wlr_seat_pointer_grab,
    pub default_grab: *mut wlr_seat_pointer_grab,
    pub buttons: [u32; 16usize],
    pub button_count: usize,
    pub grab_button: u32,
    pub grab_serial: u32,
    pub grab_time: u32,
    pub surface_destroy: wl_listener,
    pub events: wlr_seat_pointer_state__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_seat_pointer_state__bindgen_ty_1 {
    pub focus_change: wl_signal,
}
#[test]
fn bindgen_test_layout_wlr_seat_pointer_state__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wlr_seat_pointer_state__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(wlr_seat_pointer_state__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_seat_pointer_state__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(wlr_seat_pointer_state__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_seat_pointer_state__bindgen_ty_1>())).focus_change
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_pointer_state__bindgen_ty_1),
            "::",
            stringify!(focus_change)
        )
    );
}
#[test]
fn bindgen_test_layout_wlr_seat_pointer_state() {
    assert_eq!(
        ::std::mem::size_of::<wlr_seat_pointer_state>(),
        184usize,
        concat!("Size of: ", stringify!(wlr_seat_pointer_state))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_seat_pointer_state>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_seat_pointer_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_seat_pointer_state>())).seat as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_pointer_state),
            "::",
            stringify!(seat)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_seat_pointer_state>())).focused_client as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_pointer_state),
            "::",
            stringify!(focused_client)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_seat_pointer_state>())).focused_surface as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_pointer_state),
            "::",
            stringify!(focused_surface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_seat_pointer_state>())).sx as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_pointer_state),
            "::",
            stringify!(sx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_seat_pointer_state>())).sy as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_pointer_state),
            "::",
            stringify!(sy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_seat_pointer_state>())).grab as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_pointer_state),
            "::",
            stringify!(grab)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_seat_pointer_state>())).default_grab as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_pointer_state),
            "::",
            stringify!(default_grab)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_seat_pointer_state>())).buttons as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_pointer_state),
            "::",
            stringify!(buttons)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_seat_pointer_state>())).button_count as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_pointer_state),
            "::",
            stringify!(button_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_seat_pointer_state>())).grab_button as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_pointer_state),
            "::",
            stringify!(grab_button)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_seat_pointer_state>())).grab_serial as *const _ as usize
        },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_pointer_state),
            "::",
            stringify!(grab_serial)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_seat_pointer_state>())).grab_time as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_pointer_state),
            "::",
            stringify!(grab_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_seat_pointer_state>())).surface_destroy as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_pointer_state),
            "::",
            stringify!(surface_destroy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_seat_pointer_state>())).events as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_pointer_state),
            "::",
            stringify!(events)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_seat_keyboard_state {
    pub seat: *mut wlr_seat,
    pub keyboard: *mut wlr_keyboard,
    pub focused_client: *mut wlr_seat_client,
    pub focused_surface: *mut wlr_surface,
    pub keyboard_destroy: wl_listener,
    pub keyboard_keymap: wl_listener,
    pub keyboard_repeat_info: wl_listener,
    pub surface_destroy: wl_listener,
    pub grab: *mut wlr_seat_keyboard_grab,
    pub default_grab: *mut wlr_seat_keyboard_grab,
    pub events: wlr_seat_keyboard_state__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_seat_keyboard_state__bindgen_ty_1 {
    pub focus_change: wl_signal,
}
#[test]
fn bindgen_test_layout_wlr_seat_keyboard_state__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wlr_seat_keyboard_state__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(wlr_seat_keyboard_state__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_seat_keyboard_state__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(wlr_seat_keyboard_state__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_seat_keyboard_state__bindgen_ty_1>())).focus_change
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_keyboard_state__bindgen_ty_1),
            "::",
            stringify!(focus_change)
        )
    );
}
#[test]
fn bindgen_test_layout_wlr_seat_keyboard_state() {
    assert_eq!(
        ::std::mem::size_of::<wlr_seat_keyboard_state>(),
        160usize,
        concat!("Size of: ", stringify!(wlr_seat_keyboard_state))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_seat_keyboard_state>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_seat_keyboard_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_seat_keyboard_state>())).seat as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_keyboard_state),
            "::",
            stringify!(seat)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_seat_keyboard_state>())).keyboard as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_keyboard_state),
            "::",
            stringify!(keyboard)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_seat_keyboard_state>())).focused_client as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_keyboard_state),
            "::",
            stringify!(focused_client)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_seat_keyboard_state>())).focused_surface as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_keyboard_state),
            "::",
            stringify!(focused_surface)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_seat_keyboard_state>())).keyboard_destroy as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_keyboard_state),
            "::",
            stringify!(keyboard_destroy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_seat_keyboard_state>())).keyboard_keymap as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_keyboard_state),
            "::",
            stringify!(keyboard_keymap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_seat_keyboard_state>())).keyboard_repeat_info as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_keyboard_state),
            "::",
            stringify!(keyboard_repeat_info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_seat_keyboard_state>())).surface_destroy as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_keyboard_state),
            "::",
            stringify!(surface_destroy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_seat_keyboard_state>())).grab as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_keyboard_state),
            "::",
            stringify!(grab)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_seat_keyboard_state>())).default_grab as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_keyboard_state),
            "::",
            stringify!(default_grab)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_seat_keyboard_state>())).events as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_keyboard_state),
            "::",
            stringify!(events)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_seat_touch_state {
    pub seat: *mut wlr_seat,
    pub touch_points: wl_list,
    pub grab_serial: u32,
    pub grab_id: u32,
    pub grab: *mut wlr_seat_touch_grab,
    pub default_grab: *mut wlr_seat_touch_grab,
}
#[test]
fn bindgen_test_layout_wlr_seat_touch_state() {
    assert_eq!(
        ::std::mem::size_of::<wlr_seat_touch_state>(),
        48usize,
        concat!("Size of: ", stringify!(wlr_seat_touch_state))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_seat_touch_state>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_seat_touch_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_seat_touch_state>())).seat as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_touch_state),
            "::",
            stringify!(seat)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_seat_touch_state>())).touch_points as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_touch_state),
            "::",
            stringify!(touch_points)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_seat_touch_state>())).grab_serial as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_touch_state),
            "::",
            stringify!(grab_serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_seat_touch_state>())).grab_id as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_touch_state),
            "::",
            stringify!(grab_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_seat_touch_state>())).grab as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_touch_state),
            "::",
            stringify!(grab)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_seat_touch_state>())).default_grab as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_touch_state),
            "::",
            stringify!(default_grab)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_primary_selection_source {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_seat {
    pub global: *mut wl_global,
    pub display: *mut wl_display,
    pub clients: wl_list,
    pub name: *mut ::std::os::raw::c_char,
    pub capabilities: u32,
    pub last_event: timespec,
    pub selection_source: *mut wlr_data_source,
    pub selection_serial: u32,
    pub selection_offers: wl_list,
    pub primary_selection_source: *mut wlr_primary_selection_source,
    pub primary_selection_serial: u32,
    pub drag: *mut wlr_drag,
    pub drag_source: *mut wlr_data_source,
    pub drag_serial: u32,
    pub drag_offers: wl_list,
    pub pointer_state: wlr_seat_pointer_state,
    pub keyboard_state: wlr_seat_keyboard_state,
    pub touch_state: wlr_seat_touch_state,
    pub display_destroy: wl_listener,
    pub selection_source_destroy: wl_listener,
    pub primary_selection_source_destroy: wl_listener,
    pub drag_source_destroy: wl_listener,
    pub events: wlr_seat__bindgen_ty_1,
    pub data: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_seat__bindgen_ty_1 {
    pub pointer_grab_begin: wl_signal,
    pub pointer_grab_end: wl_signal,
    pub keyboard_grab_begin: wl_signal,
    pub keyboard_grab_end: wl_signal,
    pub touch_grab_begin: wl_signal,
    pub touch_grab_end: wl_signal,
    pub request_set_cursor: wl_signal,
    pub request_set_selection: wl_signal,
    pub set_selection: wl_signal,
    pub request_set_primary_selection: wl_signal,
    pub set_primary_selection: wl_signal,
    pub request_start_drag: wl_signal,
    pub start_drag: wl_signal,
    pub destroy: wl_signal,
}
#[test]
fn bindgen_test_layout_wlr_seat__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wlr_seat__bindgen_ty_1>(),
        224usize,
        concat!("Size of: ", stringify!(wlr_seat__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_seat__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_seat__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_seat__bindgen_ty_1>())).pointer_grab_begin as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat__bindgen_ty_1),
            "::",
            stringify!(pointer_grab_begin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_seat__bindgen_ty_1>())).pointer_grab_end as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat__bindgen_ty_1),
            "::",
            stringify!(pointer_grab_end)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_seat__bindgen_ty_1>())).keyboard_grab_begin as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat__bindgen_ty_1),
            "::",
            stringify!(keyboard_grab_begin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_seat__bindgen_ty_1>())).keyboard_grab_end as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat__bindgen_ty_1),
            "::",
            stringify!(keyboard_grab_end)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_seat__bindgen_ty_1>())).touch_grab_begin as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat__bindgen_ty_1),
            "::",
            stringify!(touch_grab_begin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_seat__bindgen_ty_1>())).touch_grab_end as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat__bindgen_ty_1),
            "::",
            stringify!(touch_grab_end)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_seat__bindgen_ty_1>())).request_set_cursor as *const _
                as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat__bindgen_ty_1),
            "::",
            stringify!(request_set_cursor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_seat__bindgen_ty_1>())).request_set_selection as *const _
                as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat__bindgen_ty_1),
            "::",
            stringify!(request_set_selection)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_seat__bindgen_ty_1>())).set_selection as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat__bindgen_ty_1),
            "::",
            stringify!(set_selection)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_seat__bindgen_ty_1>())).request_set_primary_selection
                as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat__bindgen_ty_1),
            "::",
            stringify!(request_set_primary_selection)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_seat__bindgen_ty_1>())).set_primary_selection as *const _
                as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat__bindgen_ty_1),
            "::",
            stringify!(set_primary_selection)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_seat__bindgen_ty_1>())).request_start_drag as *const _
                as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat__bindgen_ty_1),
            "::",
            stringify!(request_start_drag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_seat__bindgen_ty_1>())).start_drag as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat__bindgen_ty_1),
            "::",
            stringify!(start_drag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_seat__bindgen_ty_1>())).destroy as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat__bindgen_ty_1),
            "::",
            stringify!(destroy)
        )
    );
}
#[test]
fn bindgen_test_layout_wlr_seat() {
    assert_eq!(
        ::std::mem::size_of::<wlr_seat>(),
        872usize,
        concat!("Size of: ", stringify!(wlr_seat))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_seat>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_seat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_seat>())).global as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat),
            "::",
            stringify!(global)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_seat>())).display as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_seat>())).clients as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat),
            "::",
            stringify!(clients)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_seat>())).name as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_seat>())).capabilities as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat),
            "::",
            stringify!(capabilities)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_seat>())).last_event as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat),
            "::",
            stringify!(last_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_seat>())).selection_source as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat),
            "::",
            stringify!(selection_source)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_seat>())).selection_serial as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat),
            "::",
            stringify!(selection_serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_seat>())).selection_offers as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat),
            "::",
            stringify!(selection_offers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_seat>())).primary_selection_source as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat),
            "::",
            stringify!(primary_selection_source)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_seat>())).primary_selection_serial as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat),
            "::",
            stringify!(primary_selection_serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_seat>())).drag as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat),
            "::",
            stringify!(drag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_seat>())).drag_source as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat),
            "::",
            stringify!(drag_source)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_seat>())).drag_serial as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat),
            "::",
            stringify!(drag_serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_seat>())).drag_offers as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat),
            "::",
            stringify!(drag_offers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_seat>())).pointer_state as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat),
            "::",
            stringify!(pointer_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_seat>())).keyboard_state as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat),
            "::",
            stringify!(keyboard_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_seat>())).touch_state as *const _ as usize },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat),
            "::",
            stringify!(touch_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_seat>())).display_destroy as *const _ as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat),
            "::",
            stringify!(display_destroy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_seat>())).selection_source_destroy as *const _ as usize
        },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat),
            "::",
            stringify!(selection_source_destroy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_seat>())).primary_selection_source_destroy as *const _
                as usize
        },
        592usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat),
            "::",
            stringify!(primary_selection_source_destroy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_seat>())).drag_source_destroy as *const _ as usize },
        616usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat),
            "::",
            stringify!(drag_source_destroy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_seat>())).events as *const _ as usize },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_seat>())).data as *const _ as usize },
        864usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_seat_pointer_request_set_cursor_event {
    pub seat_client: *mut wlr_seat_client,
    pub surface: *mut wlr_surface,
    pub serial: u32,
    pub hotspot_x: i32,
    pub hotspot_y: i32,
}
#[test]
fn bindgen_test_layout_wlr_seat_pointer_request_set_cursor_event() {
    assert_eq!(
        ::std::mem::size_of::<wlr_seat_pointer_request_set_cursor_event>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(wlr_seat_pointer_request_set_cursor_event)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_seat_pointer_request_set_cursor_event>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(wlr_seat_pointer_request_set_cursor_event)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_seat_pointer_request_set_cursor_event>())).seat_client
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_pointer_request_set_cursor_event),
            "::",
            stringify!(seat_client)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_seat_pointer_request_set_cursor_event>())).surface
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_pointer_request_set_cursor_event),
            "::",
            stringify!(surface)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_seat_pointer_request_set_cursor_event>())).serial as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_pointer_request_set_cursor_event),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_seat_pointer_request_set_cursor_event>())).hotspot_x
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_pointer_request_set_cursor_event),
            "::",
            stringify!(hotspot_x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_seat_pointer_request_set_cursor_event>())).hotspot_y
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_pointer_request_set_cursor_event),
            "::",
            stringify!(hotspot_y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_seat_request_set_selection_event {
    pub source: *mut wlr_data_source,
    pub serial: u32,
}
#[test]
fn bindgen_test_layout_wlr_seat_request_set_selection_event() {
    assert_eq!(
        ::std::mem::size_of::<wlr_seat_request_set_selection_event>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(wlr_seat_request_set_selection_event)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_seat_request_set_selection_event>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(wlr_seat_request_set_selection_event)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_seat_request_set_selection_event>())).source as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_request_set_selection_event),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_seat_request_set_selection_event>())).serial as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_request_set_selection_event),
            "::",
            stringify!(serial)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_seat_request_set_primary_selection_event {
    pub source: *mut wlr_primary_selection_source,
    pub serial: u32,
}
#[test]
fn bindgen_test_layout_wlr_seat_request_set_primary_selection_event() {
    assert_eq!(
        ::std::mem::size_of::<wlr_seat_request_set_primary_selection_event>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(wlr_seat_request_set_primary_selection_event)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_seat_request_set_primary_selection_event>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(wlr_seat_request_set_primary_selection_event)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_seat_request_set_primary_selection_event>())).source
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_request_set_primary_selection_event),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_seat_request_set_primary_selection_event>())).serial
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_request_set_primary_selection_event),
            "::",
            stringify!(serial)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_seat_request_start_drag_event {
    pub drag: *mut wlr_drag,
    pub origin: *mut wlr_surface,
    pub serial: u32,
}
#[test]
fn bindgen_test_layout_wlr_seat_request_start_drag_event() {
    assert_eq!(
        ::std::mem::size_of::<wlr_seat_request_start_drag_event>(),
        24usize,
        concat!("Size of: ", stringify!(wlr_seat_request_start_drag_event))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_seat_request_start_drag_event>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(wlr_seat_request_start_drag_event)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_seat_request_start_drag_event>())).drag as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_request_start_drag_event),
            "::",
            stringify!(drag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_seat_request_start_drag_event>())).origin as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_request_start_drag_event),
            "::",
            stringify!(origin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_seat_request_start_drag_event>())).serial as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_request_start_drag_event),
            "::",
            stringify!(serial)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_seat_pointer_focus_change_event {
    pub seat: *mut wlr_seat,
    pub old_surface: *mut wlr_surface,
    pub new_surface: *mut wlr_surface,
    pub sx: f64,
    pub sy: f64,
}
#[test]
fn bindgen_test_layout_wlr_seat_pointer_focus_change_event() {
    assert_eq!(
        ::std::mem::size_of::<wlr_seat_pointer_focus_change_event>(),
        40usize,
        concat!("Size of: ", stringify!(wlr_seat_pointer_focus_change_event))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_seat_pointer_focus_change_event>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(wlr_seat_pointer_focus_change_event)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_seat_pointer_focus_change_event>())).seat as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_pointer_focus_change_event),
            "::",
            stringify!(seat)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_seat_pointer_focus_change_event>())).old_surface as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_pointer_focus_change_event),
            "::",
            stringify!(old_surface)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_seat_pointer_focus_change_event>())).new_surface as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_pointer_focus_change_event),
            "::",
            stringify!(new_surface)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_seat_pointer_focus_change_event>())).sx as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_pointer_focus_change_event),
            "::",
            stringify!(sx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_seat_pointer_focus_change_event>())).sy as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_pointer_focus_change_event),
            "::",
            stringify!(sy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_seat_keyboard_focus_change_event {
    pub seat: *mut wlr_seat,
    pub old_surface: *mut wlr_surface,
    pub new_surface: *mut wlr_surface,
}
#[test]
fn bindgen_test_layout_wlr_seat_keyboard_focus_change_event() {
    assert_eq!(
        ::std::mem::size_of::<wlr_seat_keyboard_focus_change_event>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(wlr_seat_keyboard_focus_change_event)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_seat_keyboard_focus_change_event>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(wlr_seat_keyboard_focus_change_event)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_seat_keyboard_focus_change_event>())).seat as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_keyboard_focus_change_event),
            "::",
            stringify!(seat)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_seat_keyboard_focus_change_event>())).old_surface as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_keyboard_focus_change_event),
            "::",
            stringify!(old_surface)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_seat_keyboard_focus_change_event>())).new_surface as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_seat_keyboard_focus_change_event),
            "::",
            stringify!(new_surface)
        )
    );
}
extern "C" {
    #[doc = " Allocates a new wlr_seat and adds a wl_seat global to the display."]
    pub fn wlr_seat_create(
        display: *mut wl_display,
        name: *const ::std::os::raw::c_char,
    ) -> *mut wlr_seat;
}
extern "C" {
    #[doc = " Destroys a wlr_seat and removes its wl_seat global."]
    pub fn wlr_seat_destroy(wlr_seat: *mut wlr_seat);
}
extern "C" {
    #[doc = " Gets a wlr_seat_client for the specified client, or returns NULL if no"]
    #[doc = " client is bound for that client."]
    pub fn wlr_seat_client_for_wl_client(
        wlr_seat: *mut wlr_seat,
        wl_client: *mut wl_client,
    ) -> *mut wlr_seat_client;
}
extern "C" {
    #[doc = " Updates the capabilities available on this seat."]
    #[doc = " Will automatically send them to all clients."]
    pub fn wlr_seat_set_capabilities(wlr_seat: *mut wlr_seat, capabilities: u32);
}
extern "C" {
    #[doc = " Updates the name of this seat."]
    #[doc = " Will automatically send it to all clients."]
    pub fn wlr_seat_set_name(wlr_seat: *mut wlr_seat, name: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Whether or not the surface has pointer focus"]
    pub fn wlr_seat_pointer_surface_has_focus(
        wlr_seat: *mut wlr_seat,
        surface: *mut wlr_surface,
    ) -> bool;
}
extern "C" {
    #[doc = " Send a pointer enter event to the given surface and consider it to be the"]
    #[doc = " focused surface for the pointer. This will send a leave event to the last"]
    #[doc = " surface that was entered. Coordinates for the enter event are surface-local."]
    #[doc = " Compositor should use `wlr_seat_pointer_notify_enter()` to change pointer"]
    #[doc = " focus to respect pointer grabs."]
    pub fn wlr_seat_pointer_enter(
        wlr_seat: *mut wlr_seat,
        surface: *mut wlr_surface,
        sx: f64,
        sy: f64,
    );
}
extern "C" {
    #[doc = " Clear the focused surface for the pointer and leave all entered surfaces."]
    pub fn wlr_seat_pointer_clear_focus(wlr_seat: *mut wlr_seat);
}
extern "C" {
    #[doc = " Send a motion event to the surface with pointer focus. Coordinates for the"]
    #[doc = " motion event are surface-local. Compositors should use"]
    #[doc = " `wlr_seat_pointer_notify_motion()` to send motion events to respect pointer"]
    #[doc = " grabs."]
    pub fn wlr_seat_pointer_send_motion(wlr_seat: *mut wlr_seat, time_msec: u32, sx: f64, sy: f64);
}
extern "C" {
    #[doc = " Send a button event to the surface with pointer focus. Coordinates for the"]
    #[doc = " button event are surface-local. Returns the serial. Compositors should use"]
    #[doc = " `wlr_seat_pointer_notify_button()` to send button events to respect pointer"]
    #[doc = " grabs."]
    pub fn wlr_seat_pointer_send_button(
        wlr_seat: *mut wlr_seat,
        time_msec: u32,
        button: u32,
        state: wlr_button_state::Type,
    ) -> u32;
}
extern "C" {
    #[doc = " Send an axis event to the surface with pointer focus. Compositors should use"]
    #[doc = " `wlr_seat_pointer_notify_axis()` to send axis events to respect pointer"]
    #[doc = " grabs."]
    pub fn wlr_seat_pointer_send_axis(
        wlr_seat: *mut wlr_seat,
        time_msec: u32,
        orientation: wlr_axis_orientation::Type,
        value: f64,
        value_discrete: i32,
        source: wlr_axis_source::Type,
    );
}
extern "C" {
    #[doc = " Send a frame event to the surface with pointer focus. Compositors should use"]
    #[doc = " `wlr_seat_pointer_notify_frame()` to send axis events to respect pointer"]
    #[doc = " grabs."]
    pub fn wlr_seat_pointer_send_frame(wlr_seat: *mut wlr_seat);
}
extern "C" {
    #[doc = " Start a grab of the pointer of this seat. The grabber is responsible for"]
    #[doc = " handling all pointer events until the grab ends."]
    pub fn wlr_seat_pointer_start_grab(wlr_seat: *mut wlr_seat, grab: *mut wlr_seat_pointer_grab);
}
extern "C" {
    #[doc = " End the grab of the pointer of this seat. This reverts the grab back to the"]
    #[doc = " default grab for the pointer."]
    pub fn wlr_seat_pointer_end_grab(wlr_seat: *mut wlr_seat);
}
extern "C" {
    #[doc = " Notify the seat of a pointer enter event to the given surface and request it"]
    #[doc = " to be the focused surface for the pointer. Pass surface-local coordinates"]
    #[doc = " where the enter occurred."]
    pub fn wlr_seat_pointer_notify_enter(
        wlr_seat: *mut wlr_seat,
        surface: *mut wlr_surface,
        sx: f64,
        sy: f64,
    );
}
extern "C" {
    #[doc = " Notify the seat of motion over the given surface. Pass surface-local"]
    #[doc = " coordinates where the pointer motion occurred."]
    pub fn wlr_seat_pointer_notify_motion(
        wlr_seat: *mut wlr_seat,
        time_msec: u32,
        sx: f64,
        sy: f64,
    );
}
extern "C" {
    #[doc = " Notify the seat that a button has been pressed. Returns the serial of the"]
    #[doc = " button press or zero if no button press was sent."]
    pub fn wlr_seat_pointer_notify_button(
        wlr_seat: *mut wlr_seat,
        time_msec: u32,
        button: u32,
        state: wlr_button_state::Type,
    ) -> u32;
}
extern "C" {
    #[doc = " Notify the seat of an axis event."]
    pub fn wlr_seat_pointer_notify_axis(
        wlr_seat: *mut wlr_seat,
        time_msec: u32,
        orientation: wlr_axis_orientation::Type,
        value: f64,
        value_discrete: i32,
        source: wlr_axis_source::Type,
    );
}
extern "C" {
    #[doc = " Notify the seat of a frame event. Frame events are sent to end a group of"]
    #[doc = " events that logically belong together. Motion, button and axis events should"]
    #[doc = " all be followed by a frame event."]
    pub fn wlr_seat_pointer_notify_frame(wlr_seat: *mut wlr_seat);
}
extern "C" {
    #[doc = " Whether or not the pointer has a grab other than the default grab."]
    pub fn wlr_seat_pointer_has_grab(seat: *mut wlr_seat) -> bool;
}
extern "C" {
    #[doc = " Set this keyboard as the active keyboard for the seat."]
    pub fn wlr_seat_set_keyboard(seat: *mut wlr_seat, dev: *mut wlr_input_device);
}
extern "C" {
    #[doc = " Get the active keyboard for the seat."]
    pub fn wlr_seat_get_keyboard(seat: *mut wlr_seat) -> *mut wlr_keyboard;
}
extern "C" {
    #[doc = " Start a grab of the keyboard of this seat. The grabber is responsible for"]
    #[doc = " handling all keyboard events until the grab ends."]
    pub fn wlr_seat_keyboard_start_grab(wlr_seat: *mut wlr_seat, grab: *mut wlr_seat_keyboard_grab);
}
extern "C" {
    #[doc = " End the grab of the keyboard of this seat. This reverts the grab back to the"]
    #[doc = " default grab for the keyboard."]
    pub fn wlr_seat_keyboard_end_grab(wlr_seat: *mut wlr_seat);
}
extern "C" {
    #[doc = " Send the keyboard key to focused keyboard resources. Compositors should use"]
    #[doc = " `wlr_seat_notify_key()` to respect keyboard grabs."]
    pub fn wlr_seat_keyboard_send_key(seat: *mut wlr_seat, time_msec: u32, key: u32, state: u32);
}
extern "C" {
    #[doc = " Notify the seat that a key has been pressed on the keyboard. Defers to any"]
    #[doc = " keyboard grabs."]
    pub fn wlr_seat_keyboard_notify_key(seat: *mut wlr_seat, time_msec: u32, key: u32, state: u32);
}
extern "C" {
    #[doc = " Send the modifier state to focused keyboard resources. Compositors should use"]
    #[doc = " `wlr_seat_keyboard_notify_modifiers()` to respect any keyboard grabs."]
    pub fn wlr_seat_keyboard_send_modifiers(
        seat: *mut wlr_seat,
        modifiers: *mut wlr_keyboard_modifiers,
    );
}
extern "C" {
    #[doc = " Notify the seat that the modifiers for the keyboard have changed. Defers to"]
    #[doc = " any keyboard grabs."]
    pub fn wlr_seat_keyboard_notify_modifiers(
        seat: *mut wlr_seat,
        modifiers: *mut wlr_keyboard_modifiers,
    );
}
extern "C" {
    #[doc = " Notify the seat that the keyboard focus has changed and request it to be the"]
    #[doc = " focused surface for this keyboard. Defers to any current grab of the seat's"]
    #[doc = " keyboard."]
    pub fn wlr_seat_keyboard_notify_enter(
        seat: *mut wlr_seat,
        surface: *mut wlr_surface,
        keycodes: *mut u32,
        num_keycodes: usize,
        modifiers: *mut wlr_keyboard_modifiers,
    );
}
extern "C" {
    #[doc = " Send a keyboard enter event to the given surface and consider it to be the"]
    #[doc = " focused surface for the keyboard. This will send a leave event to the last"]
    #[doc = " surface that was entered. Compositors should use"]
    #[doc = " `wlr_seat_keyboard_notify_enter()` to change keyboard focus to respect"]
    #[doc = " keyboard grabs."]
    pub fn wlr_seat_keyboard_enter(
        seat: *mut wlr_seat,
        surface: *mut wlr_surface,
        keycodes: *mut u32,
        num_keycodes: usize,
        modifiers: *mut wlr_keyboard_modifiers,
    );
}
extern "C" {
    #[doc = " Clear the focused surface for the keyboard and leave all entered surfaces."]
    pub fn wlr_seat_keyboard_clear_focus(wlr_seat: *mut wlr_seat);
}
extern "C" {
    #[doc = " Whether or not the keyboard has a grab other than the default grab"]
    pub fn wlr_seat_keyboard_has_grab(seat: *mut wlr_seat) -> bool;
}
extern "C" {
    #[doc = " Start a grab of the touch device of this seat. The grabber is responsible for"]
    #[doc = " handling all touch events until the grab ends."]
    pub fn wlr_seat_touch_start_grab(wlr_seat: *mut wlr_seat, grab: *mut wlr_seat_touch_grab);
}
extern "C" {
    #[doc = " End the grab of the touch device of this seat. This reverts the grab back to"]
    #[doc = " the default grab for the touch device."]
    pub fn wlr_seat_touch_end_grab(wlr_seat: *mut wlr_seat);
}
extern "C" {
    #[doc = " Get the active touch point with the given `touch_id`. If the touch point does"]
    #[doc = " not exist or is no longer active, returns NULL."]
    pub fn wlr_seat_touch_get_point(seat: *mut wlr_seat, touch_id: i32) -> *mut wlr_touch_point;
}
extern "C" {
    #[doc = " Notify the seat of a touch down on the given surface. Defers to any grab of"]
    #[doc = " the touch device."]
    pub fn wlr_seat_touch_notify_down(
        seat: *mut wlr_seat,
        surface: *mut wlr_surface,
        time_msec: u32,
        touch_id: i32,
        sx: f64,
        sy: f64,
    ) -> u32;
}
extern "C" {
    #[doc = " Notify the seat that the touch point given by `touch_id` is up. Defers to any"]
    #[doc = " grab of the touch device."]
    pub fn wlr_seat_touch_notify_up(seat: *mut wlr_seat, time_msec: u32, touch_id: i32);
}
extern "C" {
    #[doc = " Notify the seat that the touch point given by `touch_id` has moved. Defers to"]
    #[doc = " any grab of the touch device. The seat should be notified of touch motion"]
    #[doc = " even if the surface is not the owner of the touch point for processing by"]
    #[doc = " grabs."]
    pub fn wlr_seat_touch_notify_motion(
        seat: *mut wlr_seat,
        time_msec: u32,
        touch_id: i32,
        sx: f64,
        sy: f64,
    );
}
extern "C" {
    #[doc = " Notify the seat that the touch point given by `touch_id` has entered a new"]
    #[doc = " surface. The surface is required. To clear focus, use"]
    #[doc = " `wlr_seat_touch_point_clear_focus()`."]
    pub fn wlr_seat_touch_point_focus(
        seat: *mut wlr_seat,
        surface: *mut wlr_surface,
        time_msec: u32,
        touch_id: i32,
        sx: f64,
        sy: f64,
    );
}
extern "C" {
    #[doc = " Clear the focused surface for the touch point given by `touch_id`."]
    pub fn wlr_seat_touch_point_clear_focus(seat: *mut wlr_seat, time_msec: u32, touch_id: i32);
}
extern "C" {
    #[doc = " Send a touch down event to the client of the given surface. All future touch"]
    #[doc = " events for this point will go to this surface. If the touch down is valid,"]
    #[doc = " this will add a new touch point with the given `touch_id`. The touch down may"]
    #[doc = " not be valid if the surface seat client does not accept touch input."]
    #[doc = " Coordinates are surface-local. Compositors should use"]
    #[doc = " `wlr_seat_touch_notify_down()` to respect any grabs of the touch device."]
    pub fn wlr_seat_touch_send_down(
        seat: *mut wlr_seat,
        surface: *mut wlr_surface,
        time_msec: u32,
        touch_id: i32,
        sx: f64,
        sy: f64,
    ) -> u32;
}
extern "C" {
    #[doc = " Send a touch up event for the touch point given by the `touch_id`. The event"]
    #[doc = " will go to the client for the surface given in the cooresponding touch down"]
    #[doc = " event. This will remove the touch point. Compositors should use"]
    #[doc = " `wlr_seat_touch_notify_up()` to respect any grabs of the touch device."]
    pub fn wlr_seat_touch_send_up(seat: *mut wlr_seat, time_msec: u32, touch_id: i32);
}
extern "C" {
    #[doc = " Send a touch motion event for the touch point given by the `touch_id`. The"]
    #[doc = " event will go to the client for the surface given in the corresponding touch"]
    #[doc = " down event. Compositors should use `wlr_seat_touch_notify_motion()` to"]
    #[doc = " respect any grabs of the touch device."]
    pub fn wlr_seat_touch_send_motion(
        seat: *mut wlr_seat,
        time_msec: u32,
        touch_id: i32,
        sx: f64,
        sy: f64,
    );
}
extern "C" {
    #[doc = " How many touch points are currently down for the seat."]
    pub fn wlr_seat_touch_num_points(seat: *mut wlr_seat) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Whether or not the seat has a touch grab other than the default grab."]
    pub fn wlr_seat_touch_has_grab(seat: *mut wlr_seat) -> bool;
}
extern "C" {
    #[doc = " Check whether this serial is valid to start a grab action such as an"]
    #[doc = " interactive move or resize."]
    pub fn wlr_seat_validate_grab_serial(seat: *mut wlr_seat, serial: u32) -> bool;
}
extern "C" {
    #[doc = " Check whether this serial is valid to start a pointer grab action."]
    pub fn wlr_seat_validate_pointer_grab_serial(
        seat: *mut wlr_seat,
        origin: *mut wlr_surface,
        serial: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Check whether this serial is valid to start a touch grab action. If it's the"]
    #[doc = " case and point_ptr is non-NULL, *point_ptr is set to the touch point matching"]
    #[doc = " the serial."]
    pub fn wlr_seat_validate_touch_grab_serial(
        seat: *mut wlr_seat,
        origin: *mut wlr_surface,
        serial: u32,
        point_ptr: *mut *mut wlr_touch_point,
    ) -> bool;
}
extern "C" {
    #[doc = " Return a new serial (from wl_display_serial_next()) for the client, and"]
    #[doc = " update the seat client's set of valid serials. Use this for all input"]
    #[doc = " events; otherwise wlr_seat_client_validate_event_serial() may fail when"]
    #[doc = " handed a correctly functioning client's request serials."]
    pub fn wlr_seat_client_next_serial(client: *mut wlr_seat_client) -> u32;
}
extern "C" {
    #[doc = " Return true if the serial number could have been produced by"]
    #[doc = " wlr_seat_client_next_serial() and is \"older\" (by less than UINT32_MAX/2) than"]
    #[doc = " the current display serial value."]
    #[doc = ""]
    #[doc = " This function should have no false negatives, and the only false positive"]
    #[doc = " responses allowed are for elements that are still \"older\" than the current"]
    #[doc = " display serial value and also older than all serial values remaining in"]
    #[doc = " the seat client's serial ring buffer, if that buffer is also full."]
    pub fn wlr_seat_client_validate_event_serial(client: *mut wlr_seat_client, serial: u32)
        -> bool;
}
extern "C" {
    #[doc = " Get a seat client from a seat resource. Returns NULL if inert."]
    pub fn wlr_seat_client_from_resource(resource: *mut wl_resource) -> *mut wlr_seat_client;
}
extern "C" {
    #[doc = " Get a seat client from a pointer resource. Returns NULL if inert."]
    pub fn wlr_seat_client_from_pointer_resource(
        resource: *mut wl_resource,
    ) -> *mut wlr_seat_client;
}
extern "C" {
    pub static wlr_data_device_pointer_drag_interface: wlr_pointer_grab_interface;
}
extern "C" {
    pub static wlr_data_device_keyboard_drag_interface: wlr_keyboard_grab_interface;
}
extern "C" {
    pub static wlr_data_device_touch_drag_interface: wlr_touch_grab_interface;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_data_device_manager {
    pub global: *mut wl_global,
    pub resources: wl_list,
    pub data_sources: wl_list,
    pub display_destroy: wl_listener,
    pub events: wlr_data_device_manager__bindgen_ty_1,
    pub data: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_data_device_manager__bindgen_ty_1 {
    pub destroy: wl_signal,
}
#[test]
fn bindgen_test_layout_wlr_data_device_manager__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wlr_data_device_manager__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(wlr_data_device_manager__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_data_device_manager__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(wlr_data_device_manager__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_data_device_manager__bindgen_ty_1>())).destroy as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_data_device_manager__bindgen_ty_1),
            "::",
            stringify!(destroy)
        )
    );
}
#[test]
fn bindgen_test_layout_wlr_data_device_manager() {
    assert_eq!(
        ::std::mem::size_of::<wlr_data_device_manager>(),
        88usize,
        concat!("Size of: ", stringify!(wlr_data_device_manager))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_data_device_manager>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_data_device_manager))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_data_device_manager>())).global as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_data_device_manager),
            "::",
            stringify!(global)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_data_device_manager>())).resources as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_data_device_manager),
            "::",
            stringify!(resources)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_data_device_manager>())).data_sources as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_data_device_manager),
            "::",
            stringify!(data_sources)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_data_device_manager>())).display_destroy as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_data_device_manager),
            "::",
            stringify!(display_destroy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_data_device_manager>())).events as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_data_device_manager),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_data_device_manager>())).data as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_data_device_manager),
            "::",
            stringify!(data)
        )
    );
}
pub mod wlr_data_offer_type {
    pub type Type = u32;
    pub const WLR_DATA_OFFER_SELECTION: Type = 0;
    pub const WLR_DATA_OFFER_DRAG: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_data_offer {
    pub resource: *mut wl_resource,
    pub source: *mut wlr_data_source,
    pub type_: wlr_data_offer_type::Type,
    pub link: wl_list,
    pub actions: u32,
    pub preferred_action: wl_data_device_manager_dnd_action::Type,
    pub in_ask: bool,
    pub source_destroy: wl_listener,
}
#[test]
fn bindgen_test_layout_wlr_data_offer() {
    assert_eq!(
        ::std::mem::size_of::<wlr_data_offer>(),
        80usize,
        concat!("Size of: ", stringify!(wlr_data_offer))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_data_offer>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_data_offer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_data_offer>())).resource as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_data_offer),
            "::",
            stringify!(resource)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_data_offer>())).source as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_data_offer),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_data_offer>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_data_offer),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_data_offer>())).link as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_data_offer),
            "::",
            stringify!(link)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_data_offer>())).actions as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_data_offer),
            "::",
            stringify!(actions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_data_offer>())).preferred_action as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_data_offer),
            "::",
            stringify!(preferred_action)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_data_offer>())).in_ask as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_data_offer),
            "::",
            stringify!(in_ask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_data_offer>())).source_destroy as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_data_offer),
            "::",
            stringify!(source_destroy)
        )
    );
}
#[doc = " A data source implementation. Only the `send` function is mandatory. Refer to"]
#[doc = " the matching wl_data_source_* functions documentation to know what they do."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_data_source_impl {
    pub send: ::std::option::Option<
        unsafe extern "C" fn(
            source: *mut wlr_data_source,
            mime_type: *const ::std::os::raw::c_char,
            fd: i32,
        ),
    >,
    pub accept: ::std::option::Option<
        unsafe extern "C" fn(
            source: *mut wlr_data_source,
            serial: u32,
            mime_type: *const ::std::os::raw::c_char,
        ),
    >,
    pub destroy: ::std::option::Option<unsafe extern "C" fn(source: *mut wlr_data_source)>,
    pub dnd_drop: ::std::option::Option<unsafe extern "C" fn(source: *mut wlr_data_source)>,
    pub dnd_finish: ::std::option::Option<unsafe extern "C" fn(source: *mut wlr_data_source)>,
    pub dnd_action: ::std::option::Option<
        unsafe extern "C" fn(
            source: *mut wlr_data_source,
            action: wl_data_device_manager_dnd_action::Type,
        ),
    >,
}
#[test]
fn bindgen_test_layout_wlr_data_source_impl() {
    assert_eq!(
        ::std::mem::size_of::<wlr_data_source_impl>(),
        48usize,
        concat!("Size of: ", stringify!(wlr_data_source_impl))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_data_source_impl>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_data_source_impl))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_data_source_impl>())).send as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_data_source_impl),
            "::",
            stringify!(send)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_data_source_impl>())).accept as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_data_source_impl),
            "::",
            stringify!(accept)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_data_source_impl>())).destroy as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_data_source_impl),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_data_source_impl>())).dnd_drop as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_data_source_impl),
            "::",
            stringify!(dnd_drop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_data_source_impl>())).dnd_finish as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_data_source_impl),
            "::",
            stringify!(dnd_finish)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_data_source_impl>())).dnd_action as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_data_source_impl),
            "::",
            stringify!(dnd_action)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_data_source {
    pub impl_: *const wlr_data_source_impl,
    pub mime_types: wl_array,
    pub actions: i32,
    pub accepted: bool,
    pub current_dnd_action: wl_data_device_manager_dnd_action::Type,
    pub compositor_action: u32,
    pub events: wlr_data_source__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_data_source__bindgen_ty_1 {
    pub destroy: wl_signal,
}
#[test]
fn bindgen_test_layout_wlr_data_source__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wlr_data_source__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(wlr_data_source__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_data_source__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_data_source__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_data_source__bindgen_ty_1>())).destroy as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_data_source__bindgen_ty_1),
            "::",
            stringify!(destroy)
        )
    );
}
#[test]
fn bindgen_test_layout_wlr_data_source() {
    assert_eq!(
        ::std::mem::size_of::<wlr_data_source>(),
        64usize,
        concat!("Size of: ", stringify!(wlr_data_source))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_data_source>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_data_source))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_data_source>())).impl_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_data_source),
            "::",
            stringify!(impl_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_data_source>())).mime_types as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_data_source),
            "::",
            stringify!(mime_types)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_data_source>())).actions as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_data_source),
            "::",
            stringify!(actions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_data_source>())).accepted as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_data_source),
            "::",
            stringify!(accepted)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_data_source>())).current_dnd_action as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_data_source),
            "::",
            stringify!(current_dnd_action)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_data_source>())).compositor_action as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_data_source),
            "::",
            stringify!(compositor_action)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_data_source>())).events as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_data_source),
            "::",
            stringify!(events)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_drag_icon {
    pub drag: *mut wlr_drag,
    pub surface: *mut wlr_surface,
    pub mapped: bool,
    pub events: wlr_drag_icon__bindgen_ty_1,
    pub surface_destroy: wl_listener,
    pub data: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_drag_icon__bindgen_ty_1 {
    pub map: wl_signal,
    pub unmap: wl_signal,
    pub destroy: wl_signal,
}
#[test]
fn bindgen_test_layout_wlr_drag_icon__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wlr_drag_icon__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(wlr_drag_icon__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_drag_icon__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_drag_icon__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_drag_icon__bindgen_ty_1>())).map as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_drag_icon__bindgen_ty_1),
            "::",
            stringify!(map)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_drag_icon__bindgen_ty_1>())).unmap as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_drag_icon__bindgen_ty_1),
            "::",
            stringify!(unmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_drag_icon__bindgen_ty_1>())).destroy as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_drag_icon__bindgen_ty_1),
            "::",
            stringify!(destroy)
        )
    );
}
#[test]
fn bindgen_test_layout_wlr_drag_icon() {
    assert_eq!(
        ::std::mem::size_of::<wlr_drag_icon>(),
        104usize,
        concat!("Size of: ", stringify!(wlr_drag_icon))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_drag_icon>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_drag_icon))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_drag_icon>())).drag as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_drag_icon),
            "::",
            stringify!(drag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_drag_icon>())).surface as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_drag_icon),
            "::",
            stringify!(surface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_drag_icon>())).mapped as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_drag_icon),
            "::",
            stringify!(mapped)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_drag_icon>())).events as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_drag_icon),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_drag_icon>())).surface_destroy as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_drag_icon),
            "::",
            stringify!(surface_destroy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_drag_icon>())).data as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_drag_icon),
            "::",
            stringify!(data)
        )
    );
}
pub mod wlr_drag_grab_type {
    pub type Type = u32;
    pub const WLR_DRAG_GRAB_KEYBOARD: Type = 0;
    pub const WLR_DRAG_GRAB_KEYBOARD_POINTER: Type = 1;
    pub const WLR_DRAG_GRAB_KEYBOARD_TOUCH: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_drag {
    pub grab_type: wlr_drag_grab_type::Type,
    pub keyboard_grab: wlr_seat_keyboard_grab,
    pub pointer_grab: wlr_seat_pointer_grab,
    pub touch_grab: wlr_seat_touch_grab,
    pub seat: *mut wlr_seat,
    pub seat_client: *mut wlr_seat_client,
    pub focus_client: *mut wlr_seat_client,
    pub icon: *mut wlr_drag_icon,
    pub focus: *mut wlr_surface,
    pub source: *mut wlr_data_source,
    pub started: bool,
    pub dropped: bool,
    pub cancelling: bool,
    pub grab_touch_id: i32,
    pub touch_id: i32,
    pub events: wlr_drag__bindgen_ty_1,
    pub point_destroy: wl_listener,
    pub source_destroy: wl_listener,
    pub seat_client_destroy: wl_listener,
    pub icon_destroy: wl_listener,
    pub data: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_drag__bindgen_ty_1 {
    pub focus: wl_signal,
    pub motion: wl_signal,
    pub drop: wl_signal,
    pub destroy: wl_signal,
}
#[test]
fn bindgen_test_layout_wlr_drag__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wlr_drag__bindgen_ty_1>(),
        64usize,
        concat!("Size of: ", stringify!(wlr_drag__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_drag__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_drag__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_drag__bindgen_ty_1>())).focus as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_drag__bindgen_ty_1),
            "::",
            stringify!(focus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_drag__bindgen_ty_1>())).motion as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_drag__bindgen_ty_1),
            "::",
            stringify!(motion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_drag__bindgen_ty_1>())).drop as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_drag__bindgen_ty_1),
            "::",
            stringify!(drop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_drag__bindgen_ty_1>())).destroy as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_drag__bindgen_ty_1),
            "::",
            stringify!(destroy)
        )
    );
}
#[test]
fn bindgen_test_layout_wlr_drag() {
    assert_eq!(
        ::std::mem::size_of::<wlr_drag>(),
        312usize,
        concat!("Size of: ", stringify!(wlr_drag))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_drag>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_drag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_drag>())).grab_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_drag),
            "::",
            stringify!(grab_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_drag>())).keyboard_grab as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_drag),
            "::",
            stringify!(keyboard_grab)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_drag>())).pointer_grab as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_drag),
            "::",
            stringify!(pointer_grab)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_drag>())).touch_grab as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_drag),
            "::",
            stringify!(touch_grab)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_drag>())).seat as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_drag),
            "::",
            stringify!(seat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_drag>())).seat_client as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_drag),
            "::",
            stringify!(seat_client)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_drag>())).focus_client as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_drag),
            "::",
            stringify!(focus_client)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_drag>())).icon as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_drag),
            "::",
            stringify!(icon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_drag>())).focus as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_drag),
            "::",
            stringify!(focus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_drag>())).source as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_drag),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_drag>())).started as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_drag),
            "::",
            stringify!(started)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_drag>())).dropped as *const _ as usize },
        129usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_drag),
            "::",
            stringify!(dropped)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_drag>())).cancelling as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_drag),
            "::",
            stringify!(cancelling)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_drag>())).grab_touch_id as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_drag),
            "::",
            stringify!(grab_touch_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_drag>())).touch_id as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_drag),
            "::",
            stringify!(touch_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_drag>())).events as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_drag),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_drag>())).point_destroy as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_drag),
            "::",
            stringify!(point_destroy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_drag>())).source_destroy as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_drag),
            "::",
            stringify!(source_destroy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_drag>())).seat_client_destroy as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_drag),
            "::",
            stringify!(seat_client_destroy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_drag>())).icon_destroy as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_drag),
            "::",
            stringify!(icon_destroy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_drag>())).data as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_drag),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_drag_motion_event {
    pub drag: *mut wlr_drag,
    pub time: u32,
    pub sx: f64,
    pub sy: f64,
}
#[test]
fn bindgen_test_layout_wlr_drag_motion_event() {
    assert_eq!(
        ::std::mem::size_of::<wlr_drag_motion_event>(),
        32usize,
        concat!("Size of: ", stringify!(wlr_drag_motion_event))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_drag_motion_event>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_drag_motion_event))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_drag_motion_event>())).drag as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_drag_motion_event),
            "::",
            stringify!(drag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_drag_motion_event>())).time as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_drag_motion_event),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_drag_motion_event>())).sx as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_drag_motion_event),
            "::",
            stringify!(sx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_drag_motion_event>())).sy as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_drag_motion_event),
            "::",
            stringify!(sy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_drag_drop_event {
    pub drag: *mut wlr_drag,
    pub time: u32,
}
#[test]
fn bindgen_test_layout_wlr_drag_drop_event() {
    assert_eq!(
        ::std::mem::size_of::<wlr_drag_drop_event>(),
        16usize,
        concat!("Size of: ", stringify!(wlr_drag_drop_event))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_drag_drop_event>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_drag_drop_event))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_drag_drop_event>())).drag as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_drag_drop_event),
            "::",
            stringify!(drag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_drag_drop_event>())).time as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_drag_drop_event),
            "::",
            stringify!(time)
        )
    );
}
extern "C" {
    #[doc = " Create a wl data device manager global for this display."]
    pub fn wlr_data_device_manager_create(display: *mut wl_display)
        -> *mut wlr_data_device_manager;
}
extern "C" {
    #[doc = " Destroys a wlr_data_device_manager and removes its wl_data_device_manager global."]
    pub fn wlr_data_device_manager_destroy(manager: *mut wlr_data_device_manager);
}
extern "C" {
    #[doc = " Requests a selection to be set for the seat. If the request comes from"]
    #[doc = " a client, then set `client` to be the matching seat client so that this"]
    #[doc = " function can verify that the serial provided was once sent to the client"]
    #[doc = " on this seat."]
    pub fn wlr_seat_request_set_selection(
        seat: *mut wlr_seat,
        client: *mut wlr_seat_client,
        source: *mut wlr_data_source,
        serial: u32,
    );
}
extern "C" {
    #[doc = " Sets the current selection for the seat. NULL can be provided to clear it."]
    #[doc = " This removes the previous one if there was any. In case the selection doesn't"]
    #[doc = " come from a client, wl_display_next_serial() can be used to generate a"]
    #[doc = " serial."]
    pub fn wlr_seat_set_selection(seat: *mut wlr_seat, source: *mut wlr_data_source, serial: u32);
}
extern "C" {
    #[doc = " Creates a new drag. To request to start the drag, call"]
    #[doc = " `wlr_seat_request_start_drag`."]
    pub fn wlr_drag_create(
        seat_client: *mut wlr_seat_client,
        source: *mut wlr_data_source,
        icon_surface: *mut wlr_surface,
    ) -> *mut wlr_drag;
}
extern "C" {
    #[doc = " Requests a drag to be started on the seat."]
    pub fn wlr_seat_request_start_drag(
        seat: *mut wlr_seat,
        drag: *mut wlr_drag,
        origin: *mut wlr_surface,
        serial: u32,
    );
}
extern "C" {
    #[doc = " Starts a drag on the seat. This starts an implicit keyboard grab, but doesn't"]
    #[doc = " start a pointer or a touch grab."]
    pub fn wlr_seat_start_drag(seat: *mut wlr_seat, drag: *mut wlr_drag, serial: u32);
}
extern "C" {
    #[doc = " Starts a pointer drag on the seat. This starts implicit keyboard and pointer"]
    #[doc = " grabs."]
    pub fn wlr_seat_start_pointer_drag(seat: *mut wlr_seat, drag: *mut wlr_drag, serial: u32);
}
extern "C" {
    #[doc = " Starts a touch drag on the seat. This starts implicit keyboard and touch"]
    #[doc = " grabs."]
    pub fn wlr_seat_start_touch_drag(
        seat: *mut wlr_seat,
        drag: *mut wlr_drag,
        serial: u32,
        point: *mut wlr_touch_point,
    );
}
extern "C" {
    #[doc = " Initializes the data source with the provided implementation."]
    pub fn wlr_data_source_init(source: *mut wlr_data_source, impl_: *const wlr_data_source_impl);
}
extern "C" {
    #[doc = " Sends the data as the specified MIME type over the passed file descriptor,"]
    #[doc = " then close it."]
    pub fn wlr_data_source_send(
        source: *mut wlr_data_source,
        mime_type: *const ::std::os::raw::c_char,
        fd: i32,
    );
}
extern "C" {
    #[doc = " Notifies the data source that a target accepts one of the offered MIME types."]
    #[doc = " If a target doesn't accept any of the offered types, `mime_type` is NULL."]
    pub fn wlr_data_source_accept(
        source: *mut wlr_data_source,
        serial: u32,
        mime_type: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Notifies the data source it is no longer valid and should be destroyed. That"]
    #[doc = " destroys immediately the data source."]
    pub fn wlr_data_source_destroy(source: *mut wlr_data_source);
}
extern "C" {
    #[doc = " Notifies the data source that the drop operation was performed. This does not"]
    #[doc = " indicate acceptance."]
    #[doc = ""]
    #[doc = " The data source may still be used in the future and should not be destroyed"]
    #[doc = " here."]
    pub fn wlr_data_source_dnd_drop(source: *mut wlr_data_source);
}
extern "C" {
    #[doc = " Notifies the data source that the drag-and-drop operation concluded. That"]
    #[doc = " potentially destroys immediately the data source."]
    pub fn wlr_data_source_dnd_finish(source: *mut wlr_data_source);
}
extern "C" {
    #[doc = " Notifies the data source that a target accepts the drag with the specified"]
    #[doc = " action."]
    #[doc = ""]
    #[doc = " This shouldn't be called after `wlr_data_source_dnd_drop` unless the"]
    #[doc = " drag-and-drop operation ended in an \"ask\" action."]
    pub fn wlr_data_source_dnd_action(
        source: *mut wlr_data_source,
        action: wl_data_device_manager_dnd_action::Type,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xdg_popup {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zwlr_layer_shell_v1 {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zwlr_layer_surface_v1 {
    _unused: [u8; 0],
}
extern "C" {
    pub static zwlr_layer_shell_v1_interface: wl_interface;
}
extern "C" {
    pub static zwlr_layer_surface_v1_interface: wl_interface;
}
pub mod zwlr_layer_shell_v1_error {
    pub type Type = u32;
    #[doc = " wl_surface has another role"]
    pub const ZWLR_LAYER_SHELL_V1_ERROR_ROLE: Type = 0;
    #[doc = " layer value is invalid"]
    pub const ZWLR_LAYER_SHELL_V1_ERROR_INVALID_LAYER: Type = 1;
    #[doc = " wl_surface has a buffer attached or committed"]
    pub const ZWLR_LAYER_SHELL_V1_ERROR_ALREADY_CONSTRUCTED: Type = 2;
}
pub mod zwlr_layer_shell_v1_layer {
    #[doc = " @ingroup iface_zwlr_layer_shell_v1"]
    #[doc = " available layers for surfaces"]
    #[doc = ""]
    #[doc = " These values indicate which layers a surface can be rendered in. They"]
    #[doc = " are ordered by z depth, bottom-most first. Traditional shell surfaces"]
    #[doc = " will typically be rendered between the bottom and top layers."]
    #[doc = " Fullscreen shell surfaces are typically rendered at the top layer."]
    #[doc = " Multiple surfaces can share a single layer, and ordering within a"]
    #[doc = " single layer is undefined."]
    pub type Type = u32;
    pub const ZWLR_LAYER_SHELL_V1_LAYER_BACKGROUND: Type = 0;
    pub const ZWLR_LAYER_SHELL_V1_LAYER_BOTTOM: Type = 1;
    pub const ZWLR_LAYER_SHELL_V1_LAYER_TOP: Type = 2;
    pub const ZWLR_LAYER_SHELL_V1_LAYER_OVERLAY: Type = 3;
}
#[doc = " @ingroup iface_zwlr_layer_shell_v1"]
#[doc = " @struct zwlr_layer_shell_v1_interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zwlr_layer_shell_v1_interface {
    #[doc = " create a layer_surface from a surface"]
    #[doc = ""]
    #[doc = " Create a layer surface for an existing surface. This assigns"]
    #[doc = " the role of layer_surface, or raises a protocol error if another"]
    #[doc = " role is already assigned."]
    #[doc = ""]
    #[doc = " Creating a layer surface from a wl_surface which has a buffer"]
    #[doc = " attached or committed is a client error, and any attempts by a"]
    #[doc = " client to attach or manipulate a buffer prior to the first"]
    #[doc = " layer_surface.configure call must also be treated as errors."]
    #[doc = ""]
    #[doc = " You may pass NULL for output to allow the compositor to decide"]
    #[doc = " which output to use. Generally this will be the one that the"]
    #[doc = " user most recently interacted with."]
    #[doc = ""]
    #[doc = " Clients can specify a namespace that defines the purpose of the"]
    #[doc = " layer surface."]
    #[doc = " @param layer layer to add this surface to"]
    #[doc = " @param namespace namespace for the layer surface"]
    pub get_layer_surface: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            id: u32,
            surface: *mut wl_resource,
            output: *mut wl_resource,
            layer: u32,
            namespace: *const ::std::os::raw::c_char,
        ),
    >,
}
#[test]
fn bindgen_test_layout_zwlr_layer_shell_v1_interface() {
    assert_eq!(
        ::std::mem::size_of::<zwlr_layer_shell_v1_interface>(),
        8usize,
        concat!("Size of: ", stringify!(zwlr_layer_shell_v1_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<zwlr_layer_shell_v1_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(zwlr_layer_shell_v1_interface))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwlr_layer_shell_v1_interface>())).get_layer_surface as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zwlr_layer_shell_v1_interface),
            "::",
            stringify!(get_layer_surface)
        )
    );
}
pub mod zwlr_layer_surface_v1_error {
    pub type Type = u32;
    #[doc = " provided surface state is invalid"]
    pub const ZWLR_LAYER_SURFACE_V1_ERROR_INVALID_SURFACE_STATE: Type = 0;
    #[doc = " size is invalid"]
    pub const ZWLR_LAYER_SURFACE_V1_ERROR_INVALID_SIZE: Type = 1;
    #[doc = " anchor bitfield is invalid"]
    pub const ZWLR_LAYER_SURFACE_V1_ERROR_INVALID_ANCHOR: Type = 2;
}
pub mod zwlr_layer_surface_v1_anchor {
    pub type Type = u32;
    #[doc = " the top edge of the anchor rectangle"]
    pub const ZWLR_LAYER_SURFACE_V1_ANCHOR_TOP: Type = 1;
    #[doc = " the bottom edge of the anchor rectangle"]
    pub const ZWLR_LAYER_SURFACE_V1_ANCHOR_BOTTOM: Type = 2;
    #[doc = " the left edge of the anchor rectangle"]
    pub const ZWLR_LAYER_SURFACE_V1_ANCHOR_LEFT: Type = 4;
    #[doc = " the right edge of the anchor rectangle"]
    pub const ZWLR_LAYER_SURFACE_V1_ANCHOR_RIGHT: Type = 8;
}
#[doc = " @ingroup iface_zwlr_layer_surface_v1"]
#[doc = " @struct zwlr_layer_surface_v1_interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zwlr_layer_surface_v1_interface {
    #[doc = " sets the size of the surface"]
    #[doc = ""]
    #[doc = " Sets the size of the surface in surface-local coordinates. The"]
    #[doc = " compositor will display the surface centered with respect to its"]
    #[doc = " anchors."]
    #[doc = ""]
    #[doc = " If you pass 0 for either value, the compositor will assign it"]
    #[doc = " and inform you of the assignment in the configure event. You"]
    #[doc = " must set your anchor to opposite edges in the dimensions you"]
    #[doc = " omit; not doing so is a protocol error. Both values are 0 by"]
    #[doc = " default."]
    #[doc = ""]
    #[doc = " Size is double-buffered, see wl_surface.commit."]
    pub set_size: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            width: u32,
            height: u32,
        ),
    >,
    #[doc = " configures the anchor point of the surface"]
    #[doc = ""]
    #[doc = " Requests that the compositor anchor the surface to the"]
    #[doc = " specified edges and corners. If two orthoginal edges are"]
    #[doc = " specified (e.g. 'top' and 'left'), then the anchor point will be"]
    #[doc = " the intersection of the edges (e.g. the top left corner of the"]
    #[doc = " output); otherwise the anchor point will be centered on that"]
    #[doc = " edge, or in the center if none is specified."]
    #[doc = ""]
    #[doc = " Anchor is double-buffered, see wl_surface.commit."]
    pub set_anchor: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource, anchor: u32),
    >,
    #[doc = " configures the exclusive geometry of this surface"]
    #[doc = ""]
    #[doc = " Requests that the compositor avoids occluding an area of the"]
    #[doc = " surface with other surfaces. The compositor's use of this"]
    #[doc = " information is implementation-dependent - do not assume that"]
    #[doc = " this region will not actually be occluded."]
    #[doc = ""]
    #[doc = " A positive value is only meaningful if the surface is anchored"]
    #[doc = " to an edge, rather than a corner. The zone is the number of"]
    #[doc = " surface-local coordinates from the edge that are considered"]
    #[doc = " exclusive."]
    #[doc = ""]
    #[doc = " Surfaces that do not wish to have an exclusive zone may instead"]
    #[doc = " specify how they should interact with surfaces that do. If set"]
    #[doc = " to zero, the surface indicates that it would like to be moved to"]
    #[doc = " avoid occluding surfaces with a positive excluzive zone. If set"]
    #[doc = " to -1, the surface indicates that it would not like to be moved"]
    #[doc = " to accommodate for other surfaces, and the compositor should"]
    #[doc = " extend it all the way to the edges it is anchored to."]
    #[doc = ""]
    #[doc = " For example, a panel might set its exclusive zone to 10, so that"]
    #[doc = " maximized shell surfaces are not shown on top of it. A"]
    #[doc = " notification might set its exclusive zone to 0, so that it is"]
    #[doc = " moved to avoid occluding the panel, but shell surfaces are shown"]
    #[doc = " underneath it. A wallpaper or lock screen might set their"]
    #[doc = " exclusive zone to -1, so that they stretch below or over the"]
    #[doc = " panel."]
    #[doc = ""]
    #[doc = " The default value is 0."]
    #[doc = ""]
    #[doc = " Exclusive zone is double-buffered, see wl_surface.commit."]
    pub set_exclusive_zone: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource, zone: i32),
    >,
    #[doc = " sets a margin from the anchor point"]
    #[doc = ""]
    #[doc = " Requests that the surface be placed some distance away from"]
    #[doc = " the anchor point on the output, in surface-local coordinates."]
    #[doc = " Setting this value for edges you are not anchored to has no"]
    #[doc = " effect."]
    #[doc = ""]
    #[doc = " The exclusive zone includes the margin."]
    #[doc = ""]
    #[doc = " Margin is double-buffered, see wl_surface.commit."]
    pub set_margin: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            top: i32,
            right: i32,
            bottom: i32,
            left: i32,
        ),
    >,
    #[doc = " requests keyboard events"]
    #[doc = ""]
    #[doc = " Set to 1 to request that the seat send keyboard events to this"]
    #[doc = " layer surface. For layers below the shell surface layer, the"]
    #[doc = " seat will use normal focus semantics. For layers above the shell"]
    #[doc = " surface layers, the seat will always give exclusive keyboard"]
    #[doc = " focus to the top-most layer which has keyboard interactivity set"]
    #[doc = " to true."]
    #[doc = ""]
    #[doc = " Layer surfaces receive pointer, touch, and tablet events"]
    #[doc = " normally. If you do not want to receive them, set the input"]
    #[doc = " region on your surface to an empty region."]
    #[doc = ""]
    #[doc = " Events is double-buffered, see wl_surface.commit."]
    pub set_keyboard_interactivity: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            keyboard_interactivity: u32,
        ),
    >,
    #[doc = " assign this layer_surface as an xdg_popup parent"]
    #[doc = ""]
    #[doc = " This assigns an xdg_popup's parent to this layer_surface. This"]
    #[doc = " popup should have been created via xdg_surface::get_popup with"]
    #[doc = " the parent set to NULL, and this request must be invoked before"]
    #[doc = " committing the popup's initial state."]
    #[doc = ""]
    #[doc = " See the documentation of xdg_popup for more details about what"]
    #[doc = " an xdg_popup is and how it is used."]
    pub get_popup: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            popup: *mut wl_resource,
        ),
    >,
    #[doc = " ack a configure event"]
    #[doc = ""]
    #[doc = " When a configure event is received, if a client commits the"]
    #[doc = " surface in response to the configure event, then the client must"]
    #[doc = " make an ack_configure request sometime before the commit"]
    #[doc = " request, passing along the serial of the configure event."]
    #[doc = ""]
    #[doc = " If the client receives multiple configure events before it can"]
    #[doc = " respond to one, it only has to ack the last configure event."]
    #[doc = ""]
    #[doc = " A client is not required to commit immediately after sending an"]
    #[doc = " ack_configure request - it may even ack_configure several times"]
    #[doc = " before its next surface commit."]
    #[doc = ""]
    #[doc = " A client may send multiple ack_configure requests before"]
    #[doc = " committing, but only the last request sent before a commit"]
    #[doc = " indicates which configure event the client really is responding"]
    #[doc = " to."]
    #[doc = " @param serial the serial from the configure event"]
    pub ack_configure: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource, serial: u32),
    >,
    #[doc = " destroy the layer_surface"]
    #[doc = ""]
    #[doc = " This request destroys the layer surface."]
    pub destroy: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
}
#[test]
fn bindgen_test_layout_zwlr_layer_surface_v1_interface() {
    assert_eq!(
        ::std::mem::size_of::<zwlr_layer_surface_v1_interface>(),
        64usize,
        concat!("Size of: ", stringify!(zwlr_layer_surface_v1_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<zwlr_layer_surface_v1_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(zwlr_layer_surface_v1_interface))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwlr_layer_surface_v1_interface>())).set_size as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zwlr_layer_surface_v1_interface),
            "::",
            stringify!(set_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwlr_layer_surface_v1_interface>())).set_anchor as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(zwlr_layer_surface_v1_interface),
            "::",
            stringify!(set_anchor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwlr_layer_surface_v1_interface>())).set_exclusive_zone
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(zwlr_layer_surface_v1_interface),
            "::",
            stringify!(set_exclusive_zone)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwlr_layer_surface_v1_interface>())).set_margin as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(zwlr_layer_surface_v1_interface),
            "::",
            stringify!(set_margin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwlr_layer_surface_v1_interface>())).set_keyboard_interactivity
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(zwlr_layer_surface_v1_interface),
            "::",
            stringify!(set_keyboard_interactivity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwlr_layer_surface_v1_interface>())).get_popup as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(zwlr_layer_surface_v1_interface),
            "::",
            stringify!(get_popup)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwlr_layer_surface_v1_interface>())).ack_configure as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(zwlr_layer_surface_v1_interface),
            "::",
            stringify!(ack_configure)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwlr_layer_surface_v1_interface>())).destroy as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(zwlr_layer_surface_v1_interface),
            "::",
            stringify!(destroy)
        )
    );
}
#[doc = " wlr_layer_shell_v1 allows clients to arrange themselves in \"layers\" on the"]
#[doc = " desktop in accordance with the wlr-layer-shell protocol. When a client is"]
#[doc = " added, the new_surface signal will be raised and passed a reference to our"]
#[doc = " wlr_layer_surface_v1. At this time, the client will have configured the"]
#[doc = " surface as it desires, including information like desired anchors and"]
#[doc = " margins. The compositor should use this information to decide how to arrange"]
#[doc = " the layer on-screen, then determine the dimensions of the layer and call"]
#[doc = " wlr_layer_surface_v1_configure. The client will then attach a buffer and"]
#[doc = " commit the surface, at which point the wlr_layer_surface_v1 map signal is"]
#[doc = " raised and the compositor should begin rendering the surface."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_layer_shell_v1 {
    pub global: *mut wl_global,
    pub resources: wl_list,
    pub surfaces: wl_list,
    pub display_destroy: wl_listener,
    pub events: wlr_layer_shell_v1__bindgen_ty_1,
    pub data: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_layer_shell_v1__bindgen_ty_1 {
    pub new_surface: wl_signal,
    pub destroy: wl_signal,
}
#[test]
fn bindgen_test_layout_wlr_layer_shell_v1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wlr_layer_shell_v1__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(wlr_layer_shell_v1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_layer_shell_v1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(wlr_layer_shell_v1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_layer_shell_v1__bindgen_ty_1>())).new_surface as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_layer_shell_v1__bindgen_ty_1),
            "::",
            stringify!(new_surface)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_layer_shell_v1__bindgen_ty_1>())).destroy as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_layer_shell_v1__bindgen_ty_1),
            "::",
            stringify!(destroy)
        )
    );
}
#[test]
fn bindgen_test_layout_wlr_layer_shell_v1() {
    assert_eq!(
        ::std::mem::size_of::<wlr_layer_shell_v1>(),
        104usize,
        concat!("Size of: ", stringify!(wlr_layer_shell_v1))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_layer_shell_v1>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_layer_shell_v1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_layer_shell_v1>())).global as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_layer_shell_v1),
            "::",
            stringify!(global)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_layer_shell_v1>())).resources as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_layer_shell_v1),
            "::",
            stringify!(resources)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_layer_shell_v1>())).surfaces as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_layer_shell_v1),
            "::",
            stringify!(surfaces)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_layer_shell_v1>())).display_destroy as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_layer_shell_v1),
            "::",
            stringify!(display_destroy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_layer_shell_v1>())).events as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_layer_shell_v1),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_layer_shell_v1>())).data as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_layer_shell_v1),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_layer_surface_v1_state {
    pub anchor: u32,
    pub exclusive_zone: i32,
    pub margin: wlr_layer_surface_v1_state__bindgen_ty_1,
    pub keyboard_interactive: bool,
    pub desired_width: u32,
    pub desired_height: u32,
    pub actual_width: u32,
    pub actual_height: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_layer_surface_v1_state__bindgen_ty_1 {
    pub top: u32,
    pub right: u32,
    pub bottom: u32,
    pub left: u32,
}
#[test]
fn bindgen_test_layout_wlr_layer_surface_v1_state__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wlr_layer_surface_v1_state__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(wlr_layer_surface_v1_state__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_layer_surface_v1_state__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(wlr_layer_surface_v1_state__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_layer_surface_v1_state__bindgen_ty_1>())).top as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_layer_surface_v1_state__bindgen_ty_1),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_layer_surface_v1_state__bindgen_ty_1>())).right as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_layer_surface_v1_state__bindgen_ty_1),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_layer_surface_v1_state__bindgen_ty_1>())).bottom as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_layer_surface_v1_state__bindgen_ty_1),
            "::",
            stringify!(bottom)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_layer_surface_v1_state__bindgen_ty_1>())).left as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_layer_surface_v1_state__bindgen_ty_1),
            "::",
            stringify!(left)
        )
    );
}
#[test]
fn bindgen_test_layout_wlr_layer_surface_v1_state() {
    assert_eq!(
        ::std::mem::size_of::<wlr_layer_surface_v1_state>(),
        44usize,
        concat!("Size of: ", stringify!(wlr_layer_surface_v1_state))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_layer_surface_v1_state>(),
        4usize,
        concat!("Alignment of ", stringify!(wlr_layer_surface_v1_state))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_layer_surface_v1_state>())).anchor as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_layer_surface_v1_state),
            "::",
            stringify!(anchor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_layer_surface_v1_state>())).exclusive_zone as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_layer_surface_v1_state),
            "::",
            stringify!(exclusive_zone)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_layer_surface_v1_state>())).margin as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_layer_surface_v1_state),
            "::",
            stringify!(margin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_layer_surface_v1_state>())).keyboard_interactive as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_layer_surface_v1_state),
            "::",
            stringify!(keyboard_interactive)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_layer_surface_v1_state>())).desired_width as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_layer_surface_v1_state),
            "::",
            stringify!(desired_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_layer_surface_v1_state>())).desired_height as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_layer_surface_v1_state),
            "::",
            stringify!(desired_height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_layer_surface_v1_state>())).actual_width as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_layer_surface_v1_state),
            "::",
            stringify!(actual_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_layer_surface_v1_state>())).actual_height as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_layer_surface_v1_state),
            "::",
            stringify!(actual_height)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_layer_surface_v1_configure {
    pub link: wl_list,
    pub serial: u32,
    pub state: wlr_layer_surface_v1_state,
}
#[test]
fn bindgen_test_layout_wlr_layer_surface_v1_configure() {
    assert_eq!(
        ::std::mem::size_of::<wlr_layer_surface_v1_configure>(),
        64usize,
        concat!("Size of: ", stringify!(wlr_layer_surface_v1_configure))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_layer_surface_v1_configure>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_layer_surface_v1_configure))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_layer_surface_v1_configure>())).link as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_layer_surface_v1_configure),
            "::",
            stringify!(link)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_layer_surface_v1_configure>())).serial as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_layer_surface_v1_configure),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_layer_surface_v1_configure>())).state as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_layer_surface_v1_configure),
            "::",
            stringify!(state)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_layer_surface_v1 {
    pub link: wl_list,
    pub surface: *mut wlr_surface,
    pub output: *mut wlr_output,
    pub resource: *mut wl_resource,
    pub shell: *mut wlr_layer_shell_v1,
    pub popups: wl_list,
    pub namespace: *mut ::std::os::raw::c_char,
    pub layer: zwlr_layer_shell_v1_layer::Type,
    pub added: bool,
    pub configured: bool,
    pub mapped: bool,
    pub closed: bool,
    pub configure_serial: u32,
    pub configure_next_serial: u32,
    pub configure_list: wl_list,
    pub acked_configure: *mut wlr_layer_surface_v1_configure,
    pub client_pending: wlr_layer_surface_v1_state,
    pub server_pending: wlr_layer_surface_v1_state,
    pub current: wlr_layer_surface_v1_state,
    pub surface_destroy: wl_listener,
    pub events: wlr_layer_surface_v1__bindgen_ty_1,
    pub data: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_layer_surface_v1__bindgen_ty_1 {
    pub destroy: wl_signal,
    pub map: wl_signal,
    pub unmap: wl_signal,
    pub new_popup: wl_signal,
}
#[test]
fn bindgen_test_layout_wlr_layer_surface_v1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wlr_layer_surface_v1__bindgen_ty_1>(),
        64usize,
        concat!("Size of: ", stringify!(wlr_layer_surface_v1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_layer_surface_v1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(wlr_layer_surface_v1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_layer_surface_v1__bindgen_ty_1>())).destroy as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_layer_surface_v1__bindgen_ty_1),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_layer_surface_v1__bindgen_ty_1>())).map as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_layer_surface_v1__bindgen_ty_1),
            "::",
            stringify!(map)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_layer_surface_v1__bindgen_ty_1>())).unmap as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_layer_surface_v1__bindgen_ty_1),
            "::",
            stringify!(unmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_layer_surface_v1__bindgen_ty_1>())).new_popup as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_layer_surface_v1__bindgen_ty_1),
            "::",
            stringify!(new_popup)
        )
    );
}
#[test]
fn bindgen_test_layout_wlr_layer_surface_v1() {
    assert_eq!(
        ::std::mem::size_of::<wlr_layer_surface_v1>(),
        344usize,
        concat!("Size of: ", stringify!(wlr_layer_surface_v1))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_layer_surface_v1>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_layer_surface_v1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_layer_surface_v1>())).link as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_layer_surface_v1),
            "::",
            stringify!(link)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_layer_surface_v1>())).surface as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_layer_surface_v1),
            "::",
            stringify!(surface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_layer_surface_v1>())).output as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_layer_surface_v1),
            "::",
            stringify!(output)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_layer_surface_v1>())).resource as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_layer_surface_v1),
            "::",
            stringify!(resource)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_layer_surface_v1>())).shell as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_layer_surface_v1),
            "::",
            stringify!(shell)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_layer_surface_v1>())).popups as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_layer_surface_v1),
            "::",
            stringify!(popups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_layer_surface_v1>())).namespace as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_layer_surface_v1),
            "::",
            stringify!(namespace)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_layer_surface_v1>())).layer as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_layer_surface_v1),
            "::",
            stringify!(layer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_layer_surface_v1>())).added as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_layer_surface_v1),
            "::",
            stringify!(added)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_layer_surface_v1>())).configured as *const _ as usize },
        77usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_layer_surface_v1),
            "::",
            stringify!(configured)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_layer_surface_v1>())).mapped as *const _ as usize },
        78usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_layer_surface_v1),
            "::",
            stringify!(mapped)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_layer_surface_v1>())).closed as *const _ as usize },
        79usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_layer_surface_v1),
            "::",
            stringify!(closed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_layer_surface_v1>())).configure_serial as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_layer_surface_v1),
            "::",
            stringify!(configure_serial)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_layer_surface_v1>())).configure_next_serial as *const _
                as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_layer_surface_v1),
            "::",
            stringify!(configure_next_serial)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_layer_surface_v1>())).configure_list as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_layer_surface_v1),
            "::",
            stringify!(configure_list)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_layer_surface_v1>())).acked_configure as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_layer_surface_v1),
            "::",
            stringify!(acked_configure)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_layer_surface_v1>())).client_pending as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_layer_surface_v1),
            "::",
            stringify!(client_pending)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_layer_surface_v1>())).server_pending as *const _ as usize
        },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_layer_surface_v1),
            "::",
            stringify!(server_pending)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_layer_surface_v1>())).current as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_layer_surface_v1),
            "::",
            stringify!(current)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_layer_surface_v1>())).surface_destroy as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_layer_surface_v1),
            "::",
            stringify!(surface_destroy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_layer_surface_v1>())).events as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_layer_surface_v1),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_layer_surface_v1>())).data as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_layer_surface_v1),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    pub fn wlr_layer_shell_v1_create(display: *mut wl_display) -> *mut wlr_layer_shell_v1;
}
extern "C" {
    pub fn wlr_layer_shell_v1_destroy(layer_shell: *mut wlr_layer_shell_v1);
}
extern "C" {
    #[doc = " Notifies the layer surface to configure itself with this width/height. The"]
    #[doc = " layer_surface will signal its map event when the surface is ready to assume"]
    #[doc = " this size."]
    pub fn wlr_layer_surface_v1_configure(
        surface: *mut wlr_layer_surface_v1,
        width: u32,
        height: u32,
    );
}
extern "C" {
    #[doc = " Unmaps this layer surface and notifies the client that it has been closed."]
    pub fn wlr_layer_surface_v1_close(surface: *mut wlr_layer_surface_v1);
}
extern "C" {
    pub fn wlr_surface_is_layer_surface(surface: *mut wlr_surface) -> bool;
}
extern "C" {
    pub fn wlr_layer_surface_v1_from_wlr_surface(
        surface: *mut wlr_surface,
    ) -> *mut wlr_layer_surface_v1;
}
extern "C" {
    pub fn wlr_layer_surface_v1_for_each_surface(
        surface: *mut wlr_layer_surface_v1,
        iterator: wlr_surface_iterator_func_t,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Find a surface within this layer-surface tree at the given surface-local"]
    #[doc = " coordinates. Returns the surface and coordinates in the leaf surface"]
    #[doc = " coordinate system or NULL if no surface is found at that location."]
    pub fn wlr_layer_surface_v1_surface_at(
        surface: *mut wlr_layer_surface_v1,
        sx: f64,
        sy: f64,
        sub_x: *mut f64,
        sub_y: *mut f64,
    ) -> *mut wlr_surface;
}
extern "C" {
    #[doc = " Writes the identity matrix into mat"]
    pub fn wlr_matrix_identity(mat: *mut f32);
}
extern "C" {
    #[doc = " mat \u{2190} a \u{d7} b"]
    pub fn wlr_matrix_multiply(mat: *mut f32, a: *const f32, b: *const f32);
}
extern "C" {
    pub fn wlr_matrix_transpose(mat: *mut f32, a: *const f32);
}
extern "C" {
    #[doc = " Writes a 2D translation matrix to mat of magnitude (x, y)"]
    pub fn wlr_matrix_translate(mat: *mut f32, x: f32, y: f32);
}
extern "C" {
    #[doc = " Writes a 2D scale matrix to mat of magnitude (x, y)"]
    pub fn wlr_matrix_scale(mat: *mut f32, x: f32, y: f32);
}
extern "C" {
    #[doc = " Writes a 2D rotation matrix to mat at an angle of rad radians"]
    pub fn wlr_matrix_rotate(mat: *mut f32, rad: f32);
}
extern "C" {
    #[doc = " Writes a transformation matrix which applies the specified"]
    #[doc = "  wl_output_transform to mat"]
    pub fn wlr_matrix_transform(mat: *mut f32, transform: wl_output_transform::Type);
}
extern "C" {
    #[doc = " Writes a 2D orthographic projection matrix to mat of (width, height) with a"]
    #[doc = "  specified wl_output_transform"]
    pub fn wlr_matrix_projection(
        mat: *mut f32,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        transform: wl_output_transform::Type,
    );
}
extern "C" {
    #[doc = " Shortcut for the various matrix operations involved in projecting the"]
    #[doc = "  specified wlr_box onto a given orthographic projection with a given"]
    #[doc = "  rotation. The result is written to mat, which can be applied to each"]
    #[doc = "  coordinate of the box to get a new coordinate from [-1,1]."]
    pub fn wlr_matrix_project_box(
        mat: *mut f32,
        box_: *const wlr_box,
        transform: wl_output_transform::Type,
        rotation: f32,
        projection: *const f32,
    );
}
#[doc = " Tracks damage for an output."]
#[doc = ""]
#[doc = " The `frame` event will be emitted when it is a good time for the compositor"]
#[doc = " to submit a new frame."]
#[doc = ""]
#[doc = " To render a new frame, compositors should call"]
#[doc = " `wlr_output_damage_attach_render`, render and call `wlr_output_commit`. No"]
#[doc = " rendering should happen outside a `frame` event handler or before"]
#[doc = " `wlr_output_damage_attach_render`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_output_damage {
    pub output: *mut wlr_output,
    pub max_rects: ::std::os::raw::c_int,
    pub current: pixman_region32_t,
    pub previous: [pixman_region32_t; 2usize],
    pub previous_idx: usize,
    pub events: wlr_output_damage__bindgen_ty_1,
    pub output_destroy: wl_listener,
    pub output_mode: wl_listener,
    pub output_transform: wl_listener,
    pub output_scale: wl_listener,
    pub output_needs_frame: wl_listener,
    pub output_frame: wl_listener,
    pub output_commit: wl_listener,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_output_damage__bindgen_ty_1 {
    pub frame: wl_signal,
    pub destroy: wl_signal,
}
#[test]
fn bindgen_test_layout_wlr_output_damage__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wlr_output_damage__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(wlr_output_damage__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_output_damage__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_output_damage__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_output_damage__bindgen_ty_1>())).frame as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output_damage__bindgen_ty_1),
            "::",
            stringify!(frame)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_output_damage__bindgen_ty_1>())).destroy as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output_damage__bindgen_ty_1),
            "::",
            stringify!(destroy)
        )
    );
}
#[test]
fn bindgen_test_layout_wlr_output_damage() {
    assert_eq!(
        ::std::mem::size_of::<wlr_output_damage>(),
        296usize,
        concat!("Size of: ", stringify!(wlr_output_damage))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_output_damage>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_output_damage))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output_damage>())).output as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output_damage),
            "::",
            stringify!(output)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output_damage>())).max_rects as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output_damage),
            "::",
            stringify!(max_rects)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output_damage>())).current as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output_damage),
            "::",
            stringify!(current)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output_damage>())).previous as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output_damage),
            "::",
            stringify!(previous)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output_damage>())).previous_idx as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output_damage),
            "::",
            stringify!(previous_idx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output_damage>())).events as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output_damage),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_output_damage>())).output_destroy as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output_damage),
            "::",
            stringify!(output_destroy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output_damage>())).output_mode as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output_damage),
            "::",
            stringify!(output_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_output_damage>())).output_transform as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output_damage),
            "::",
            stringify!(output_transform)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output_damage>())).output_scale as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output_damage),
            "::",
            stringify!(output_scale)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_output_damage>())).output_needs_frame as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output_damage),
            "::",
            stringify!(output_needs_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output_damage>())).output_frame as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output_damage),
            "::",
            stringify!(output_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_output_damage>())).output_commit as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_output_damage),
            "::",
            stringify!(output_commit)
        )
    );
}
extern "C" {
    pub fn wlr_output_damage_create(output: *mut wlr_output) -> *mut wlr_output_damage;
}
extern "C" {
    pub fn wlr_output_damage_destroy(output_damage: *mut wlr_output_damage);
}
extern "C" {
    #[doc = " Attach the renderer's buffer to the output. Compositors must call this"]
    #[doc = " function before rendering. After they are done rendering, they should call"]
    #[doc = " `wlr_output_set_damage` and `wlr_output_commit` to submit the new frame."]
    #[doc = ""]
    #[doc = " `needs_frame` will be set to true if a frame should be submitted. `damage`"]
    #[doc = " will be set to the region of the output that needs to be repainted, in"]
    #[doc = " output-buffer-local coordinates."]
    #[doc = ""]
    #[doc = " The buffer damage region accumulates all damage since the buffer has last"]
    #[doc = " been swapped. This is not to be confused with the output surface damage,"]
    #[doc = " which only contains the changes between two frames."]
    pub fn wlr_output_damage_attach_render(
        output_damage: *mut wlr_output_damage,
        needs_frame: *mut bool,
        buffer_damage: *mut pixman_region32_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Accumulates damage and schedules a `frame` event."]
    pub fn wlr_output_damage_add(
        output_damage: *mut wlr_output_damage,
        damage: *mut pixman_region32_t,
    );
}
extern "C" {
    #[doc = " Damages the whole output and schedules a `frame` event."]
    pub fn wlr_output_damage_add_whole(output_damage: *mut wlr_output_damage);
}
extern "C" {
    #[doc = " Accumulates damage from a box and schedules a `frame` event."]
    pub fn wlr_output_damage_add_box(output_damage: *mut wlr_output_damage, box_: *mut wlr_box);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_screencopy_manager_v1 {
    pub global: *mut wl_global,
    pub resources: wl_list,
    pub frames: wl_list,
    pub display_destroy: wl_listener,
    pub events: wlr_screencopy_manager_v1__bindgen_ty_1,
    pub data: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_screencopy_manager_v1__bindgen_ty_1 {
    pub destroy: wl_signal,
}
#[test]
fn bindgen_test_layout_wlr_screencopy_manager_v1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wlr_screencopy_manager_v1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(wlr_screencopy_manager_v1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_screencopy_manager_v1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(wlr_screencopy_manager_v1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_screencopy_manager_v1__bindgen_ty_1>())).destroy as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_screencopy_manager_v1__bindgen_ty_1),
            "::",
            stringify!(destroy)
        )
    );
}
#[test]
fn bindgen_test_layout_wlr_screencopy_manager_v1() {
    assert_eq!(
        ::std::mem::size_of::<wlr_screencopy_manager_v1>(),
        88usize,
        concat!("Size of: ", stringify!(wlr_screencopy_manager_v1))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_screencopy_manager_v1>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_screencopy_manager_v1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_screencopy_manager_v1>())).global as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_screencopy_manager_v1),
            "::",
            stringify!(global)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_screencopy_manager_v1>())).resources as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_screencopy_manager_v1),
            "::",
            stringify!(resources)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_screencopy_manager_v1>())).frames as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_screencopy_manager_v1),
            "::",
            stringify!(frames)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_screencopy_manager_v1>())).display_destroy as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_screencopy_manager_v1),
            "::",
            stringify!(display_destroy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_screencopy_manager_v1>())).events as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_screencopy_manager_v1),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_screencopy_manager_v1>())).data as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_screencopy_manager_v1),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_screencopy_frame_v1 {
    pub resource: *mut wl_resource,
    pub manager: *mut wlr_screencopy_manager_v1,
    pub link: wl_list,
    pub format: wl_shm_format::Type,
    pub box_: wlr_box,
    pub stride: ::std::os::raw::c_int,
    pub overlay_cursor: bool,
    pub cursor_locked: bool,
    pub buffer: *mut wl_shm_buffer,
    pub buffer_destroy: wl_listener,
    pub output: *mut wlr_output,
    pub output_precommit: wl_listener,
    pub output_destroy: wl_listener,
    pub output_enable: wl_listener,
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_wlr_screencopy_frame_v1() {
    assert_eq!(
        ::std::mem::size_of::<wlr_screencopy_frame_v1>(),
        184usize,
        concat!("Size of: ", stringify!(wlr_screencopy_frame_v1))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_screencopy_frame_v1>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_screencopy_frame_v1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_screencopy_frame_v1>())).resource as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_screencopy_frame_v1),
            "::",
            stringify!(resource)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_screencopy_frame_v1>())).manager as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_screencopy_frame_v1),
            "::",
            stringify!(manager)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_screencopy_frame_v1>())).link as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_screencopy_frame_v1),
            "::",
            stringify!(link)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_screencopy_frame_v1>())).format as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_screencopy_frame_v1),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_screencopy_frame_v1>())).box_ as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_screencopy_frame_v1),
            "::",
            stringify!(box_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_screencopy_frame_v1>())).stride as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_screencopy_frame_v1),
            "::",
            stringify!(stride)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_screencopy_frame_v1>())).overlay_cursor as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_screencopy_frame_v1),
            "::",
            stringify!(overlay_cursor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_screencopy_frame_v1>())).cursor_locked as *const _ as usize
        },
        57usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_screencopy_frame_v1),
            "::",
            stringify!(cursor_locked)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_screencopy_frame_v1>())).buffer as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_screencopy_frame_v1),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_screencopy_frame_v1>())).buffer_destroy as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_screencopy_frame_v1),
            "::",
            stringify!(buffer_destroy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_screencopy_frame_v1>())).output as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_screencopy_frame_v1),
            "::",
            stringify!(output)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_screencopy_frame_v1>())).output_precommit as *const _
                as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_screencopy_frame_v1),
            "::",
            stringify!(output_precommit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_screencopy_frame_v1>())).output_destroy as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_screencopy_frame_v1),
            "::",
            stringify!(output_destroy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_screencopy_frame_v1>())).output_enable as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_screencopy_frame_v1),
            "::",
            stringify!(output_enable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_screencopy_frame_v1>())).data as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_screencopy_frame_v1),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    pub fn wlr_screencopy_manager_v1_create(
        display: *mut wl_display,
    ) -> *mut wlr_screencopy_manager_v1;
}
extern "C" {
    pub fn wlr_screencopy_manager_v1_destroy(screencopy: *mut wlr_screencopy_manager_v1);
}
pub mod wlr_edges {
    pub type Type = u32;
    pub const WLR_EDGE_NONE: Type = 0;
    pub const WLR_EDGE_TOP: Type = 1;
    pub const WLR_EDGE_BOTTOM: Type = 2;
    pub const WLR_EDGE_LEFT: Type = 4;
    pub const WLR_EDGE_RIGHT: Type = 8;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_xcursor_image {
    pub width: u32,
    pub height: u32,
    pub hotspot_x: u32,
    pub hotspot_y: u32,
    pub delay: u32,
    pub buffer: *mut u8,
}
#[test]
fn bindgen_test_layout_wlr_xcursor_image() {
    assert_eq!(
        ::std::mem::size_of::<wlr_xcursor_image>(),
        32usize,
        concat!("Size of: ", stringify!(wlr_xcursor_image))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_xcursor_image>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_xcursor_image))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xcursor_image>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xcursor_image),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xcursor_image>())).height as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xcursor_image),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xcursor_image>())).hotspot_x as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xcursor_image),
            "::",
            stringify!(hotspot_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xcursor_image>())).hotspot_y as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xcursor_image),
            "::",
            stringify!(hotspot_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xcursor_image>())).delay as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xcursor_image),
            "::",
            stringify!(delay)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xcursor_image>())).buffer as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xcursor_image),
            "::",
            stringify!(buffer)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_xcursor {
    pub image_count: ::std::os::raw::c_uint,
    pub images: *mut *mut wlr_xcursor_image,
    pub name: *mut ::std::os::raw::c_char,
    pub total_delay: u32,
}
#[test]
fn bindgen_test_layout_wlr_xcursor() {
    assert_eq!(
        ::std::mem::size_of::<wlr_xcursor>(),
        32usize,
        concat!("Size of: ", stringify!(wlr_xcursor))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_xcursor>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_xcursor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xcursor>())).image_count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xcursor),
            "::",
            stringify!(image_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xcursor>())).images as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xcursor),
            "::",
            stringify!(images)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xcursor>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xcursor),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xcursor>())).total_delay as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xcursor),
            "::",
            stringify!(total_delay)
        )
    );
}
#[doc = " Container for an Xcursor theme."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_xcursor_theme {
    pub cursor_count: ::std::os::raw::c_uint,
    pub cursors: *mut *mut wlr_xcursor,
    pub name: *mut ::std::os::raw::c_char,
    pub size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_wlr_xcursor_theme() {
    assert_eq!(
        ::std::mem::size_of::<wlr_xcursor_theme>(),
        32usize,
        concat!("Size of: ", stringify!(wlr_xcursor_theme))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_xcursor_theme>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_xcursor_theme))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xcursor_theme>())).cursor_count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xcursor_theme),
            "::",
            stringify!(cursor_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xcursor_theme>())).cursors as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xcursor_theme),
            "::",
            stringify!(cursors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xcursor_theme>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xcursor_theme),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xcursor_theme>())).size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xcursor_theme),
            "::",
            stringify!(size)
        )
    );
}
extern "C" {
    #[doc = " Loads the named xcursor theme at the given cursor size (in pixels). This is"]
    #[doc = " useful if you need cursor images for your compositor to use when a"]
    #[doc = " client-side cursors is not available or you wish to override client-side"]
    #[doc = " cursors for a particular UI interaction (such as using a grab cursor when"]
    #[doc = " moving a window around)."]
    pub fn wlr_xcursor_theme_load(
        name: *const ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> *mut wlr_xcursor_theme;
}
extern "C" {
    pub fn wlr_xcursor_theme_destroy(theme: *mut wlr_xcursor_theme);
}
extern "C" {
    #[doc = " Obtains a wlr_xcursor image for the specified cursor name (e.g. \"left_ptr\")."]
    pub fn wlr_xcursor_theme_get_cursor(
        theme: *mut wlr_xcursor_theme,
        name: *const ::std::os::raw::c_char,
    ) -> *mut wlr_xcursor;
}
extern "C" {
    #[doc = " Returns the current frame number for an animated cursor give a monotonic time"]
    #[doc = " reference."]
    pub fn wlr_xcursor_frame(cursor: *mut wlr_xcursor, time: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the name of the resize cursor image for the given edges."]
    pub fn wlr_xcursor_get_resize_name(edges: wlr_edges::Type) -> *const ::std::os::raw::c_char;
}
#[doc = " An XCursor theme at a particular scale factor of the base size."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_xcursor_manager_theme {
    pub scale: f32,
    pub theme: *mut wlr_xcursor_theme,
    pub link: wl_list,
}
#[test]
fn bindgen_test_layout_wlr_xcursor_manager_theme() {
    assert_eq!(
        ::std::mem::size_of::<wlr_xcursor_manager_theme>(),
        32usize,
        concat!("Size of: ", stringify!(wlr_xcursor_manager_theme))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_xcursor_manager_theme>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_xcursor_manager_theme))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xcursor_manager_theme>())).scale as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xcursor_manager_theme),
            "::",
            stringify!(scale)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xcursor_manager_theme>())).theme as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xcursor_manager_theme),
            "::",
            stringify!(theme)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xcursor_manager_theme>())).link as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xcursor_manager_theme),
            "::",
            stringify!(link)
        )
    );
}
#[doc = " wlr_xcursor_manager dynamically loads xcursor themes at sizes necessary for"]
#[doc = " use on outputs at arbitrary scale factors. You should call"]
#[doc = " wlr_xcursor_manager_load for each output you will show your cursor on, with"]
#[doc = " the scale factor parameter set to that output's scale factor."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_xcursor_manager {
    pub name: *mut ::std::os::raw::c_char,
    pub size: u32,
    pub scaled_themes: wl_list,
}
#[test]
fn bindgen_test_layout_wlr_xcursor_manager() {
    assert_eq!(
        ::std::mem::size_of::<wlr_xcursor_manager>(),
        32usize,
        concat!("Size of: ", stringify!(wlr_xcursor_manager))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_xcursor_manager>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_xcursor_manager))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xcursor_manager>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xcursor_manager),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xcursor_manager>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xcursor_manager),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xcursor_manager>())).scaled_themes as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xcursor_manager),
            "::",
            stringify!(scaled_themes)
        )
    );
}
extern "C" {
    #[doc = " Creates a new XCursor manager with the given xcursor theme name and base size"]
    #[doc = " (for use when scale=1)."]
    pub fn wlr_xcursor_manager_create(
        name: *const ::std::os::raw::c_char,
        size: u32,
    ) -> *mut wlr_xcursor_manager;
}
extern "C" {
    pub fn wlr_xcursor_manager_destroy(manager: *mut wlr_xcursor_manager);
}
extern "C" {
    #[doc = " Ensures an xcursor theme at the given scale factor is loaded in the manager."]
    pub fn wlr_xcursor_manager_load(
        manager: *mut wlr_xcursor_manager,
        scale: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieves a wlr_xcursor reference for the given cursor name at the given"]
    #[doc = " scale factor, or NULL if this wlr_xcursor_manager has not loaded a cursor"]
    #[doc = " theme at the requested scale."]
    pub fn wlr_xcursor_manager_get_xcursor(
        manager: *mut wlr_xcursor_manager,
        name: *const ::std::os::raw::c_char,
        scale: f32,
    ) -> *mut wlr_xcursor;
}
extern "C" {
    #[doc = " Set a wlr_cursor's cursor image to the specified cursor name for all scale"]
    #[doc = " factors. wlr_cursor will take over from this point and ensure the correct"]
    #[doc = " cursor is used on each output, assuming a wlr_output_layout is attached to"]
    #[doc = " it."]
    pub fn wlr_xcursor_manager_set_cursor_image(
        manager: *mut wlr_xcursor_manager,
        name: *const ::std::os::raw::c_char,
        cursor: *mut wlr_cursor,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xdg_positioner {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xdg_surface {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xdg_toplevel {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xdg_wm_base {
    _unused: [u8; 0],
}
extern "C" {
    pub static xdg_wm_base_interface: wl_interface;
}
extern "C" {
    pub static xdg_positioner_interface: wl_interface;
}
extern "C" {
    pub static xdg_surface_interface: wl_interface;
}
extern "C" {
    pub static xdg_toplevel_interface: wl_interface;
}
extern "C" {
    pub static xdg_popup_interface: wl_interface;
}
pub mod xdg_wm_base_error {
    pub type Type = u32;
    #[doc = " given wl_surface has another role"]
    pub const XDG_WM_BASE_ERROR_ROLE: Type = 0;
    #[doc = " xdg_wm_base was destroyed before children"]
    pub const XDG_WM_BASE_ERROR_DEFUNCT_SURFACES: Type = 1;
    #[doc = " the client tried to map or destroy a non-topmost popup"]
    pub const XDG_WM_BASE_ERROR_NOT_THE_TOPMOST_POPUP: Type = 2;
    #[doc = " the client specified an invalid popup parent surface"]
    pub const XDG_WM_BASE_ERROR_INVALID_POPUP_PARENT: Type = 3;
    #[doc = " the client provided an invalid surface state"]
    pub const XDG_WM_BASE_ERROR_INVALID_SURFACE_STATE: Type = 4;
    #[doc = " the client provided an invalid positioner"]
    pub const XDG_WM_BASE_ERROR_INVALID_POSITIONER: Type = 5;
}
#[doc = " @ingroup iface_xdg_wm_base"]
#[doc = " @struct xdg_wm_base_interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xdg_wm_base_interface {
    #[doc = " destroy xdg_wm_base"]
    #[doc = ""]
    #[doc = " Destroy this xdg_wm_base object."]
    #[doc = ""]
    #[doc = " Destroying a bound xdg_wm_base object while there are surfaces"]
    #[doc = " still alive created by this xdg_wm_base object instance is"]
    #[doc = " illegal and will result in a protocol error."]
    pub destroy: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
    #[doc = " create a positioner object"]
    #[doc = ""]
    #[doc = " Create a positioner object. A positioner object is used to"]
    #[doc = " position surfaces relative to some parent surface. See the"]
    #[doc = " interface description and xdg_surface.get_popup for details."]
    pub create_positioner: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource, id: u32),
    >,
    #[doc = " create a shell surface from a surface"]
    #[doc = ""]
    #[doc = " This creates an xdg_surface for the given surface. While"]
    #[doc = " xdg_surface itself is not a role, the corresponding surface may"]
    #[doc = " only be assigned a role extending xdg_surface, such as"]
    #[doc = " xdg_toplevel or xdg_popup."]
    #[doc = ""]
    #[doc = " This creates an xdg_surface for the given surface. An"]
    #[doc = " xdg_surface is used as basis to define a role to a given"]
    #[doc = " surface, such as xdg_toplevel or xdg_popup. It also manages"]
    #[doc = " functionality shared between xdg_surface based surface roles."]
    #[doc = ""]
    #[doc = " See the documentation of xdg_surface for more details about what"]
    #[doc = " an xdg_surface is and how it is used."]
    pub get_xdg_surface: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            id: u32,
            surface: *mut wl_resource,
        ),
    >,
    #[doc = " respond to a ping event"]
    #[doc = ""]
    #[doc = " A client must respond to a ping event with a pong request or"]
    #[doc = " the client may be deemed unresponsive. See xdg_wm_base.ping."]
    #[doc = " @param serial serial of the ping event"]
    pub pong: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource, serial: u32),
    >,
}
#[test]
fn bindgen_test_layout_xdg_wm_base_interface() {
    assert_eq!(
        ::std::mem::size_of::<xdg_wm_base_interface>(),
        32usize,
        concat!("Size of: ", stringify!(xdg_wm_base_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<xdg_wm_base_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(xdg_wm_base_interface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xdg_wm_base_interface>())).destroy as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xdg_wm_base_interface),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xdg_wm_base_interface>())).create_positioner as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xdg_wm_base_interface),
            "::",
            stringify!(create_positioner)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xdg_wm_base_interface>())).get_xdg_surface as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xdg_wm_base_interface),
            "::",
            stringify!(get_xdg_surface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xdg_wm_base_interface>())).pong as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xdg_wm_base_interface),
            "::",
            stringify!(pong)
        )
    );
}
pub mod xdg_positioner_error {
    pub type Type = u32;
    #[doc = " invalid input provided"]
    pub const XDG_POSITIONER_ERROR_INVALID_INPUT: Type = 0;
}
pub mod xdg_positioner_anchor {
    pub type Type = u32;
    pub const XDG_POSITIONER_ANCHOR_NONE: Type = 0;
    pub const XDG_POSITIONER_ANCHOR_TOP: Type = 1;
    pub const XDG_POSITIONER_ANCHOR_BOTTOM: Type = 2;
    pub const XDG_POSITIONER_ANCHOR_LEFT: Type = 3;
    pub const XDG_POSITIONER_ANCHOR_RIGHT: Type = 4;
    pub const XDG_POSITIONER_ANCHOR_TOP_LEFT: Type = 5;
    pub const XDG_POSITIONER_ANCHOR_BOTTOM_LEFT: Type = 6;
    pub const XDG_POSITIONER_ANCHOR_TOP_RIGHT: Type = 7;
    pub const XDG_POSITIONER_ANCHOR_BOTTOM_RIGHT: Type = 8;
}
pub mod xdg_positioner_gravity {
    pub type Type = u32;
    pub const XDG_POSITIONER_GRAVITY_NONE: Type = 0;
    pub const XDG_POSITIONER_GRAVITY_TOP: Type = 1;
    pub const XDG_POSITIONER_GRAVITY_BOTTOM: Type = 2;
    pub const XDG_POSITIONER_GRAVITY_LEFT: Type = 3;
    pub const XDG_POSITIONER_GRAVITY_RIGHT: Type = 4;
    pub const XDG_POSITIONER_GRAVITY_TOP_LEFT: Type = 5;
    pub const XDG_POSITIONER_GRAVITY_BOTTOM_LEFT: Type = 6;
    pub const XDG_POSITIONER_GRAVITY_TOP_RIGHT: Type = 7;
    pub const XDG_POSITIONER_GRAVITY_BOTTOM_RIGHT: Type = 8;
}
pub mod xdg_positioner_constraint_adjustment {
    #[doc = " @ingroup iface_xdg_positioner"]
    #[doc = " vertically resize the surface"]
    #[doc = ""]
    #[doc = " Resize the surface vertically so that it is completely unconstrained."]
    pub type Type = u32;
    pub const XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_NONE: Type = 0;
    pub const XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_SLIDE_X: Type = 1;
    pub const XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_SLIDE_Y: Type = 2;
    pub const XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_FLIP_X: Type = 4;
    pub const XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_FLIP_Y: Type = 8;
    pub const XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_RESIZE_X: Type = 16;
    pub const XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_RESIZE_Y: Type = 32;
}
#[doc = " @ingroup iface_xdg_positioner"]
#[doc = " @struct xdg_positioner_interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xdg_positioner_interface {
    #[doc = " destroy the xdg_positioner object"]
    #[doc = ""]
    #[doc = " Notify the compositor that the xdg_positioner will no longer"]
    #[doc = " be used."]
    pub destroy: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
    #[doc = " set the size of the to-be positioned rectangle"]
    #[doc = ""]
    #[doc = " Set the size of the surface that is to be positioned with the"]
    #[doc = " positioner object. The size is in surface-local coordinates and"]
    #[doc = " corresponds to the window geometry. See"]
    #[doc = " xdg_surface.set_window_geometry."]
    #[doc = ""]
    #[doc = " If a zero or negative size is set the invalid_input error is"]
    #[doc = " raised."]
    #[doc = " @param width width of positioned rectangle"]
    #[doc = " @param height height of positioned rectangle"]
    pub set_size: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            width: i32,
            height: i32,
        ),
    >,
    #[doc = " set the anchor rectangle within the parent surface"]
    #[doc = ""]
    #[doc = " Specify the anchor rectangle within the parent surface that"]
    #[doc = " the child surface will be placed relative to. The rectangle is"]
    #[doc = " relative to the window geometry as defined by"]
    #[doc = " xdg_surface.set_window_geometry of the parent surface."]
    #[doc = ""]
    #[doc = " When the xdg_positioner object is used to position a child"]
    #[doc = " surface, the anchor rectangle may not extend outside the window"]
    #[doc = " geometry of the positioned child's parent surface."]
    #[doc = ""]
    #[doc = " If a negative size is set the invalid_input error is raised."]
    #[doc = " @param x x position of anchor rectangle"]
    #[doc = " @param y y position of anchor rectangle"]
    #[doc = " @param width width of anchor rectangle"]
    #[doc = " @param height height of anchor rectangle"]
    pub set_anchor_rect: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            x: i32,
            y: i32,
            width: i32,
            height: i32,
        ),
    >,
    #[doc = " set anchor rectangle anchor"]
    #[doc = ""]
    #[doc = " Defines the anchor point for the anchor rectangle. The"]
    #[doc = " specified anchor is used derive an anchor point that the child"]
    #[doc = " surface will be positioned relative to. If a corner anchor is"]
    #[doc = " set (e.g. 'top_left' or 'bottom_right'), the anchor point will"]
    #[doc = " be at the specified corner; otherwise, the derived anchor point"]
    #[doc = " will be centered on the specified edge, or in the center of the"]
    #[doc = " anchor rectangle if no edge is specified."]
    #[doc = " @param anchor anchor"]
    pub set_anchor: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource, anchor: u32),
    >,
    #[doc = " set child surface gravity"]
    #[doc = ""]
    #[doc = " Defines in what direction a surface should be positioned,"]
    #[doc = " relative to the anchor point of the parent surface. If a corner"]
    #[doc = " gravity is specified (e.g. 'bottom_right' or 'top_left'), then"]
    #[doc = " the child surface will be placed towards the specified gravity;"]
    #[doc = " otherwise, the child surface will be centered over the anchor"]
    #[doc = " point on any axis that had no gravity specified."]
    #[doc = " @param gravity gravity direction"]
    pub set_gravity: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource, gravity: u32),
    >,
    #[doc = " set the adjustment to be done when constrained"]
    #[doc = ""]
    #[doc = " Specify how the window should be positioned if the originally"]
    #[doc = " intended position caused the surface to be constrained, meaning"]
    #[doc = " at least partially outside positioning boundaries set by the"]
    #[doc = " compositor. The adjustment is set by constructing a bitmask"]
    #[doc = " describing the adjustment to be made when the surface is"]
    #[doc = " constrained on that axis."]
    #[doc = ""]
    #[doc = " If no bit for one axis is set, the compositor will assume that"]
    #[doc = " the child surface should not change its position on that axis"]
    #[doc = " when constrained."]
    #[doc = ""]
    #[doc = " If more than one bit for one axis is set, the order of how"]
    #[doc = " adjustments are applied is specified in the corresponding"]
    #[doc = " adjustment descriptions."]
    #[doc = ""]
    #[doc = " The default adjustment is none."]
    #[doc = " @param constraint_adjustment bit mask of constraint adjustments"]
    pub set_constraint_adjustment: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            constraint_adjustment: u32,
        ),
    >,
    #[doc = " set surface position offset"]
    #[doc = ""]
    #[doc = " Specify the surface position offset relative to the position"]
    #[doc = " of the anchor on the anchor rectangle and the anchor on the"]
    #[doc = " surface. For example if the anchor of the anchor rectangle is at"]
    #[doc = " (x, y), the surface has the gravity bottom|right, and the offset"]
    #[doc = " is (ox, oy), the calculated surface position will be (x + ox, y"]
    #[doc = " + oy). The offset position of the surface is the one used for"]
    #[doc = " constraint testing. See set_constraint_adjustment."]
    #[doc = ""]
    #[doc = " An example use case is placing a popup menu on top of a user"]
    #[doc = " interface element, while aligning the user interface element of"]
    #[doc = " the parent surface with some user interface element placed"]
    #[doc = " somewhere in the popup surface."]
    #[doc = " @param x surface position x offset"]
    #[doc = " @param y surface position y offset"]
    pub set_offset: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource, x: i32, y: i32),
    >,
}
#[test]
fn bindgen_test_layout_xdg_positioner_interface() {
    assert_eq!(
        ::std::mem::size_of::<xdg_positioner_interface>(),
        56usize,
        concat!("Size of: ", stringify!(xdg_positioner_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<xdg_positioner_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(xdg_positioner_interface))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xdg_positioner_interface>())).destroy as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xdg_positioner_interface),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xdg_positioner_interface>())).set_size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xdg_positioner_interface),
            "::",
            stringify!(set_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xdg_positioner_interface>())).set_anchor_rect as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xdg_positioner_interface),
            "::",
            stringify!(set_anchor_rect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xdg_positioner_interface>())).set_anchor as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xdg_positioner_interface),
            "::",
            stringify!(set_anchor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xdg_positioner_interface>())).set_gravity as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(xdg_positioner_interface),
            "::",
            stringify!(set_gravity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xdg_positioner_interface>())).set_constraint_adjustment
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(xdg_positioner_interface),
            "::",
            stringify!(set_constraint_adjustment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xdg_positioner_interface>())).set_offset as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(xdg_positioner_interface),
            "::",
            stringify!(set_offset)
        )
    );
}
pub mod xdg_surface_error {
    pub type Type = u32;
    pub const XDG_SURFACE_ERROR_NOT_CONSTRUCTED: Type = 1;
    pub const XDG_SURFACE_ERROR_ALREADY_CONSTRUCTED: Type = 2;
    pub const XDG_SURFACE_ERROR_UNCONFIGURED_BUFFER: Type = 3;
}
#[doc = " @ingroup iface_xdg_surface"]
#[doc = " @struct xdg_surface_interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xdg_surface_interface {
    #[doc = " destroy the xdg_surface"]
    #[doc = ""]
    #[doc = " Destroy the xdg_surface object. An xdg_surface must only be"]
    #[doc = " destroyed after its role object has been destroyed."]
    pub destroy: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
    #[doc = " assign the xdg_toplevel surface role"]
    #[doc = ""]
    #[doc = " This creates an xdg_toplevel object for the given xdg_surface"]
    #[doc = " and gives the associated wl_surface the xdg_toplevel role."]
    #[doc = ""]
    #[doc = " See the documentation of xdg_toplevel for more details about"]
    #[doc = " what an xdg_toplevel is and how it is used."]
    pub get_toplevel: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource, id: u32),
    >,
    #[doc = " assign the xdg_popup surface role"]
    #[doc = ""]
    #[doc = " This creates an xdg_popup object for the given xdg_surface and"]
    #[doc = " gives the associated wl_surface the xdg_popup role."]
    #[doc = ""]
    #[doc = " If null is passed as a parent, a parent surface must be"]
    #[doc = " specified using some other protocol, before committing the"]
    #[doc = " initial state."]
    #[doc = ""]
    #[doc = " See the documentation of xdg_popup for more details about what"]
    #[doc = " an xdg_popup is and how it is used."]
    pub get_popup: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            id: u32,
            parent: *mut wl_resource,
            positioner: *mut wl_resource,
        ),
    >,
    #[doc = " set the new window geometry"]
    #[doc = ""]
    #[doc = " The window geometry of a surface is its \"visible bounds\" from"]
    #[doc = " the user's perspective. Client-side decorations often have"]
    #[doc = " invisible portions like drop-shadows which should be ignored for"]
    #[doc = " the purposes of aligning, placing and constraining windows."]
    #[doc = ""]
    #[doc = " The window geometry is double buffered, and will be applied at"]
    #[doc = " the time wl_surface.commit of the corresponding wl_surface is"]
    #[doc = " called."]
    #[doc = ""]
    #[doc = " When maintaining a position, the compositor should treat the (x,"]
    #[doc = " y) coordinate of the window geometry as the top left corner of"]
    #[doc = " the window. A client changing the (x, y) window geometry"]
    #[doc = " coordinate should in general not alter the position of the"]
    #[doc = " window."]
    #[doc = ""]
    #[doc = " Once the window geometry of the surface is set, it is not"]
    #[doc = " possible to unset it, and it will remain the same until"]
    #[doc = " set_window_geometry is called again, even if a new subsurface or"]
    #[doc = " buffer is attached."]
    #[doc = ""]
    #[doc = " If never set, the value is the full bounds of the surface,"]
    #[doc = " including any subsurfaces. This updates dynamically on every"]
    #[doc = " commit. This unset is meant for extremely simple clients."]
    #[doc = ""]
    #[doc = " The arguments are given in the surface-local coordinate space of"]
    #[doc = " the wl_surface associated with this xdg_surface."]
    #[doc = ""]
    #[doc = " The width and height must be greater than zero. Setting an"]
    #[doc = " invalid size will raise an error. When applied, the effective"]
    #[doc = " window geometry will be the set window geometry clamped to the"]
    #[doc = " bounding rectangle of the combined geometry of the surface of"]
    #[doc = " the xdg_surface and the associated subsurfaces."]
    pub set_window_geometry: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            x: i32,
            y: i32,
            width: i32,
            height: i32,
        ),
    >,
    #[doc = " ack a configure event"]
    #[doc = ""]
    #[doc = " When a configure event is received, if a client commits the"]
    #[doc = " surface in response to the configure event, then the client must"]
    #[doc = " make an ack_configure request sometime before the commit"]
    #[doc = " request, passing along the serial of the configure event."]
    #[doc = ""]
    #[doc = " For instance, for toplevel surfaces the compositor might use"]
    #[doc = " this information to move a surface to the top left only when the"]
    #[doc = " client has drawn itself for the maximized or fullscreen state."]
    #[doc = ""]
    #[doc = " If the client receives multiple configure events before it can"]
    #[doc = " respond to one, it only has to ack the last configure event."]
    #[doc = ""]
    #[doc = " A client is not required to commit immediately after sending an"]
    #[doc = " ack_configure request - it may even ack_configure several times"]
    #[doc = " before its next surface commit."]
    #[doc = ""]
    #[doc = " A client may send multiple ack_configure requests before"]
    #[doc = " committing, but only the last request sent before a commit"]
    #[doc = " indicates which configure event the client really is responding"]
    #[doc = " to."]
    #[doc = " @param serial the serial from the configure event"]
    pub ack_configure: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource, serial: u32),
    >,
}
#[test]
fn bindgen_test_layout_xdg_surface_interface() {
    assert_eq!(
        ::std::mem::size_of::<xdg_surface_interface>(),
        40usize,
        concat!("Size of: ", stringify!(xdg_surface_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<xdg_surface_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(xdg_surface_interface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xdg_surface_interface>())).destroy as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xdg_surface_interface),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xdg_surface_interface>())).get_toplevel as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xdg_surface_interface),
            "::",
            stringify!(get_toplevel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xdg_surface_interface>())).get_popup as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xdg_surface_interface),
            "::",
            stringify!(get_popup)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xdg_surface_interface>())).set_window_geometry as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xdg_surface_interface),
            "::",
            stringify!(set_window_geometry)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xdg_surface_interface>())).ack_configure as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(xdg_surface_interface),
            "::",
            stringify!(ack_configure)
        )
    );
}
pub mod xdg_toplevel_resize_edge {
    #[doc = " @ingroup iface_xdg_toplevel"]
    #[doc = " edge values for resizing"]
    #[doc = ""]
    #[doc = " These values are used to indicate which edge of a surface"]
    #[doc = " is being dragged in a resize operation."]
    pub type Type = u32;
    pub const XDG_TOPLEVEL_RESIZE_EDGE_NONE: Type = 0;
    pub const XDG_TOPLEVEL_RESIZE_EDGE_TOP: Type = 1;
    pub const XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM: Type = 2;
    pub const XDG_TOPLEVEL_RESIZE_EDGE_LEFT: Type = 4;
    pub const XDG_TOPLEVEL_RESIZE_EDGE_TOP_LEFT: Type = 5;
    pub const XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM_LEFT: Type = 6;
    pub const XDG_TOPLEVEL_RESIZE_EDGE_RIGHT: Type = 8;
    pub const XDG_TOPLEVEL_RESIZE_EDGE_TOP_RIGHT: Type = 9;
    pub const XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM_RIGHT: Type = 10;
}
pub mod xdg_toplevel_state {
    #[doc = " @ingroup iface_xdg_toplevel"]
    #[doc = " the surface is tiled"]
    #[doc = ""]
    #[doc = " The window is currently in a tiled layout and the bottom edge is"]
    #[doc = " considered to be adjacent to another part of the tiling grid."]
    pub type Type = u32;
    #[doc = " the surface is maximized"]
    pub const XDG_TOPLEVEL_STATE_MAXIMIZED: Type = 1;
    #[doc = " the surface is fullscreen"]
    pub const XDG_TOPLEVEL_STATE_FULLSCREEN: Type = 2;
    #[doc = " the surface is being resized"]
    pub const XDG_TOPLEVEL_STATE_RESIZING: Type = 3;
    #[doc = " the surface is now activated"]
    pub const XDG_TOPLEVEL_STATE_ACTIVATED: Type = 4;
    #[doc = " @since 2"]
    pub const XDG_TOPLEVEL_STATE_TILED_LEFT: Type = 5;
    #[doc = " @since 2"]
    pub const XDG_TOPLEVEL_STATE_TILED_RIGHT: Type = 6;
    #[doc = " @since 2"]
    pub const XDG_TOPLEVEL_STATE_TILED_TOP: Type = 7;
    #[doc = " @since 2"]
    pub const XDG_TOPLEVEL_STATE_TILED_BOTTOM: Type = 8;
}
#[doc = " @ingroup iface_xdg_toplevel"]
#[doc = " @struct xdg_toplevel_interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xdg_toplevel_interface {
    #[doc = " destroy the xdg_toplevel"]
    #[doc = ""]
    #[doc = " This request destroys the role surface and unmaps the surface;"]
    #[doc = " see \"Unmapping\" behavior in interface section for details."]
    pub destroy: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
    #[doc = " set the parent of this surface"]
    #[doc = ""]
    #[doc = " Set the \"parent\" of this surface. This surface should be"]
    #[doc = " stacked above the parent surface and all other ancestor"]
    #[doc = " surfaces."]
    #[doc = ""]
    #[doc = " Parent windows should be set on dialogs, toolboxes, or other"]
    #[doc = " \"auxiliary\" surfaces, so that the parent is raised when the"]
    #[doc = " dialog is raised."]
    #[doc = ""]
    #[doc = " Setting a null parent for a child window removes any"]
    #[doc = " parent-child relationship for the child. Setting a null parent"]
    #[doc = " for a window which currently has no parent is a no-op."]
    #[doc = ""]
    #[doc = " If the parent is unmapped then its children are managed as"]
    #[doc = " though the parent of the now-unmapped parent has become the"]
    #[doc = " parent of this surface. If no parent exists for the now-unmapped"]
    #[doc = " parent then the children are managed as though they have no"]
    #[doc = " parent surface."]
    pub set_parent: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            parent: *mut wl_resource,
        ),
    >,
    #[doc = " set surface title"]
    #[doc = ""]
    #[doc = " Set a short title for the surface."]
    #[doc = ""]
    #[doc = " This string may be used to identify the surface in a task bar,"]
    #[doc = " window list, or other user interface elements provided by the"]
    #[doc = " compositor."]
    #[doc = ""]
    #[doc = " The string must be encoded in UTF-8."]
    pub set_title: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            title: *const ::std::os::raw::c_char,
        ),
    >,
    #[doc = " set application ID"]
    #[doc = ""]
    #[doc = " Set an application identifier for the surface."]
    #[doc = ""]
    #[doc = " The app ID identifies the general class of applications to which"]
    #[doc = " the surface belongs. The compositor can use this to group"]
    #[doc = " multiple surfaces together, or to determine how to launch a new"]
    #[doc = " application."]
    #[doc = ""]
    #[doc = " For D-Bus activatable applications, the app ID is used as the"]
    #[doc = " D-Bus service name."]
    #[doc = ""]
    #[doc = " The compositor shell will try to group application surfaces"]
    #[doc = " together by their app ID. As a best practice, it is suggested to"]
    #[doc = " select app ID's that match the basename of the application's"]
    #[doc = " .desktop file. For example, \"org.freedesktop.FooViewer\" where"]
    #[doc = " the .desktop file is \"org.freedesktop.FooViewer.desktop\"."]
    #[doc = ""]
    #[doc = " See the desktop-entry specification [0] for more details on"]
    #[doc = " application identifiers and how they relate to well-known D-Bus"]
    #[doc = " names and .desktop files."]
    #[doc = ""]
    #[doc = " [0] http://standards.freedesktop.org/desktop-entry-spec/"]
    pub set_app_id: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            app_id: *const ::std::os::raw::c_char,
        ),
    >,
    #[doc = " show the window menu"]
    #[doc = ""]
    #[doc = " Clients implementing client-side decorations might want to"]
    #[doc = " show a context menu when right-clicking on the decorations,"]
    #[doc = " giving the user a menu that they can use to maximize or minimize"]
    #[doc = " the window."]
    #[doc = ""]
    #[doc = " This request asks the compositor to pop up such a window menu at"]
    #[doc = " the given position, relative to the local surface coordinates of"]
    #[doc = " the parent surface. There are no guarantees as to what menu"]
    #[doc = " items the window menu contains."]
    #[doc = ""]
    #[doc = " This request must be used in response to some sort of user"]
    #[doc = " action like a button press, key press, or touch down event."]
    #[doc = " @param seat the wl_seat of the user event"]
    #[doc = " @param serial the serial of the user event"]
    #[doc = " @param x the x position to pop up the window menu at"]
    #[doc = " @param y the y position to pop up the window menu at"]
    pub show_window_menu: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            seat: *mut wl_resource,
            serial: u32,
            x: i32,
            y: i32,
        ),
    >,
    #[doc = " start an interactive move"]
    #[doc = ""]
    #[doc = " Start an interactive, user-driven move of the surface."]
    #[doc = ""]
    #[doc = " This request must be used in response to some sort of user"]
    #[doc = " action like a button press, key press, or touch down event. The"]
    #[doc = " passed serial is used to determine the type of interactive move"]
    #[doc = " (touch, pointer, etc)."]
    #[doc = ""]
    #[doc = " The server may ignore move requests depending on the state of"]
    #[doc = " the surface (e.g. fullscreen or maximized), or if the passed"]
    #[doc = " serial is no longer valid."]
    #[doc = ""]
    #[doc = " If triggered, the surface will lose the focus of the device"]
    #[doc = " (wl_pointer, wl_touch, etc) used for the move. It is up to the"]
    #[doc = " compositor to visually indicate that the move is taking place,"]
    #[doc = " such as updating a pointer cursor, during the move. There is no"]
    #[doc = " guarantee that the device focus will return when the move is"]
    #[doc = " completed."]
    #[doc = " @param seat the wl_seat of the user event"]
    #[doc = " @param serial the serial of the user event"]
    pub move_: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            seat: *mut wl_resource,
            serial: u32,
        ),
    >,
    #[doc = " start an interactive resize"]
    #[doc = ""]
    #[doc = " Start a user-driven, interactive resize of the surface."]
    #[doc = ""]
    #[doc = " This request must be used in response to some sort of user"]
    #[doc = " action like a button press, key press, or touch down event. The"]
    #[doc = " passed serial is used to determine the type of interactive"]
    #[doc = " resize (touch, pointer, etc)."]
    #[doc = ""]
    #[doc = " The server may ignore resize requests depending on the state of"]
    #[doc = " the surface (e.g. fullscreen or maximized)."]
    #[doc = ""]
    #[doc = " If triggered, the client will receive configure events with the"]
    #[doc = " \"resize\" state enum value and the expected sizes. See the"]
    #[doc = " \"resize\" enum value for more details about what is required. The"]
    #[doc = " client must also acknowledge configure events using"]
    #[doc = " \"ack_configure\". After the resize is completed, the client will"]
    #[doc = " receive another \"configure\" event without the resize state."]
    #[doc = ""]
    #[doc = " If triggered, the surface also will lose the focus of the device"]
    #[doc = " (wl_pointer, wl_touch, etc) used for the resize. It is up to the"]
    #[doc = " compositor to visually indicate that the resize is taking place,"]
    #[doc = " such as updating a pointer cursor, during the resize. There is"]
    #[doc = " no guarantee that the device focus will return when the resize"]
    #[doc = " is completed."]
    #[doc = ""]
    #[doc = " The edges parameter specifies how the surface should be resized,"]
    #[doc = " and is one of the values of the resize_edge enum. The compositor"]
    #[doc = " may use this information to update the surface position for"]
    #[doc = " example when dragging the top left corner. The compositor may"]
    #[doc = " also use this information to adapt its behavior, e.g. choose an"]
    #[doc = " appropriate cursor image."]
    #[doc = " @param seat the wl_seat of the user event"]
    #[doc = " @param serial the serial of the user event"]
    #[doc = " @param edges which edge or corner is being dragged"]
    pub resize: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            seat: *mut wl_resource,
            serial: u32,
            edges: u32,
        ),
    >,
    #[doc = " set the maximum size"]
    #[doc = ""]
    #[doc = " Set a maximum size for the window."]
    #[doc = ""]
    #[doc = " The client can specify a maximum size so that the compositor"]
    #[doc = " does not try to configure the window beyond this size."]
    #[doc = ""]
    #[doc = " The width and height arguments are in window geometry"]
    #[doc = " coordinates. See xdg_surface.set_window_geometry."]
    #[doc = ""]
    #[doc = " Values set in this way are double-buffered. They will get"]
    #[doc = " applied on the next commit."]
    #[doc = ""]
    #[doc = " The compositor can use this information to allow or disallow"]
    #[doc = " different states like maximize or fullscreen and draw accurate"]
    #[doc = " animations."]
    #[doc = ""]
    #[doc = " Similarly, a tiling window manager may use this information to"]
    #[doc = " place and resize client windows in a more effective way."]
    #[doc = ""]
    #[doc = " The client should not rely on the compositor to obey the maximum"]
    #[doc = " size. The compositor may decide to ignore the values set by the"]
    #[doc = " client and request a larger size."]
    #[doc = ""]
    #[doc = " If never set, or a value of zero in the request, means that the"]
    #[doc = " client has no expected maximum size in the given dimension. As a"]
    #[doc = " result, a client wishing to reset the maximum size to an"]
    #[doc = " unspecified state can use zero for width and height in the"]
    #[doc = " request."]
    #[doc = ""]
    #[doc = " Requesting a maximum size to be smaller than the minimum size of"]
    #[doc = " a surface is illegal and will result in a protocol error."]
    #[doc = ""]
    #[doc = " The width and height must be greater than or equal to zero."]
    #[doc = " Using strictly negative values for width and height will result"]
    #[doc = " in a protocol error."]
    pub set_max_size: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            width: i32,
            height: i32,
        ),
    >,
    #[doc = " set the minimum size"]
    #[doc = ""]
    #[doc = " Set a minimum size for the window."]
    #[doc = ""]
    #[doc = " The client can specify a minimum size so that the compositor"]
    #[doc = " does not try to configure the window below this size."]
    #[doc = ""]
    #[doc = " The width and height arguments are in window geometry"]
    #[doc = " coordinates. See xdg_surface.set_window_geometry."]
    #[doc = ""]
    #[doc = " Values set in this way are double-buffered. They will get"]
    #[doc = " applied on the next commit."]
    #[doc = ""]
    #[doc = " The compositor can use this information to allow or disallow"]
    #[doc = " different states like maximize or fullscreen and draw accurate"]
    #[doc = " animations."]
    #[doc = ""]
    #[doc = " Similarly, a tiling window manager may use this information to"]
    #[doc = " place and resize client windows in a more effective way."]
    #[doc = ""]
    #[doc = " The client should not rely on the compositor to obey the minimum"]
    #[doc = " size. The compositor may decide to ignore the values set by the"]
    #[doc = " client and request a smaller size."]
    #[doc = ""]
    #[doc = " If never set, or a value of zero in the request, means that the"]
    #[doc = " client has no expected minimum size in the given dimension. As a"]
    #[doc = " result, a client wishing to reset the minimum size to an"]
    #[doc = " unspecified state can use zero for width and height in the"]
    #[doc = " request."]
    #[doc = ""]
    #[doc = " Requesting a minimum size to be larger than the maximum size of"]
    #[doc = " a surface is illegal and will result in a protocol error."]
    #[doc = ""]
    #[doc = " The width and height must be greater than or equal to zero."]
    #[doc = " Using strictly negative values for width and height will result"]
    #[doc = " in a protocol error."]
    pub set_min_size: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            width: i32,
            height: i32,
        ),
    >,
    #[doc = " maximize the window"]
    #[doc = ""]
    #[doc = " Maximize the surface."]
    #[doc = ""]
    #[doc = " After requesting that the surface should be maximized, the"]
    #[doc = " compositor will respond by emitting a configure event. Whether"]
    #[doc = " this configure actually sets the window maximized is subject to"]
    #[doc = " compositor policies. The client must then update its content,"]
    #[doc = " drawing in the configured state. The client must also"]
    #[doc = " acknowledge the configure when committing the new content (see"]
    #[doc = " ack_configure)."]
    #[doc = ""]
    #[doc = " It is up to the compositor to decide how and where to maximize"]
    #[doc = " the surface, for example which output and what region of the"]
    #[doc = " screen should be used."]
    #[doc = ""]
    #[doc = " If the surface was already maximized, the compositor will still"]
    #[doc = " emit a configure event with the \"maximized\" state."]
    #[doc = ""]
    #[doc = " If the surface is in a fullscreen state, this request has no"]
    #[doc = " direct effect. It may alter the state the surface is returned to"]
    #[doc = " when unmaximized unless overridden by the compositor."]
    pub set_maximized: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
    #[doc = " unmaximize the window"]
    #[doc = ""]
    #[doc = " Unmaximize the surface."]
    #[doc = ""]
    #[doc = " After requesting that the surface should be unmaximized, the"]
    #[doc = " compositor will respond by emitting a configure event. Whether"]
    #[doc = " this actually un-maximizes the window is subject to compositor"]
    #[doc = " policies. If available and applicable, the compositor will"]
    #[doc = " include the window geometry dimensions the window had prior to"]
    #[doc = " being maximized in the configure event. The client must then"]
    #[doc = " update its content, drawing it in the configured state. The"]
    #[doc = " client must also acknowledge the configure when committing the"]
    #[doc = " new content (see ack_configure)."]
    #[doc = ""]
    #[doc = " It is up to the compositor to position the surface after it was"]
    #[doc = " unmaximized; usually the position the surface had before"]
    #[doc = " maximizing, if applicable."]
    #[doc = ""]
    #[doc = " If the surface was already not maximized, the compositor will"]
    #[doc = " still emit a configure event without the \"maximized\" state."]
    #[doc = ""]
    #[doc = " If the surface is in a fullscreen state, this request has no"]
    #[doc = " direct effect. It may alter the state the surface is returned to"]
    #[doc = " when unmaximized unless overridden by the compositor."]
    pub unset_maximized: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
    #[doc = " set the window as fullscreen on an output"]
    #[doc = ""]
    #[doc = " Make the surface fullscreen."]
    #[doc = ""]
    #[doc = " After requesting that the surface should be fullscreened, the"]
    #[doc = " compositor will respond by emitting a configure event. Whether"]
    #[doc = " the client is actually put into a fullscreen state is subject to"]
    #[doc = " compositor policies. The client must also acknowledge the"]
    #[doc = " configure when committing the new content (see ack_configure)."]
    #[doc = ""]
    #[doc = " The output passed by the request indicates the client's"]
    #[doc = " preference as to which display it should be set fullscreen on."]
    #[doc = " If this value is NULL, it's up to the compositor to choose which"]
    #[doc = " display will be used to map this surface."]
    #[doc = ""]
    #[doc = " If the surface doesn't cover the whole output, the compositor"]
    #[doc = " will position the surface in the center of the output and"]
    #[doc = " compensate with with border fill covering the rest of the"]
    #[doc = " output. The content of the border fill is undefined, but should"]
    #[doc = " be assumed to be in some way that attempts to blend into the"]
    #[doc = " surrounding area (e.g. solid black)."]
    #[doc = ""]
    #[doc = " If the fullscreened surface is not opaque, the compositor must"]
    #[doc = " make sure that other screen content not part of the same surface"]
    #[doc = " tree (made up of subsurfaces, popups or similarly coupled"]
    #[doc = " surfaces) are not visible below the fullscreened surface."]
    pub set_fullscreen: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            output: *mut wl_resource,
        ),
    >,
    #[doc = " unset the window as fullscreen"]
    #[doc = ""]
    #[doc = " Make the surface no longer fullscreen."]
    #[doc = ""]
    #[doc = " After requesting that the surface should be unfullscreened, the"]
    #[doc = " compositor will respond by emitting a configure event. Whether"]
    #[doc = " this actually removes the fullscreen state of the client is"]
    #[doc = " subject to compositor policies."]
    #[doc = ""]
    #[doc = " Making a surface unfullscreen sets states for the surface based"]
    #[doc = " on the following: * the state(s) it may have had before becoming"]
    #[doc = " fullscreen * any state(s) decided by the compositor * any"]
    #[doc = " state(s) requested by the client while the surface was"]
    #[doc = " fullscreen"]
    #[doc = ""]
    #[doc = " The compositor may include the previous window geometry"]
    #[doc = " dimensions in the configure event, if applicable."]
    #[doc = ""]
    #[doc = " The client must also acknowledge the configure when committing"]
    #[doc = " the new content (see ack_configure)."]
    pub unset_fullscreen: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
    #[doc = " set the window as minimized"]
    #[doc = ""]
    #[doc = " Request that the compositor minimize your surface. There is no"]
    #[doc = " way to know if the surface is currently minimized, nor is there"]
    #[doc = " any way to unset minimization on this surface."]
    #[doc = ""]
    #[doc = " If you are looking to throttle redrawing when minimized, please"]
    #[doc = " instead use the wl_surface.frame event for this, as this will"]
    #[doc = " also work with live previews on windows in Alt-Tab, Expose or"]
    #[doc = " similar compositor features."]
    pub set_minimized: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
}
#[test]
fn bindgen_test_layout_xdg_toplevel_interface() {
    assert_eq!(
        ::std::mem::size_of::<xdg_toplevel_interface>(),
        112usize,
        concat!("Size of: ", stringify!(xdg_toplevel_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<xdg_toplevel_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(xdg_toplevel_interface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xdg_toplevel_interface>())).destroy as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xdg_toplevel_interface),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xdg_toplevel_interface>())).set_parent as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xdg_toplevel_interface),
            "::",
            stringify!(set_parent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xdg_toplevel_interface>())).set_title as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xdg_toplevel_interface),
            "::",
            stringify!(set_title)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xdg_toplevel_interface>())).set_app_id as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xdg_toplevel_interface),
            "::",
            stringify!(set_app_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xdg_toplevel_interface>())).show_window_menu as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(xdg_toplevel_interface),
            "::",
            stringify!(show_window_menu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xdg_toplevel_interface>())).move_ as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(xdg_toplevel_interface),
            "::",
            stringify!(move_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xdg_toplevel_interface>())).resize as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(xdg_toplevel_interface),
            "::",
            stringify!(resize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xdg_toplevel_interface>())).set_max_size as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(xdg_toplevel_interface),
            "::",
            stringify!(set_max_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xdg_toplevel_interface>())).set_min_size as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(xdg_toplevel_interface),
            "::",
            stringify!(set_min_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xdg_toplevel_interface>())).set_maximized as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(xdg_toplevel_interface),
            "::",
            stringify!(set_maximized)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xdg_toplevel_interface>())).unset_maximized as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(xdg_toplevel_interface),
            "::",
            stringify!(unset_maximized)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xdg_toplevel_interface>())).set_fullscreen as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(xdg_toplevel_interface),
            "::",
            stringify!(set_fullscreen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xdg_toplevel_interface>())).unset_fullscreen as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(xdg_toplevel_interface),
            "::",
            stringify!(unset_fullscreen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xdg_toplevel_interface>())).set_minimized as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(xdg_toplevel_interface),
            "::",
            stringify!(set_minimized)
        )
    );
}
pub mod xdg_popup_error {
    pub type Type = u32;
    #[doc = " tried to grab after being mapped"]
    pub const XDG_POPUP_ERROR_INVALID_GRAB: Type = 0;
}
#[doc = " @ingroup iface_xdg_popup"]
#[doc = " @struct xdg_popup_interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xdg_popup_interface {
    #[doc = " remove xdg_popup interface"]
    #[doc = ""]
    #[doc = " This destroys the popup. Explicitly destroying the xdg_popup"]
    #[doc = " object will also dismiss the popup, and unmap the surface."]
    #[doc = ""]
    #[doc = " If this xdg_popup is not the \"topmost\" popup, a protocol error"]
    #[doc = " will be sent."]
    pub destroy: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
    #[doc = " make the popup take an explicit grab"]
    #[doc = ""]
    #[doc = " This request makes the created popup take an explicit grab. An"]
    #[doc = " explicit grab will be dismissed when the user dismisses the"]
    #[doc = " popup, or when the client destroys the xdg_popup. This can be"]
    #[doc = " done by the user clicking outside the surface, using the"]
    #[doc = " keyboard, or even locking the screen through closing the lid or"]
    #[doc = " a timeout."]
    #[doc = ""]
    #[doc = " If the compositor denies the grab, the popup will be immediately"]
    #[doc = " dismissed."]
    #[doc = ""]
    #[doc = " This request must be used in response to some sort of user"]
    #[doc = " action like a button press, key press, or touch down event. The"]
    #[doc = " serial number of the event should be passed as 'serial'."]
    #[doc = ""]
    #[doc = " The parent of a grabbing popup must either be an xdg_toplevel"]
    #[doc = " surface or another xdg_popup with an explicit grab. If the"]
    #[doc = " parent is another xdg_popup it means that the popups are nested,"]
    #[doc = " with this popup now being the topmost popup."]
    #[doc = ""]
    #[doc = " Nested popups must be destroyed in the reverse order they were"]
    #[doc = " created in, e.g. the only popup you are allowed to destroy at"]
    #[doc = " all times is the topmost one."]
    #[doc = ""]
    #[doc = " When compositors choose to dismiss a popup, they may dismiss"]
    #[doc = " every nested grabbing popup as well. When a compositor dismisses"]
    #[doc = " popups, it will follow the same dismissing order as required"]
    #[doc = " from the client."]
    #[doc = ""]
    #[doc = " The parent of a grabbing popup must either be another xdg_popup"]
    #[doc = " with an active explicit grab, or an xdg_popup or xdg_toplevel,"]
    #[doc = " if there are no explicit grabs already taken."]
    #[doc = ""]
    #[doc = " If the topmost grabbing popup is destroyed, the grab will be"]
    #[doc = " returned to the parent of the popup, if that parent previously"]
    #[doc = " had an explicit grab."]
    #[doc = ""]
    #[doc = " If the parent is a grabbing popup which has already been"]
    #[doc = " dismissed, this popup will be immediately dismissed. If the"]
    #[doc = " parent is a popup that did not take an explicit grab, an error"]
    #[doc = " will be raised."]
    #[doc = ""]
    #[doc = " During a popup grab, the client owning the grab will receive"]
    #[doc = " pointer and touch events for all their surfaces as normal"]
    #[doc = " (similar to an \"owner-events\" grab in X11 parlance), while the"]
    #[doc = " top most grabbing popup will always have keyboard focus."]
    #[doc = " @param seat the wl_seat of the user event"]
    #[doc = " @param serial the serial of the user event"]
    pub grab: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            seat: *mut wl_resource,
            serial: u32,
        ),
    >,
}
#[test]
fn bindgen_test_layout_xdg_popup_interface() {
    assert_eq!(
        ::std::mem::size_of::<xdg_popup_interface>(),
        16usize,
        concat!("Size of: ", stringify!(xdg_popup_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<xdg_popup_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(xdg_popup_interface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xdg_popup_interface>())).destroy as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xdg_popup_interface),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xdg_popup_interface>())).grab as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xdg_popup_interface),
            "::",
            stringify!(grab)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_xdg_shell {
    pub global: *mut wl_global,
    pub clients: wl_list,
    pub popup_grabs: wl_list,
    pub ping_timeout: u32,
    pub display_destroy: wl_listener,
    pub events: wlr_xdg_shell__bindgen_ty_1,
    pub data: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_xdg_shell__bindgen_ty_1 {
    #[doc = " The `new_surface` event signals that a client has requested to"]
    #[doc = " create a new shell surface. At this point, the surface is ready to"]
    #[doc = " be configured but is not mapped or ready receive input events. The"]
    #[doc = " surface will be ready to be managed on the `map` event."]
    pub new_surface: wl_signal,
    pub destroy: wl_signal,
}
#[test]
fn bindgen_test_layout_wlr_xdg_shell__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wlr_xdg_shell__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(wlr_xdg_shell__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_xdg_shell__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_xdg_shell__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xdg_shell__bindgen_ty_1>())).new_surface as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_shell__bindgen_ty_1),
            "::",
            stringify!(new_surface)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xdg_shell__bindgen_ty_1>())).destroy as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_shell__bindgen_ty_1),
            "::",
            stringify!(destroy)
        )
    );
}
#[test]
fn bindgen_test_layout_wlr_xdg_shell() {
    assert_eq!(
        ::std::mem::size_of::<wlr_xdg_shell>(),
        112usize,
        concat!("Size of: ", stringify!(wlr_xdg_shell))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_xdg_shell>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_xdg_shell))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_shell>())).global as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_shell),
            "::",
            stringify!(global)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_shell>())).clients as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_shell),
            "::",
            stringify!(clients)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_shell>())).popup_grabs as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_shell),
            "::",
            stringify!(popup_grabs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_shell>())).ping_timeout as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_shell),
            "::",
            stringify!(ping_timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_shell>())).display_destroy as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_shell),
            "::",
            stringify!(display_destroy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_shell>())).events as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_shell),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_shell>())).data as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_shell),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_xdg_client {
    pub shell: *mut wlr_xdg_shell,
    pub resource: *mut wl_resource,
    pub client: *mut wl_client,
    pub surfaces: wl_list,
    pub link: wl_list,
    pub ping_serial: u32,
    pub ping_timer: *mut wl_event_source,
}
#[test]
fn bindgen_test_layout_wlr_xdg_client() {
    assert_eq!(
        ::std::mem::size_of::<wlr_xdg_client>(),
        72usize,
        concat!("Size of: ", stringify!(wlr_xdg_client))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_xdg_client>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_xdg_client))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_client>())).shell as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_client),
            "::",
            stringify!(shell)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_client>())).resource as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_client),
            "::",
            stringify!(resource)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_client>())).client as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_client),
            "::",
            stringify!(client)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_client>())).surfaces as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_client),
            "::",
            stringify!(surfaces)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_client>())).link as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_client),
            "::",
            stringify!(link)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_client>())).ping_serial as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_client),
            "::",
            stringify!(ping_serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_client>())).ping_timer as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_client),
            "::",
            stringify!(ping_timer)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_xdg_positioner {
    pub resource: *mut wl_resource,
    pub anchor_rect: wlr_box,
    pub anchor: xdg_positioner_anchor::Type,
    pub gravity: xdg_positioner_gravity::Type,
    pub constraint_adjustment: xdg_positioner_constraint_adjustment::Type,
    pub size: wlr_xdg_positioner__bindgen_ty_1,
    pub offset: wlr_xdg_positioner__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_xdg_positioner__bindgen_ty_1 {
    pub width: i32,
    pub height: i32,
}
#[test]
fn bindgen_test_layout_wlr_xdg_positioner__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wlr_xdg_positioner__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(wlr_xdg_positioner__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_xdg_positioner__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(wlr_xdg_positioner__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xdg_positioner__bindgen_ty_1>())).width as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_positioner__bindgen_ty_1),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xdg_positioner__bindgen_ty_1>())).height as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_positioner__bindgen_ty_1),
            "::",
            stringify!(height)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_xdg_positioner__bindgen_ty_2 {
    pub x: i32,
    pub y: i32,
}
#[test]
fn bindgen_test_layout_wlr_xdg_positioner__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<wlr_xdg_positioner__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(wlr_xdg_positioner__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_xdg_positioner__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(wlr_xdg_positioner__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xdg_positioner__bindgen_ty_2>())).x as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_positioner__bindgen_ty_2),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xdg_positioner__bindgen_ty_2>())).y as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_positioner__bindgen_ty_2),
            "::",
            stringify!(y)
        )
    );
}
#[test]
fn bindgen_test_layout_wlr_xdg_positioner() {
    assert_eq!(
        ::std::mem::size_of::<wlr_xdg_positioner>(),
        56usize,
        concat!("Size of: ", stringify!(wlr_xdg_positioner))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_xdg_positioner>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_xdg_positioner))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_positioner>())).resource as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_positioner),
            "::",
            stringify!(resource)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_positioner>())).anchor_rect as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_positioner),
            "::",
            stringify!(anchor_rect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_positioner>())).anchor as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_positioner),
            "::",
            stringify!(anchor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_positioner>())).gravity as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_positioner),
            "::",
            stringify!(gravity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xdg_positioner>())).constraint_adjustment as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_positioner),
            "::",
            stringify!(constraint_adjustment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_positioner>())).size as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_positioner),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_positioner>())).offset as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_positioner),
            "::",
            stringify!(offset)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_xdg_popup {
    pub base: *mut wlr_xdg_surface,
    pub link: wl_list,
    pub resource: *mut wl_resource,
    pub committed: bool,
    pub parent: *mut wlr_surface,
    pub seat: *mut wlr_seat,
    pub geometry: wlr_box,
    pub positioner: wlr_xdg_positioner,
    pub grab_link: wl_list,
}
#[test]
fn bindgen_test_layout_wlr_xdg_popup() {
    assert_eq!(
        ::std::mem::size_of::<wlr_xdg_popup>(),
        144usize,
        concat!("Size of: ", stringify!(wlr_xdg_popup))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_xdg_popup>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_xdg_popup))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_popup>())).base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_popup),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_popup>())).link as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_popup),
            "::",
            stringify!(link)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_popup>())).resource as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_popup),
            "::",
            stringify!(resource)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_popup>())).committed as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_popup),
            "::",
            stringify!(committed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_popup>())).parent as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_popup),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_popup>())).seat as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_popup),
            "::",
            stringify!(seat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_popup>())).geometry as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_popup),
            "::",
            stringify!(geometry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_popup>())).positioner as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_popup),
            "::",
            stringify!(positioner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_popup>())).grab_link as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_popup),
            "::",
            stringify!(grab_link)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_xdg_popup_grab {
    pub client: *mut wl_client,
    pub pointer_grab: wlr_seat_pointer_grab,
    pub keyboard_grab: wlr_seat_keyboard_grab,
    pub touch_grab: wlr_seat_touch_grab,
    pub seat: *mut wlr_seat,
    pub popups: wl_list,
    pub link: wl_list,
    pub seat_destroy: wl_listener,
}
#[test]
fn bindgen_test_layout_wlr_xdg_popup_grab() {
    assert_eq!(
        ::std::mem::size_of::<wlr_xdg_popup_grab>(),
        144usize,
        concat!("Size of: ", stringify!(wlr_xdg_popup_grab))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_xdg_popup_grab>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_xdg_popup_grab))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_popup_grab>())).client as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_popup_grab),
            "::",
            stringify!(client)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_popup_grab>())).pointer_grab as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_popup_grab),
            "::",
            stringify!(pointer_grab)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xdg_popup_grab>())).keyboard_grab as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_popup_grab),
            "::",
            stringify!(keyboard_grab)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_popup_grab>())).touch_grab as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_popup_grab),
            "::",
            stringify!(touch_grab)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_popup_grab>())).seat as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_popup_grab),
            "::",
            stringify!(seat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_popup_grab>())).popups as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_popup_grab),
            "::",
            stringify!(popups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_popup_grab>())).link as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_popup_grab),
            "::",
            stringify!(link)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_popup_grab>())).seat_destroy as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_popup_grab),
            "::",
            stringify!(seat_destroy)
        )
    );
}
pub mod wlr_xdg_surface_role {
    pub type Type = u32;
    pub const WLR_XDG_SURFACE_ROLE_NONE: Type = 0;
    pub const WLR_XDG_SURFACE_ROLE_TOPLEVEL: Type = 1;
    pub const WLR_XDG_SURFACE_ROLE_POPUP: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_xdg_toplevel_state {
    pub maximized: bool,
    pub fullscreen: bool,
    pub resizing: bool,
    pub activated: bool,
    pub tiled: u32,
    pub width: u32,
    pub height: u32,
    pub max_width: u32,
    pub max_height: u32,
    pub min_width: u32,
    pub min_height: u32,
    pub fullscreen_output: *mut wlr_output,
    pub fullscreen_output_destroy: wl_listener,
}
#[test]
fn bindgen_test_layout_wlr_xdg_toplevel_state() {
    assert_eq!(
        ::std::mem::size_of::<wlr_xdg_toplevel_state>(),
        64usize,
        concat!("Size of: ", stringify!(wlr_xdg_toplevel_state))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_xdg_toplevel_state>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_xdg_toplevel_state))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xdg_toplevel_state>())).maximized as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_toplevel_state),
            "::",
            stringify!(maximized)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xdg_toplevel_state>())).fullscreen as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_toplevel_state),
            "::",
            stringify!(fullscreen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_toplevel_state>())).resizing as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_toplevel_state),
            "::",
            stringify!(resizing)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xdg_toplevel_state>())).activated as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_toplevel_state),
            "::",
            stringify!(activated)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_toplevel_state>())).tiled as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_toplevel_state),
            "::",
            stringify!(tiled)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_toplevel_state>())).width as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_toplevel_state),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_toplevel_state>())).height as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_toplevel_state),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xdg_toplevel_state>())).max_width as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_toplevel_state),
            "::",
            stringify!(max_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xdg_toplevel_state>())).max_height as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_toplevel_state),
            "::",
            stringify!(max_height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xdg_toplevel_state>())).min_width as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_toplevel_state),
            "::",
            stringify!(min_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xdg_toplevel_state>())).min_height as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_toplevel_state),
            "::",
            stringify!(min_height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xdg_toplevel_state>())).fullscreen_output as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_toplevel_state),
            "::",
            stringify!(fullscreen_output)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xdg_toplevel_state>())).fullscreen_output_destroy as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_toplevel_state),
            "::",
            stringify!(fullscreen_output_destroy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_xdg_toplevel {
    pub resource: *mut wl_resource,
    pub base: *mut wlr_xdg_surface,
    pub added: bool,
    pub parent: *mut wlr_xdg_surface,
    pub parent_unmap: wl_listener,
    pub client_pending: wlr_xdg_toplevel_state,
    pub server_pending: wlr_xdg_toplevel_state,
    pub current: wlr_xdg_toplevel_state,
    pub title: *mut ::std::os::raw::c_char,
    pub app_id: *mut ::std::os::raw::c_char,
    pub events: wlr_xdg_toplevel__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_xdg_toplevel__bindgen_ty_1 {
    pub request_maximize: wl_signal,
    pub request_fullscreen: wl_signal,
    pub request_minimize: wl_signal,
    pub request_move: wl_signal,
    pub request_resize: wl_signal,
    pub request_show_window_menu: wl_signal,
    pub set_parent: wl_signal,
    pub set_title: wl_signal,
    pub set_app_id: wl_signal,
}
#[test]
fn bindgen_test_layout_wlr_xdg_toplevel__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wlr_xdg_toplevel__bindgen_ty_1>(),
        144usize,
        concat!("Size of: ", stringify!(wlr_xdg_toplevel__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_xdg_toplevel__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_xdg_toplevel__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xdg_toplevel__bindgen_ty_1>())).request_maximize as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_toplevel__bindgen_ty_1),
            "::",
            stringify!(request_maximize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xdg_toplevel__bindgen_ty_1>())).request_fullscreen
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_toplevel__bindgen_ty_1),
            "::",
            stringify!(request_fullscreen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xdg_toplevel__bindgen_ty_1>())).request_minimize as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_toplevel__bindgen_ty_1),
            "::",
            stringify!(request_minimize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xdg_toplevel__bindgen_ty_1>())).request_move as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_toplevel__bindgen_ty_1),
            "::",
            stringify!(request_move)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xdg_toplevel__bindgen_ty_1>())).request_resize as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_toplevel__bindgen_ty_1),
            "::",
            stringify!(request_resize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xdg_toplevel__bindgen_ty_1>())).request_show_window_menu
                as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_toplevel__bindgen_ty_1),
            "::",
            stringify!(request_show_window_menu)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xdg_toplevel__bindgen_ty_1>())).set_parent as *const _
                as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_toplevel__bindgen_ty_1),
            "::",
            stringify!(set_parent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xdg_toplevel__bindgen_ty_1>())).set_title as *const _
                as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_toplevel__bindgen_ty_1),
            "::",
            stringify!(set_title)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xdg_toplevel__bindgen_ty_1>())).set_app_id as *const _
                as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_toplevel__bindgen_ty_1),
            "::",
            stringify!(set_app_id)
        )
    );
}
#[test]
fn bindgen_test_layout_wlr_xdg_toplevel() {
    assert_eq!(
        ::std::mem::size_of::<wlr_xdg_toplevel>(),
        408usize,
        concat!("Size of: ", stringify!(wlr_xdg_toplevel))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_xdg_toplevel>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_xdg_toplevel))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_toplevel>())).resource as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_toplevel),
            "::",
            stringify!(resource)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_toplevel>())).base as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_toplevel),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_toplevel>())).added as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_toplevel),
            "::",
            stringify!(added)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_toplevel>())).parent as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_toplevel),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_toplevel>())).parent_unmap as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_toplevel),
            "::",
            stringify!(parent_unmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_toplevel>())).client_pending as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_toplevel),
            "::",
            stringify!(client_pending)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_toplevel>())).server_pending as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_toplevel),
            "::",
            stringify!(server_pending)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_toplevel>())).current as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_toplevel),
            "::",
            stringify!(current)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_toplevel>())).title as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_toplevel),
            "::",
            stringify!(title)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_toplevel>())).app_id as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_toplevel),
            "::",
            stringify!(app_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_toplevel>())).events as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_toplevel),
            "::",
            stringify!(events)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_xdg_surface_configure {
    pub surface: *mut wlr_xdg_surface,
    pub link: wl_list,
    pub serial: u32,
    pub toplevel_state: *mut wlr_xdg_toplevel_state,
}
#[test]
fn bindgen_test_layout_wlr_xdg_surface_configure() {
    assert_eq!(
        ::std::mem::size_of::<wlr_xdg_surface_configure>(),
        40usize,
        concat!("Size of: ", stringify!(wlr_xdg_surface_configure))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_xdg_surface_configure>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_xdg_surface_configure))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xdg_surface_configure>())).surface as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_surface_configure),
            "::",
            stringify!(surface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_surface_configure>())).link as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_surface_configure),
            "::",
            stringify!(link)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xdg_surface_configure>())).serial as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_surface_configure),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xdg_surface_configure>())).toplevel_state as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_surface_configure),
            "::",
            stringify!(toplevel_state)
        )
    );
}
#[doc = " An xdg-surface is a user interface element requiring management by the"]
#[doc = " compositor. An xdg-surface alone isn't useful, a role should be assigned to"]
#[doc = " it in order to map it."]
#[doc = ""]
#[doc = " When a surface has a role and is ready to be displayed, the `map` event is"]
#[doc = " emitted. When a surface should no longer be displayed, the `unmap` event is"]
#[doc = " emitted. The `unmap` event is guaranteed to be emitted before the `destroy`"]
#[doc = " event if the view is destroyed when mapped."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wlr_xdg_surface {
    pub client: *mut wlr_xdg_client,
    pub resource: *mut wl_resource,
    pub surface: *mut wlr_surface,
    pub link: wl_list,
    pub role: wlr_xdg_surface_role::Type,
    pub __bindgen_anon_1: wlr_xdg_surface__bindgen_ty_1,
    pub popups: wl_list,
    pub added: bool,
    pub configured: bool,
    pub mapped: bool,
    pub configure_serial: u32,
    pub configure_idle: *mut wl_event_source,
    pub configure_next_serial: u32,
    pub configure_list: wl_list,
    pub has_next_geometry: bool,
    pub next_geometry: wlr_box,
    pub geometry: wlr_box,
    pub surface_destroy: wl_listener,
    pub surface_commit: wl_listener,
    pub events: wlr_xdg_surface__bindgen_ty_2,
    pub data: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union wlr_xdg_surface__bindgen_ty_1 {
    pub toplevel: *mut wlr_xdg_toplevel,
    pub popup: *mut wlr_xdg_popup,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_wlr_xdg_surface__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wlr_xdg_surface__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(wlr_xdg_surface__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_xdg_surface__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_xdg_surface__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xdg_surface__bindgen_ty_1>())).toplevel as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_surface__bindgen_ty_1),
            "::",
            stringify!(toplevel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xdg_surface__bindgen_ty_1>())).popup as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_surface__bindgen_ty_1),
            "::",
            stringify!(popup)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_xdg_surface__bindgen_ty_2 {
    pub destroy: wl_signal,
    pub ping_timeout: wl_signal,
    pub new_popup: wl_signal,
    #[doc = " The `map` event signals that the shell surface is ready to be"]
    #[doc = " managed by the compositor and rendered on the screen. At this point,"]
    #[doc = " the surface has configured its properties, has had the opportunity"]
    #[doc = " to bind to the seat to receive input events, and has a buffer that"]
    #[doc = " is ready to be rendered. You can now safely add this surface to a"]
    #[doc = " list of views."]
    pub map: wl_signal,
    #[doc = " The `unmap` event signals that the surface is no longer in a state"]
    #[doc = " where it should be shown on the screen. This might happen if the"]
    #[doc = " surface no longer has a displayable buffer because either the"]
    #[doc = " surface has been hidden or is about to be destroyed."]
    pub unmap: wl_signal,
    pub configure: wl_signal,
    pub ack_configure: wl_signal,
}
#[test]
fn bindgen_test_layout_wlr_xdg_surface__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<wlr_xdg_surface__bindgen_ty_2>(),
        112usize,
        concat!("Size of: ", stringify!(wlr_xdg_surface__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_xdg_surface__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_xdg_surface__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xdg_surface__bindgen_ty_2>())).destroy as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_surface__bindgen_ty_2),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xdg_surface__bindgen_ty_2>())).ping_timeout as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_surface__bindgen_ty_2),
            "::",
            stringify!(ping_timeout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xdg_surface__bindgen_ty_2>())).new_popup as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_surface__bindgen_ty_2),
            "::",
            stringify!(new_popup)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xdg_surface__bindgen_ty_2>())).map as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_surface__bindgen_ty_2),
            "::",
            stringify!(map)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xdg_surface__bindgen_ty_2>())).unmap as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_surface__bindgen_ty_2),
            "::",
            stringify!(unmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xdg_surface__bindgen_ty_2>())).configure as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_surface__bindgen_ty_2),
            "::",
            stringify!(configure)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xdg_surface__bindgen_ty_2>())).ack_configure as *const _
                as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_surface__bindgen_ty_2),
            "::",
            stringify!(ack_configure)
        )
    );
}
#[test]
fn bindgen_test_layout_wlr_xdg_surface() {
    assert_eq!(
        ::std::mem::size_of::<wlr_xdg_surface>(),
        320usize,
        concat!("Size of: ", stringify!(wlr_xdg_surface))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_xdg_surface>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_xdg_surface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_surface>())).client as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_surface),
            "::",
            stringify!(client)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_surface>())).resource as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_surface),
            "::",
            stringify!(resource)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_surface>())).surface as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_surface),
            "::",
            stringify!(surface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_surface>())).link as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_surface),
            "::",
            stringify!(link)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_surface>())).role as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_surface),
            "::",
            stringify!(role)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_surface>())).popups as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_surface),
            "::",
            stringify!(popups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_surface>())).added as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_surface),
            "::",
            stringify!(added)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_surface>())).configured as *const _ as usize },
        73usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_surface),
            "::",
            stringify!(configured)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_surface>())).mapped as *const _ as usize },
        74usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_surface),
            "::",
            stringify!(mapped)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xdg_surface>())).configure_serial as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_surface),
            "::",
            stringify!(configure_serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_surface>())).configure_idle as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_surface),
            "::",
            stringify!(configure_idle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xdg_surface>())).configure_next_serial as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_surface),
            "::",
            stringify!(configure_next_serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_surface>())).configure_list as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_surface),
            "::",
            stringify!(configure_list)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xdg_surface>())).has_next_geometry as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_surface),
            "::",
            stringify!(has_next_geometry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_surface>())).next_geometry as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_surface),
            "::",
            stringify!(next_geometry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_surface>())).geometry as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_surface),
            "::",
            stringify!(geometry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_surface>())).surface_destroy as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_surface),
            "::",
            stringify!(surface_destroy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_surface>())).surface_commit as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_surface),
            "::",
            stringify!(surface_commit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_surface>())).events as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_surface),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xdg_surface>())).data as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_surface),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_xdg_toplevel_move_event {
    pub surface: *mut wlr_xdg_surface,
    pub seat: *mut wlr_seat_client,
    pub serial: u32,
}
#[test]
fn bindgen_test_layout_wlr_xdg_toplevel_move_event() {
    assert_eq!(
        ::std::mem::size_of::<wlr_xdg_toplevel_move_event>(),
        24usize,
        concat!("Size of: ", stringify!(wlr_xdg_toplevel_move_event))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_xdg_toplevel_move_event>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_xdg_toplevel_move_event))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xdg_toplevel_move_event>())).surface as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_toplevel_move_event),
            "::",
            stringify!(surface)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xdg_toplevel_move_event>())).seat as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_toplevel_move_event),
            "::",
            stringify!(seat)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xdg_toplevel_move_event>())).serial as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_toplevel_move_event),
            "::",
            stringify!(serial)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_xdg_toplevel_resize_event {
    pub surface: *mut wlr_xdg_surface,
    pub seat: *mut wlr_seat_client,
    pub serial: u32,
    pub edges: u32,
}
#[test]
fn bindgen_test_layout_wlr_xdg_toplevel_resize_event() {
    assert_eq!(
        ::std::mem::size_of::<wlr_xdg_toplevel_resize_event>(),
        24usize,
        concat!("Size of: ", stringify!(wlr_xdg_toplevel_resize_event))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_xdg_toplevel_resize_event>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_xdg_toplevel_resize_event))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xdg_toplevel_resize_event>())).surface as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_toplevel_resize_event),
            "::",
            stringify!(surface)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xdg_toplevel_resize_event>())).seat as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_toplevel_resize_event),
            "::",
            stringify!(seat)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xdg_toplevel_resize_event>())).serial as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_toplevel_resize_event),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xdg_toplevel_resize_event>())).edges as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_toplevel_resize_event),
            "::",
            stringify!(edges)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_xdg_toplevel_set_fullscreen_event {
    pub surface: *mut wlr_xdg_surface,
    pub fullscreen: bool,
    pub output: *mut wlr_output,
}
#[test]
fn bindgen_test_layout_wlr_xdg_toplevel_set_fullscreen_event() {
    assert_eq!(
        ::std::mem::size_of::<wlr_xdg_toplevel_set_fullscreen_event>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(wlr_xdg_toplevel_set_fullscreen_event)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_xdg_toplevel_set_fullscreen_event>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(wlr_xdg_toplevel_set_fullscreen_event)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xdg_toplevel_set_fullscreen_event>())).surface as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_toplevel_set_fullscreen_event),
            "::",
            stringify!(surface)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xdg_toplevel_set_fullscreen_event>())).fullscreen as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_toplevel_set_fullscreen_event),
            "::",
            stringify!(fullscreen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xdg_toplevel_set_fullscreen_event>())).output as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_toplevel_set_fullscreen_event),
            "::",
            stringify!(output)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_xdg_toplevel_show_window_menu_event {
    pub surface: *mut wlr_xdg_surface,
    pub seat: *mut wlr_seat_client,
    pub serial: u32,
    pub x: u32,
    pub y: u32,
}
#[test]
fn bindgen_test_layout_wlr_xdg_toplevel_show_window_menu_event() {
    assert_eq!(
        ::std::mem::size_of::<wlr_xdg_toplevel_show_window_menu_event>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(wlr_xdg_toplevel_show_window_menu_event)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_xdg_toplevel_show_window_menu_event>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(wlr_xdg_toplevel_show_window_menu_event)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xdg_toplevel_show_window_menu_event>())).surface as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_toplevel_show_window_menu_event),
            "::",
            stringify!(surface)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xdg_toplevel_show_window_menu_event>())).seat as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_toplevel_show_window_menu_event),
            "::",
            stringify!(seat)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xdg_toplevel_show_window_menu_event>())).serial as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_toplevel_show_window_menu_event),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xdg_toplevel_show_window_menu_event>())).x as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_toplevel_show_window_menu_event),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xdg_toplevel_show_window_menu_event>())).y as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xdg_toplevel_show_window_menu_event),
            "::",
            stringify!(y)
        )
    );
}
extern "C" {
    pub fn wlr_xdg_shell_create(display: *mut wl_display) -> *mut wlr_xdg_shell;
}
extern "C" {
    pub fn wlr_xdg_shell_destroy(xdg_shell: *mut wlr_xdg_shell);
}
extern "C" {
    pub fn wlr_xdg_surface_from_resource(resource: *mut wl_resource) -> *mut wlr_xdg_surface;
}
extern "C" {
    pub fn wlr_xdg_surface_from_popup_resource(resource: *mut wl_resource) -> *mut wlr_xdg_surface;
}
extern "C" {
    pub fn wlr_xdg_surface_from_toplevel_resource(
        resource: *mut wl_resource,
    ) -> *mut wlr_xdg_surface;
}
extern "C" {
    #[doc = " Send a ping to the surface. If the surface does not respond in a reasonable"]
    #[doc = " amount of time, the ping_timeout event will be emitted."]
    pub fn wlr_xdg_surface_ping(surface: *mut wlr_xdg_surface);
}
extern "C" {
    #[doc = " Request that this toplevel surface be the given size. Returns the associated"]
    #[doc = " configure serial."]
    pub fn wlr_xdg_toplevel_set_size(surface: *mut wlr_xdg_surface, width: u32, height: u32)
        -> u32;
}
extern "C" {
    #[doc = " Request that this toplevel surface show itself in an activated or deactivated"]
    #[doc = " state. Returns the associated configure serial."]
    pub fn wlr_xdg_toplevel_set_activated(surface: *mut wlr_xdg_surface, activated: bool) -> u32;
}
extern "C" {
    #[doc = " Request that this toplevel surface consider itself maximized or not"]
    #[doc = " maximized. Returns the associated configure serial."]
    pub fn wlr_xdg_toplevel_set_maximized(surface: *mut wlr_xdg_surface, maximized: bool) -> u32;
}
extern "C" {
    #[doc = " Request that this toplevel surface consider itself fullscreen or not"]
    #[doc = " fullscreen. Returns the associated configure serial."]
    pub fn wlr_xdg_toplevel_set_fullscreen(surface: *mut wlr_xdg_surface, fullscreen: bool) -> u32;
}
extern "C" {
    #[doc = " Request that this toplevel surface consider itself to be resizing or not"]
    #[doc = " resizing. Returns the associated configure serial."]
    pub fn wlr_xdg_toplevel_set_resizing(surface: *mut wlr_xdg_surface, resizing: bool) -> u32;
}
extern "C" {
    #[doc = " Request that this toplevel surface consider itself in a tiled layout and some"]
    #[doc = " edges are adjacent to another part of the tiling grid. `tiled_edges` is a"]
    #[doc = " bitfield of `enum wlr_edges`. Returns the associated configure serial."]
    pub fn wlr_xdg_toplevel_set_tiled(surface: *mut wlr_xdg_surface, tiled_edges: u32) -> u32;
}
extern "C" {
    #[doc = " Request that this xdg toplevel closes."]
    pub fn wlr_xdg_toplevel_send_close(surface: *mut wlr_xdg_surface);
}
extern "C" {
    #[doc = " Request that this xdg popup closes."]
    pub fn wlr_xdg_popup_destroy(surface: *mut wlr_xdg_surface);
}
extern "C" {
    #[doc = " Get the geometry for this positioner based on the anchor rect, gravity, and"]
    #[doc = " size of this positioner."]
    pub fn wlr_xdg_positioner_get_geometry(positioner: *mut wlr_xdg_positioner) -> wlr_box;
}
extern "C" {
    #[doc = " Get the anchor point for this popup in the toplevel parent's coordinate system."]
    pub fn wlr_xdg_popup_get_anchor_point(
        popup: *mut wlr_xdg_popup,
        toplevel_sx: *mut ::std::os::raw::c_int,
        toplevel_sy: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Convert the given coordinates in the popup coordinate system to the toplevel"]
    #[doc = " surface coordinate system."]
    pub fn wlr_xdg_popup_get_toplevel_coords(
        popup: *mut wlr_xdg_popup,
        popup_sx: ::std::os::raw::c_int,
        popup_sy: ::std::os::raw::c_int,
        toplevel_sx: *mut ::std::os::raw::c_int,
        toplevel_sy: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Set the geometry of this popup to unconstrain it according to its"]
    #[doc = " xdg-positioner rules. The box should be in the popup's root toplevel parent"]
    #[doc = " surface coordinate system."]
    pub fn wlr_xdg_popup_unconstrain_from_box(
        popup: *mut wlr_xdg_popup,
        toplevel_sx_box: *mut wlr_box,
    );
}
extern "C" {
    #[doc = "Invert the right/left anchor and gravity for this positioner. This can be"]
    #[doc = "used to \"flip\" the positioner around the anchor rect in the x direction."]
    pub fn wlr_positioner_invert_x(positioner: *mut wlr_xdg_positioner);
}
extern "C" {
    #[doc = "Invert the top/bottom anchor and gravity for this positioner. This can be"]
    #[doc = "used to \"flip\" the positioner around the anchor rect in the y direction."]
    pub fn wlr_positioner_invert_y(positioner: *mut wlr_xdg_positioner);
}
extern "C" {
    #[doc = " Find a surface within this xdg-surface tree at the given surface-local"]
    #[doc = " coordinates. Returns the surface and coordinates in the leaf surface"]
    #[doc = " coordinate system or NULL if no surface is found at that location."]
    pub fn wlr_xdg_surface_surface_at(
        surface: *mut wlr_xdg_surface,
        sx: f64,
        sy: f64,
        sub_x: *mut f64,
        sub_y: *mut f64,
    ) -> *mut wlr_surface;
}
extern "C" {
    pub fn wlr_surface_is_xdg_surface(surface: *mut wlr_surface) -> bool;
}
extern "C" {
    pub fn wlr_xdg_surface_from_wlr_surface(surface: *mut wlr_surface) -> *mut wlr_xdg_surface;
}
extern "C" {
    #[doc = " Get the surface geometry."]
    #[doc = " This is either the geometry as set by the client, or defaulted to the bounds"]
    #[doc = " of the surface + the subsurfaces (as specified by the protocol)."]
    #[doc = ""]
    #[doc = " The x and y value can be <0"]
    pub fn wlr_xdg_surface_get_geometry(surface: *mut wlr_xdg_surface, box_: *mut wlr_box);
}
extern "C" {
    #[doc = " Call `iterator` on each surface and popup in the xdg-surface tree, with the"]
    #[doc = " surface's position relative to the root xdg-surface. The function is called"]
    #[doc = " from root to leaves (in rendering order)."]
    pub fn wlr_xdg_surface_for_each_surface(
        surface: *mut wlr_xdg_surface,
        iterator: wlr_surface_iterator_func_t,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Schedule a surface configuration. This should only be called by protocols"]
    #[doc = " extending the shell."]
    pub fn wlr_xdg_surface_schedule_configure(surface: *mut wlr_xdg_surface) -> u32;
}
extern "C" {
    #[doc = " Call `iterator` on each popup in the xdg-surface tree, with the popup's"]
    #[doc = " position relative to the root xdg-surface. The function is called from root"]
    #[doc = " to leaves (in rendering order)."]
    pub fn wlr_xdg_surface_for_each_popup(
        surface: *mut wlr_xdg_surface,
        iterator: wlr_surface_iterator_func_t,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: usize) -> usize;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: usize,
    );
}
extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __errno_location() -> *mut ::std::os::raw::c_int;
}
pub mod wlr_log_importance {
    pub type Type = u32;
    pub const WLR_SILENT: Type = 0;
    pub const WLR_ERROR: Type = 1;
    pub const WLR_INFO: Type = 2;
    pub const WLR_DEBUG: Type = 3;
    pub const WLR_LOG_IMPORTANCE_LAST: Type = 4;
}
pub type wlr_log_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        importance: wlr_log_importance::Type,
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ),
>;
extern "C" {
    pub fn wlr_log_init(verbosity: wlr_log_importance::Type, callback: wlr_log_func_t);
}
extern "C" {
    pub fn wlr_log_get_verbosity() -> wlr_log_importance::Type;
}
extern "C" {
    pub fn _wlr_log(
        verbosity: wlr_log_importance::Type,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn _wlr_vlog(
        verbosity: wlr_log_importance::Type,
        format: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    );
}
extern "C" {
    #[doc = " Scales a region, ie. multiplies all its coordinates by `scale`."]
    #[doc = ""]
    #[doc = " The resulting coordinates are rounded up or down so that the new region is"]
    #[doc = " at least as big as the original one."]
    pub fn wlr_region_scale(dst: *mut pixman_region32_t, src: *mut pixman_region32_t, scale: f32);
}
extern "C" {
    #[doc = " Applies a transform to a region inside a box of size `width` x `height`."]
    pub fn wlr_region_transform(
        dst: *mut pixman_region32_t,
        src: *mut pixman_region32_t,
        transform: wl_output_transform::Type,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Expands the region of `distance`. If `distance` is negative, it shrinks the"]
    #[doc = " region."]
    pub fn wlr_region_expand(
        dst: *mut pixman_region32_t,
        src: *mut pixman_region32_t,
        distance: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn wlr_region_rotated_bounds(
        dst: *mut pixman_region32_t,
        src: *mut pixman_region32_t,
        rotation: f32,
        ox: ::std::os::raw::c_int,
        oy: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn wlr_region_confine(
        region: *mut pixman_region32_t,
        x1: f64,
        y1: f64,
        x2: f64,
        y2: f64,
        x2_out: *mut f64,
        y2_out: *mut f64,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: usize,
}
#[test]
fn bindgen_test_layout_iovec() {
    assert_eq!(
        ::std::mem::size_of::<iovec>(),
        16usize,
        concat!("Size of: ", stringify!(iovec))
    );
    assert_eq!(
        ::std::mem::align_of::<iovec>(),
        8usize,
        concat!("Alignment of ", stringify!(iovec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iovec>())).iov_base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iovec>())).iov_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_len)
        )
    );
}
extern "C" {
    pub fn readv(
        __fd: ::std::os::raw::c_int,
        __iovec: *const iovec,
        __count: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn writev(
        __fd: ::std::os::raw::c_int,
        __iovec: *const iovec,
        __count: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn preadv(
        __fd: ::std::os::raw::c_int,
        __iovec: *const iovec,
        __count: ::std::os::raw::c_int,
        __offset: __off_t,
    ) -> isize;
}
extern "C" {
    pub fn pwritev(
        __fd: ::std::os::raw::c_int,
        __iovec: *const iovec,
        __count: ::std::os::raw::c_int,
        __offset: __off_t,
    ) -> isize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sched_param() {
    assert_eq!(
        ::std::mem::size_of::<sched_param>(),
        4usize,
        concat!("Size of: ", stringify!(sched_param))
    );
    assert_eq!(
        ::std::mem::align_of::<sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(sched_param))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_param>())).sched_priority as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(sched_priority)
        )
    );
}
pub type __cpu_mask = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_set_t {
    pub __bits: [__cpu_mask; 16usize],
}
#[test]
fn bindgen_test_layout_cpu_set_t() {
    assert_eq!(
        ::std::mem::size_of::<cpu_set_t>(),
        128usize,
        concat!("Size of: ", stringify!(cpu_set_t))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_set_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_set_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_set_t>())).__bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_set_t),
            "::",
            stringify!(__bits)
        )
    );
}
extern "C" {
    pub fn __sched_cpucount(__setsize: usize, __setp: *const cpu_set_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __sched_cpualloc(__count: usize) -> *mut cpu_set_t;
}
extern "C" {
    pub fn __sched_cpufree(__set: *mut cpu_set_t);
}
extern "C" {
    pub fn sched_setparam(__pid: __pid_t, __param: *const sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getparam(__pid: __pid_t, __param: *mut sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_setscheduler(
        __pid: __pid_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getscheduler(__pid: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_yield() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_max(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_min(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_rr_get_interval(__pid: __pid_t, __t: *mut timespec) -> ::std::os::raw::c_int;
}
pub type __jmp_buf = [::std::os::raw::c_long; 8usize];
pub mod _bindgen_ty_3 {
    pub type Type = u32;
    pub const PTHREAD_CREATE_JOINABLE: Type = 0;
    pub const PTHREAD_CREATE_DETACHED: Type = 1;
}
pub mod _bindgen_ty_4 {
    pub type Type = u32;
    pub const PTHREAD_MUTEX_TIMED_NP: Type = 0;
    pub const PTHREAD_MUTEX_RECURSIVE_NP: Type = 1;
    pub const PTHREAD_MUTEX_ERRORCHECK_NP: Type = 2;
    pub const PTHREAD_MUTEX_ADAPTIVE_NP: Type = 3;
    pub const PTHREAD_MUTEX_NORMAL: Type = 0;
    pub const PTHREAD_MUTEX_RECURSIVE: Type = 1;
    pub const PTHREAD_MUTEX_ERRORCHECK: Type = 2;
    pub const PTHREAD_MUTEX_DEFAULT: Type = 0;
}
pub mod _bindgen_ty_5 {
    pub type Type = u32;
    pub const PTHREAD_MUTEX_STALLED: Type = 0;
    pub const PTHREAD_MUTEX_STALLED_NP: Type = 0;
    pub const PTHREAD_MUTEX_ROBUST: Type = 1;
    pub const PTHREAD_MUTEX_ROBUST_NP: Type = 1;
}
pub mod _bindgen_ty_6 {
    pub type Type = u32;
    pub const PTHREAD_PRIO_NONE: Type = 0;
    pub const PTHREAD_PRIO_INHERIT: Type = 1;
    pub const PTHREAD_PRIO_PROTECT: Type = 2;
}
pub mod _bindgen_ty_7 {
    pub type Type = u32;
    pub const PTHREAD_RWLOCK_PREFER_READER_NP: Type = 0;
    pub const PTHREAD_RWLOCK_PREFER_WRITER_NP: Type = 1;
    pub const PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP: Type = 2;
    pub const PTHREAD_RWLOCK_DEFAULT_NP: Type = 0;
}
pub mod _bindgen_ty_8 {
    pub type Type = u32;
    pub const PTHREAD_INHERIT_SCHED: Type = 0;
    pub const PTHREAD_EXPLICIT_SCHED: Type = 1;
}
pub mod _bindgen_ty_9 {
    pub type Type = u32;
    pub const PTHREAD_SCOPE_SYSTEM: Type = 0;
    pub const PTHREAD_SCOPE_PROCESS: Type = 1;
}
pub mod _bindgen_ty_10 {
    pub type Type = u32;
    pub const PTHREAD_PROCESS_PRIVATE: Type = 0;
    pub const PTHREAD_PROCESS_SHARED: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pthread_cleanup_buffer {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __canceltype: ::std::os::raw::c_int,
    pub __prev: *mut _pthread_cleanup_buffer,
}
#[test]
fn bindgen_test_layout__pthread_cleanup_buffer() {
    assert_eq!(
        ::std::mem::size_of::<_pthread_cleanup_buffer>(),
        32usize,
        concat!("Size of: ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<_pthread_cleanup_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_pthread_cleanup_buffer>())).__routine as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_pthread_cleanup_buffer>())).__arg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_pthread_cleanup_buffer>())).__canceltype as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__canceltype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_pthread_cleanup_buffer>())).__prev as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__prev)
        )
    );
}
pub mod _bindgen_ty_11 {
    pub type Type = u32;
    pub const PTHREAD_CANCEL_ENABLE: Type = 0;
    pub const PTHREAD_CANCEL_DISABLE: Type = 1;
}
pub mod _bindgen_ty_12 {
    pub type Type = u32;
    pub const PTHREAD_CANCEL_DEFERRED: Type = 0;
    pub const PTHREAD_CANCEL_ASYNCHRONOUS: Type = 1;
}
extern "C" {
    pub fn pthread_create(
        __newthread: *mut pthread_t,
        __attr: *const pthread_attr_t,
        __start_routine: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_exit(__retval: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn pthread_join(
        __th: pthread_t,
        __thread_return: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_detach(__th: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_self() -> pthread_t;
}
extern "C" {
    pub fn pthread_equal(__thread1: pthread_t, __thread2: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_init(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_destroy(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getdetachstate(
        __attr: *const pthread_attr_t,
        __detachstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setdetachstate(
        __attr: *mut pthread_attr_t,
        __detachstate: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getguardsize(
        __attr: *const pthread_attr_t,
        __guardsize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setguardsize(
        __attr: *mut pthread_attr_t,
        __guardsize: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedparam(
        __attr: *const pthread_attr_t,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedparam(
        __attr: *mut pthread_attr_t,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedpolicy(
        __attr: *const pthread_attr_t,
        __policy: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedpolicy(
        __attr: *mut pthread_attr_t,
        __policy: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getinheritsched(
        __attr: *const pthread_attr_t,
        __inherit: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setinheritsched(
        __attr: *mut pthread_attr_t,
        __inherit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getscope(
        __attr: *const pthread_attr_t,
        __scope: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setscope(
        __attr: *mut pthread_attr_t,
        __scope: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstackaddr(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstackaddr(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstacksize(
        __attr: *const pthread_attr_t,
        __stacksize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstacksize(
        __attr: *mut pthread_attr_t,
        __stacksize: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstack(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
        __stacksize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstack(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
        __stacksize: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedparam(
        __target_thread: pthread_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getschedparam(
        __target_thread: pthread_t,
        __policy: *mut ::std::os::raw::c_int,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedprio(
        __target_thread: pthread_t,
        __prio: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_once(
        __once_control: *mut pthread_once_t,
        __init_routine: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcancelstate(
        __state: ::std::os::raw::c_int,
        __oldstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcanceltype(
        __type: ::std::os::raw::c_int,
        __oldtype: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cancel(__th: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_testcancel();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_unwind_buf_t {
    pub __cancel_jmp_buf: [__pthread_unwind_buf_t__bindgen_ty_1; 1usize],
    pub __pad: [*mut ::std::os::raw::c_void; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_unwind_buf_t__bindgen_ty_1 {
    pub __cancel_jmp_buf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___pthread_unwind_buf_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_unwind_buf_t__bindgen_ty_1>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_unwind_buf_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_unwind_buf_t__bindgen_ty_1>())).__cancel_jmp_buf
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1),
            "::",
            stringify!(__cancel_jmp_buf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_unwind_buf_t__bindgen_ty_1>())).__mask_was_saved
                as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1),
            "::",
            stringify!(__mask_was_saved)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_unwind_buf_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_unwind_buf_t>(),
        104usize,
        concat!("Size of: ", stringify!(__pthread_unwind_buf_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_unwind_buf_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_unwind_buf_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_unwind_buf_t>())).__cancel_jmp_buf as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t),
            "::",
            stringify!(__cancel_jmp_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_unwind_buf_t>())).__pad as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t),
            "::",
            stringify!(__pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cleanup_frame {
    pub __cancel_routine:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __cancel_arg: *mut ::std::os::raw::c_void,
    pub __do_it: ::std::os::raw::c_int,
    pub __cancel_type: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___pthread_cleanup_frame() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cleanup_frame>(),
        24usize,
        concat!("Size of: ", stringify!(__pthread_cleanup_frame))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cleanup_frame>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cleanup_frame))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cleanup_frame>())).__cancel_routine as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_routine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cleanup_frame>())).__cancel_arg as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cleanup_frame>())).__do_it as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__do_it)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cleanup_frame>())).__cancel_type as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_type)
        )
    );
}
extern "C" {
    pub fn __pthread_register_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unregister_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unwind_next(__buf: *mut __pthread_unwind_buf_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __jmp_buf_tag {
    _unused: [u8; 0],
}
extern "C" {
    pub fn __sigsetjmp(
        __env: *mut __jmp_buf_tag,
        __savemask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_init(
        __mutex: *mut pthread_mutex_t,
        __mutexattr: *const pthread_mutexattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_destroy(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_trylock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_timedlock(
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_getprioceiling(
        __mutex: *const pthread_mutex_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_setprioceiling(
        __mutex: *mut pthread_mutex_t,
        __prioceiling: ::std::os::raw::c_int,
        __old_ceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_consistent(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_init(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_destroy(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getpshared(
        __attr: *const pthread_mutexattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setpshared(
        __attr: *mut pthread_mutexattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_gettype(
        __attr: *const pthread_mutexattr_t,
        __kind: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_settype(
        __attr: *mut pthread_mutexattr_t,
        __kind: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprotocol(
        __attr: *const pthread_mutexattr_t,
        __protocol: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprotocol(
        __attr: *mut pthread_mutexattr_t,
        __protocol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprioceiling(
        __attr: *const pthread_mutexattr_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprioceiling(
        __attr: *mut pthread_mutexattr_t,
        __prioceiling: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getrobust(
        __attr: *const pthread_mutexattr_t,
        __robustness: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setrobust(
        __attr: *mut pthread_mutexattr_t,
        __robustness: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_init(
        __rwlock: *mut pthread_rwlock_t,
        __attr: *const pthread_rwlockattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_destroy(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_rdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_tryrdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedrdlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_wrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_trywrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedwrlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_unlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_init(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_destroy(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getpshared(
        __attr: *const pthread_rwlockattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setpshared(
        __attr: *mut pthread_rwlockattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getkind_np(
        __attr: *const pthread_rwlockattr_t,
        __pref: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setkind_np(
        __attr: *mut pthread_rwlockattr_t,
        __pref: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_init(
        __cond: *mut pthread_cond_t,
        __cond_attr: *const pthread_condattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_destroy(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_signal(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_broadcast(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_wait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_timedwait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_init(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_destroy(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getpshared(
        __attr: *const pthread_condattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setpshared(
        __attr: *mut pthread_condattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getclock(
        __attr: *const pthread_condattr_t,
        __clock_id: *mut __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setclock(
        __attr: *mut pthread_condattr_t,
        __clock_id: __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_init(
        __lock: *mut pthread_spinlock_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_destroy(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_lock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_trylock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_unlock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_init(
        __barrier: *mut pthread_barrier_t,
        __attr: *const pthread_barrierattr_t,
        __count: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_destroy(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_wait(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_init(__attr: *mut pthread_barrierattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_destroy(__attr: *mut pthread_barrierattr_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_getpshared(
        __attr: *const pthread_barrierattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_setpshared(
        __attr: *mut pthread_barrierattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_create(
        __key: *mut pthread_key_t,
        __destr_function: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_delete(__key: pthread_key_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getspecific(__key: pthread_key_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pthread_setspecific(
        __key: pthread_key_t,
        __pointer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getcpuclockid(
        __thread_id: pthread_t,
        __clock_id: *mut __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_atfork(
        __prepare: ::std::option::Option<unsafe extern "C" fn()>,
        __parent: ::std::option::Option<unsafe extern "C" fn()>,
        __child: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_connection_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_generic_iterator_t {
    pub data: *mut ::std::os::raw::c_void,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_generic_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_generic_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_generic_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_generic_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_generic_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_generic_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_generic_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_generic_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_generic_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
}
#[test]
fn bindgen_test_layout_xcb_generic_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_generic_reply_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_generic_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_generic_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_generic_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_generic_reply_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_generic_reply_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_generic_reply_t>())).sequence as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_generic_reply_t>())).length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_reply_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_generic_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub pad: [u32; 7usize],
    pub full_sequence: u32,
}
#[test]
fn bindgen_test_layout_xcb_generic_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_generic_event_t>(),
        36usize,
        concat!("Size of: ", stringify!(xcb_generic_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_generic_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_generic_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_generic_event_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_generic_event_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_generic_event_t>())).sequence as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_generic_event_t>())).pad as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_event_t),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_generic_event_t>())).full_sequence as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_event_t),
            "::",
            stringify!(full_sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_raw_generic_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub pad: [u32; 7usize],
}
#[test]
fn bindgen_test_layout_xcb_raw_generic_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_raw_generic_event_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_raw_generic_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_raw_generic_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_raw_generic_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_raw_generic_event_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_raw_generic_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_raw_generic_event_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_raw_generic_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_raw_generic_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_raw_generic_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_raw_generic_event_t>())).pad as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_raw_generic_event_t),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_ge_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub event_type: u16,
    pub pad1: u16,
    pub pad: [u32; 5usize],
    pub full_sequence: u32,
}
#[test]
fn bindgen_test_layout_xcb_ge_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_ge_event_t>(),
        36usize,
        concat!("Size of: ", stringify!(xcb_ge_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_ge_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_ge_event_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_ge_event_t>())).response_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ge_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_ge_event_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ge_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_ge_event_t>())).sequence as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ge_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_ge_event_t>())).length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ge_event_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_ge_event_t>())).event_type as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ge_event_t),
            "::",
            stringify!(event_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_ge_event_t>())).pad1 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ge_event_t),
            "::",
            stringify!(pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_ge_event_t>())).pad as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ge_event_t),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_ge_event_t>())).full_sequence as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ge_event_t),
            "::",
            stringify!(full_sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_generic_error_t {
    pub response_type: u8,
    pub error_code: u8,
    pub sequence: u16,
    pub resource_id: u32,
    pub minor_code: u16,
    pub major_code: u8,
    pub pad0: u8,
    pub pad: [u32; 5usize],
    pub full_sequence: u32,
}
#[test]
fn bindgen_test_layout_xcb_generic_error_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_generic_error_t>(),
        36usize,
        concat!("Size of: ", stringify!(xcb_generic_error_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_generic_error_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_generic_error_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_generic_error_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_error_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_generic_error_t>())).error_code as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_error_t),
            "::",
            stringify!(error_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_generic_error_t>())).sequence as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_error_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_generic_error_t>())).resource_id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_error_t),
            "::",
            stringify!(resource_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_generic_error_t>())).minor_code as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_error_t),
            "::",
            stringify!(minor_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_generic_error_t>())).major_code as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_error_t),
            "::",
            stringify!(major_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_generic_error_t>())).pad0 as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_error_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_generic_error_t>())).pad as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_error_t),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_generic_error_t>())).full_sequence as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_error_t),
            "::",
            stringify!(full_sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_void_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_void_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_void_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_void_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_void_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_void_cookie_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_void_cookie_t>())).sequence as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_void_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_char2b_t {
    pub byte1: u8,
    pub byte2: u8,
}
#[test]
fn bindgen_test_layout_xcb_char2b_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_char2b_t>(),
        2usize,
        concat!("Size of: ", stringify!(xcb_char2b_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_char2b_t>(),
        1usize,
        concat!("Alignment of ", stringify!(xcb_char2b_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_char2b_t>())).byte1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_char2b_t),
            "::",
            stringify!(byte1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_char2b_t>())).byte2 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_char2b_t),
            "::",
            stringify!(byte2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_char2b_iterator_t {
    pub data: *mut xcb_char2b_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_char2b_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_char2b_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_char2b_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_char2b_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_char2b_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_char2b_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_char2b_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_char2b_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_char2b_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_char2b_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_char2b_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_window_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_window_iterator_t {
    pub data: *mut xcb_window_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_window_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_window_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_window_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_window_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_window_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_window_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_window_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_window_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_window_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_window_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_window_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_pixmap_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_pixmap_iterator_t {
    pub data: *mut xcb_pixmap_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_pixmap_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_pixmap_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_pixmap_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_pixmap_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_pixmap_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_pixmap_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_pixmap_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_pixmap_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_pixmap_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_pixmap_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_pixmap_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_cursor_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_cursor_iterator_t {
    pub data: *mut xcb_cursor_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_cursor_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_cursor_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_cursor_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_cursor_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_cursor_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_cursor_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_cursor_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_cursor_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_cursor_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_cursor_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_cursor_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_font_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_font_iterator_t {
    pub data: *mut xcb_font_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_font_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_font_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_font_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_font_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_font_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_font_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_font_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_font_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_font_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_font_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_font_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_gcontext_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_gcontext_iterator_t {
    pub data: *mut xcb_gcontext_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_gcontext_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_gcontext_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_gcontext_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_gcontext_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_gcontext_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_gcontext_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_gcontext_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_gcontext_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_gcontext_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_gcontext_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_gcontext_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_colormap_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_colormap_iterator_t {
    pub data: *mut xcb_colormap_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_colormap_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_colormap_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_colormap_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_colormap_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_colormap_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_colormap_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_colormap_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_colormap_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_colormap_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_colormap_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_colormap_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_atom_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_atom_iterator_t {
    pub data: *mut xcb_atom_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_atom_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_atom_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_atom_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_atom_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_atom_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_atom_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_atom_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_atom_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_atom_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_atom_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_atom_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_drawable_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_drawable_iterator_t {
    pub data: *mut xcb_drawable_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_drawable_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_drawable_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_drawable_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_drawable_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_drawable_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_drawable_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_drawable_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_drawable_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_drawable_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_drawable_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_drawable_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_fontable_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_fontable_iterator_t {
    pub data: *mut xcb_fontable_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_fontable_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_fontable_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_fontable_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_fontable_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_fontable_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_fontable_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fontable_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_fontable_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fontable_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_fontable_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fontable_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_bool32_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_bool32_iterator_t {
    pub data: *mut xcb_bool32_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_bool32_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_bool32_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_bool32_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_bool32_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_bool32_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_bool32_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_bool32_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_bool32_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_bool32_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_bool32_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_bool32_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_visualid_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_visualid_iterator_t {
    pub data: *mut xcb_visualid_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_visualid_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_visualid_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_visualid_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_visualid_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_visualid_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_visualid_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visualid_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_visualid_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visualid_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_visualid_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visualid_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_timestamp_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_timestamp_iterator_t {
    pub data: *mut xcb_timestamp_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_timestamp_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_timestamp_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_timestamp_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_timestamp_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_timestamp_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_timestamp_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_timestamp_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_timestamp_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_timestamp_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_timestamp_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_timestamp_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_keysym_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_keysym_iterator_t {
    pub data: *mut xcb_keysym_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_keysym_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_keysym_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_keysym_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_keysym_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_keysym_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_keysym_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_keysym_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_keysym_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_keysym_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_keysym_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_keysym_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_keycode_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_keycode_iterator_t {
    pub data: *mut xcb_keycode_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_keycode_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_keycode_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_keycode_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_keycode_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_keycode_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_keycode_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_keycode_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_keycode_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_keycode_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_keycode_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_keycode_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_keycode32_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_keycode32_iterator_t {
    pub data: *mut xcb_keycode32_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_keycode32_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_keycode32_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_keycode32_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_keycode32_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_keycode32_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_keycode32_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_keycode32_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_keycode32_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_keycode32_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_keycode32_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_keycode32_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_button_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_button_iterator_t {
    pub data: *mut xcb_button_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_button_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_button_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_button_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_button_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_button_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_button_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_button_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_button_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_point_t {
    pub x: i16,
    pub y: i16,
}
#[test]
fn bindgen_test_layout_xcb_point_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_point_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_point_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_point_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_point_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_point_t>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_point_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_point_t>())).y as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_point_t),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_point_iterator_t {
    pub data: *mut xcb_point_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_point_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_point_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_point_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_point_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_point_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_point_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_point_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_point_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_point_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_point_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_point_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_rectangle_t {
    pub x: i16,
    pub y: i16,
    pub width: u16,
    pub height: u16,
}
#[test]
fn bindgen_test_layout_xcb_rectangle_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_rectangle_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_rectangle_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_rectangle_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_rectangle_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_rectangle_t>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rectangle_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_rectangle_t>())).y as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rectangle_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_rectangle_t>())).width as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rectangle_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_rectangle_t>())).height as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rectangle_t),
            "::",
            stringify!(height)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_rectangle_iterator_t {
    pub data: *mut xcb_rectangle_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_rectangle_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_rectangle_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_rectangle_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_rectangle_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_rectangle_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_rectangle_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rectangle_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_rectangle_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rectangle_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_rectangle_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rectangle_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_arc_t {
    pub x: i16,
    pub y: i16,
    pub width: u16,
    pub height: u16,
    pub angle1: i16,
    pub angle2: i16,
}
#[test]
fn bindgen_test_layout_xcb_arc_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_arc_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_arc_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_arc_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_arc_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_arc_t>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_arc_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_arc_t>())).y as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_arc_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_arc_t>())).width as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_arc_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_arc_t>())).height as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_arc_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_arc_t>())).angle1 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_arc_t),
            "::",
            stringify!(angle1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_arc_t>())).angle2 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_arc_t),
            "::",
            stringify!(angle2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_arc_iterator_t {
    pub data: *mut xcb_arc_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_arc_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_arc_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_arc_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_arc_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_arc_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_arc_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_arc_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_arc_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_arc_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_arc_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_arc_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_format_t {
    pub depth: u8,
    pub bits_per_pixel: u8,
    pub scanline_pad: u8,
    pub pad0: [u8; 5usize],
}
#[test]
fn bindgen_test_layout_xcb_format_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_format_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_format_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_format_t>(),
        1usize,
        concat!("Alignment of ", stringify!(xcb_format_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_format_t>())).depth as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_format_t),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_format_t>())).bits_per_pixel as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_format_t),
            "::",
            stringify!(bits_per_pixel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_format_t>())).scanline_pad as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_format_t),
            "::",
            stringify!(scanline_pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_format_t>())).pad0 as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_format_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_format_iterator_t {
    pub data: *mut xcb_format_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_format_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_format_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_format_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_format_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_format_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_format_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_format_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_format_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_format_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_format_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_format_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub mod xcb_visual_class_t {
    pub type Type = u32;
    pub const XCB_VISUAL_CLASS_STATIC_GRAY: Type = 0;
    pub const XCB_VISUAL_CLASS_GRAY_SCALE: Type = 1;
    pub const XCB_VISUAL_CLASS_STATIC_COLOR: Type = 2;
    pub const XCB_VISUAL_CLASS_PSEUDO_COLOR: Type = 3;
    pub const XCB_VISUAL_CLASS_TRUE_COLOR: Type = 4;
    pub const XCB_VISUAL_CLASS_DIRECT_COLOR: Type = 5;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_visualtype_t {
    pub visual_id: xcb_visualid_t,
    pub _class: u8,
    pub bits_per_rgb_value: u8,
    pub colormap_entries: u16,
    pub red_mask: u32,
    pub green_mask: u32,
    pub blue_mask: u32,
    pub pad0: [u8; 4usize],
}
#[test]
fn bindgen_test_layout_xcb_visualtype_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_visualtype_t>(),
        24usize,
        concat!("Size of: ", stringify!(xcb_visualtype_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_visualtype_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_visualtype_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_visualtype_t>())).visual_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visualtype_t),
            "::",
            stringify!(visual_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_visualtype_t>()))._class as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visualtype_t),
            "::",
            stringify!(_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_visualtype_t>())).bits_per_rgb_value as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visualtype_t),
            "::",
            stringify!(bits_per_rgb_value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_visualtype_t>())).colormap_entries as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visualtype_t),
            "::",
            stringify!(colormap_entries)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_visualtype_t>())).red_mask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visualtype_t),
            "::",
            stringify!(red_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_visualtype_t>())).green_mask as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visualtype_t),
            "::",
            stringify!(green_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_visualtype_t>())).blue_mask as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visualtype_t),
            "::",
            stringify!(blue_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_visualtype_t>())).pad0 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visualtype_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_visualtype_iterator_t {
    pub data: *mut xcb_visualtype_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_visualtype_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_visualtype_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_visualtype_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_visualtype_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_visualtype_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_visualtype_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visualtype_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_visualtype_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visualtype_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_visualtype_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visualtype_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_depth_t {
    pub depth: u8,
    pub pad0: u8,
    pub visuals_len: u16,
    pub pad1: [u8; 4usize],
}
#[test]
fn bindgen_test_layout_xcb_depth_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_depth_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_depth_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_depth_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_depth_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_depth_t>())).depth as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_depth_t),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_depth_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_depth_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_depth_t>())).visuals_len as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_depth_t),
            "::",
            stringify!(visuals_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_depth_t>())).pad1 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_depth_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_depth_iterator_t {
    pub data: *mut xcb_depth_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_depth_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_depth_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_depth_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_depth_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_depth_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_depth_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_depth_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_depth_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_depth_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_depth_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_depth_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub mod xcb_event_mask_t {
    pub type Type = u32;
    pub const XCB_EVENT_MASK_NO_EVENT: Type = 0;
    pub const XCB_EVENT_MASK_KEY_PRESS: Type = 1;
    pub const XCB_EVENT_MASK_KEY_RELEASE: Type = 2;
    pub const XCB_EVENT_MASK_BUTTON_PRESS: Type = 4;
    pub const XCB_EVENT_MASK_BUTTON_RELEASE: Type = 8;
    pub const XCB_EVENT_MASK_ENTER_WINDOW: Type = 16;
    pub const XCB_EVENT_MASK_LEAVE_WINDOW: Type = 32;
    pub const XCB_EVENT_MASK_POINTER_MOTION: Type = 64;
    pub const XCB_EVENT_MASK_POINTER_MOTION_HINT: Type = 128;
    pub const XCB_EVENT_MASK_BUTTON_1_MOTION: Type = 256;
    pub const XCB_EVENT_MASK_BUTTON_2_MOTION: Type = 512;
    pub const XCB_EVENT_MASK_BUTTON_3_MOTION: Type = 1024;
    pub const XCB_EVENT_MASK_BUTTON_4_MOTION: Type = 2048;
    pub const XCB_EVENT_MASK_BUTTON_5_MOTION: Type = 4096;
    pub const XCB_EVENT_MASK_BUTTON_MOTION: Type = 8192;
    pub const XCB_EVENT_MASK_KEYMAP_STATE: Type = 16384;
    pub const XCB_EVENT_MASK_EXPOSURE: Type = 32768;
    pub const XCB_EVENT_MASK_VISIBILITY_CHANGE: Type = 65536;
    pub const XCB_EVENT_MASK_STRUCTURE_NOTIFY: Type = 131072;
    pub const XCB_EVENT_MASK_RESIZE_REDIRECT: Type = 262144;
    pub const XCB_EVENT_MASK_SUBSTRUCTURE_NOTIFY: Type = 524288;
    pub const XCB_EVENT_MASK_SUBSTRUCTURE_REDIRECT: Type = 1048576;
    pub const XCB_EVENT_MASK_FOCUS_CHANGE: Type = 2097152;
    pub const XCB_EVENT_MASK_PROPERTY_CHANGE: Type = 4194304;
    pub const XCB_EVENT_MASK_COLOR_MAP_CHANGE: Type = 8388608;
    pub const XCB_EVENT_MASK_OWNER_GRAB_BUTTON: Type = 16777216;
}
pub mod xcb_backing_store_t {
    pub type Type = u32;
    pub const XCB_BACKING_STORE_NOT_USEFUL: Type = 0;
    pub const XCB_BACKING_STORE_WHEN_MAPPED: Type = 1;
    pub const XCB_BACKING_STORE_ALWAYS: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_screen_t {
    pub root: xcb_window_t,
    pub default_colormap: xcb_colormap_t,
    pub white_pixel: u32,
    pub black_pixel: u32,
    pub current_input_masks: u32,
    pub width_in_pixels: u16,
    pub height_in_pixels: u16,
    pub width_in_millimeters: u16,
    pub height_in_millimeters: u16,
    pub min_installed_maps: u16,
    pub max_installed_maps: u16,
    pub root_visual: xcb_visualid_t,
    pub backing_stores: u8,
    pub save_unders: u8,
    pub root_depth: u8,
    pub allowed_depths_len: u8,
}
#[test]
fn bindgen_test_layout_xcb_screen_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_screen_t>(),
        40usize,
        concat!("Size of: ", stringify!(xcb_screen_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_screen_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_screen_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_screen_t>())).root as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_screen_t>())).default_colormap as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(default_colormap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_screen_t>())).white_pixel as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(white_pixel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_screen_t>())).black_pixel as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(black_pixel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_screen_t>())).current_input_masks as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(current_input_masks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_screen_t>())).width_in_pixels as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(width_in_pixels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_screen_t>())).height_in_pixels as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(height_in_pixels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_screen_t>())).width_in_millimeters as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(width_in_millimeters)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_screen_t>())).height_in_millimeters as *const _ as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(height_in_millimeters)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_screen_t>())).min_installed_maps as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(min_installed_maps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_screen_t>())).max_installed_maps as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(max_installed_maps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_screen_t>())).root_visual as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(root_visual)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_screen_t>())).backing_stores as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(backing_stores)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_screen_t>())).save_unders as *const _ as usize },
        37usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(save_unders)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_screen_t>())).root_depth as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(root_depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_screen_t>())).allowed_depths_len as *const _ as usize },
        39usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(allowed_depths_len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_screen_iterator_t {
    pub data: *mut xcb_screen_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_screen_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_screen_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_screen_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_screen_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_screen_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_screen_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_screen_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_screen_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_setup_request_t {
    pub byte_order: u8,
    pub pad0: u8,
    pub protocol_major_version: u16,
    pub protocol_minor_version: u16,
    pub authorization_protocol_name_len: u16,
    pub authorization_protocol_data_len: u16,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_setup_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_setup_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_setup_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_setup_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_setup_request_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_setup_request_t>())).byte_order as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_request_t),
            "::",
            stringify!(byte_order)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_setup_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_setup_request_t>())).protocol_major_version as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_request_t),
            "::",
            stringify!(protocol_major_version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_setup_request_t>())).protocol_minor_version as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_request_t),
            "::",
            stringify!(protocol_minor_version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_setup_request_t>())).authorization_protocol_name_len
                as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_request_t),
            "::",
            stringify!(authorization_protocol_name_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_setup_request_t>())).authorization_protocol_data_len
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_request_t),
            "::",
            stringify!(authorization_protocol_data_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_setup_request_t>())).pad1 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_request_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_setup_request_iterator_t {
    pub data: *mut xcb_setup_request_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_setup_request_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_setup_request_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_setup_request_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_setup_request_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_setup_request_iterator_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_setup_request_iterator_t>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_request_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_setup_request_iterator_t>())).rem as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_request_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_setup_request_iterator_t>())).index as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_request_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_setup_failed_t {
    pub status: u8,
    pub reason_len: u8,
    pub protocol_major_version: u16,
    pub protocol_minor_version: u16,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_setup_failed_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_setup_failed_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_setup_failed_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_setup_failed_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_setup_failed_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_setup_failed_t>())).status as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_failed_t),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_setup_failed_t>())).reason_len as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_failed_t),
            "::",
            stringify!(reason_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_setup_failed_t>())).protocol_major_version as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_failed_t),
            "::",
            stringify!(protocol_major_version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_setup_failed_t>())).protocol_minor_version as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_failed_t),
            "::",
            stringify!(protocol_minor_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_setup_failed_t>())).length as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_failed_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_setup_failed_iterator_t {
    pub data: *mut xcb_setup_failed_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_setup_failed_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_setup_failed_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_setup_failed_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_setup_failed_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_setup_failed_iterator_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_setup_failed_iterator_t>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_failed_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_setup_failed_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_failed_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_setup_failed_iterator_t>())).index as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_failed_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_setup_authenticate_t {
    pub status: u8,
    pub pad0: [u8; 5usize],
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_setup_authenticate_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_setup_authenticate_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_setup_authenticate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_setup_authenticate_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_setup_authenticate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_setup_authenticate_t>())).status as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_authenticate_t),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_setup_authenticate_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_authenticate_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_setup_authenticate_t>())).length as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_authenticate_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_setup_authenticate_iterator_t {
    pub data: *mut xcb_setup_authenticate_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_setup_authenticate_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_setup_authenticate_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_setup_authenticate_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_setup_authenticate_iterator_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_setup_authenticate_iterator_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_setup_authenticate_iterator_t>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_authenticate_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_setup_authenticate_iterator_t>())).rem as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_authenticate_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_setup_authenticate_iterator_t>())).index as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_authenticate_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub mod xcb_image_order_t {
    pub type Type = u32;
    pub const XCB_IMAGE_ORDER_LSB_FIRST: Type = 0;
    pub const XCB_IMAGE_ORDER_MSB_FIRST: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_setup_t {
    pub status: u8,
    pub pad0: u8,
    pub protocol_major_version: u16,
    pub protocol_minor_version: u16,
    pub length: u16,
    pub release_number: u32,
    pub resource_id_base: u32,
    pub resource_id_mask: u32,
    pub motion_buffer_size: u32,
    pub vendor_len: u16,
    pub maximum_request_length: u16,
    pub roots_len: u8,
    pub pixmap_formats_len: u8,
    pub image_byte_order: u8,
    pub bitmap_format_bit_order: u8,
    pub bitmap_format_scanline_unit: u8,
    pub bitmap_format_scanline_pad: u8,
    pub min_keycode: xcb_keycode_t,
    pub max_keycode: xcb_keycode_t,
    pub pad1: [u8; 4usize],
}
#[test]
fn bindgen_test_layout_xcb_setup_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_setup_t>(),
        40usize,
        concat!("Size of: ", stringify!(xcb_setup_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_setup_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_setup_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_setup_t>())).status as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_setup_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_setup_t>())).protocol_major_version as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(protocol_major_version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_setup_t>())).protocol_minor_version as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(protocol_minor_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_setup_t>())).length as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_setup_t>())).release_number as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(release_number)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_setup_t>())).resource_id_base as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(resource_id_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_setup_t>())).resource_id_mask as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(resource_id_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_setup_t>())).motion_buffer_size as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(motion_buffer_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_setup_t>())).vendor_len as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(vendor_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_setup_t>())).maximum_request_length as *const _ as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(maximum_request_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_setup_t>())).roots_len as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(roots_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_setup_t>())).pixmap_formats_len as *const _ as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(pixmap_formats_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_setup_t>())).image_byte_order as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(image_byte_order)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_setup_t>())).bitmap_format_bit_order as *const _ as usize
        },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(bitmap_format_bit_order)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_setup_t>())).bitmap_format_scanline_unit as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(bitmap_format_scanline_unit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_setup_t>())).bitmap_format_scanline_pad as *const _ as usize
        },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(bitmap_format_scanline_pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_setup_t>())).min_keycode as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(min_keycode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_setup_t>())).max_keycode as *const _ as usize },
        35usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(max_keycode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_setup_t>())).pad1 as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_setup_iterator_t {
    pub data: *mut xcb_setup_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_setup_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_setup_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_setup_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_setup_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_setup_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_setup_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_setup_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_setup_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub mod xcb_mod_mask_t {
    pub type Type = u32;
    pub const XCB_MOD_MASK_SHIFT: Type = 1;
    pub const XCB_MOD_MASK_LOCK: Type = 2;
    pub const XCB_MOD_MASK_CONTROL: Type = 4;
    pub const XCB_MOD_MASK_1: Type = 8;
    pub const XCB_MOD_MASK_2: Type = 16;
    pub const XCB_MOD_MASK_3: Type = 32;
    pub const XCB_MOD_MASK_4: Type = 64;
    pub const XCB_MOD_MASK_5: Type = 128;
    pub const XCB_MOD_MASK_ANY: Type = 32768;
}
pub mod xcb_key_but_mask_t {
    pub type Type = u32;
    pub const XCB_KEY_BUT_MASK_SHIFT: Type = 1;
    pub const XCB_KEY_BUT_MASK_LOCK: Type = 2;
    pub const XCB_KEY_BUT_MASK_CONTROL: Type = 4;
    pub const XCB_KEY_BUT_MASK_MOD_1: Type = 8;
    pub const XCB_KEY_BUT_MASK_MOD_2: Type = 16;
    pub const XCB_KEY_BUT_MASK_MOD_3: Type = 32;
    pub const XCB_KEY_BUT_MASK_MOD_4: Type = 64;
    pub const XCB_KEY_BUT_MASK_MOD_5: Type = 128;
    pub const XCB_KEY_BUT_MASK_BUTTON_1: Type = 256;
    pub const XCB_KEY_BUT_MASK_BUTTON_2: Type = 512;
    pub const XCB_KEY_BUT_MASK_BUTTON_3: Type = 1024;
    pub const XCB_KEY_BUT_MASK_BUTTON_4: Type = 2048;
    pub const XCB_KEY_BUT_MASK_BUTTON_5: Type = 4096;
}
pub mod xcb_window_enum_t {
    pub type Type = u32;
    pub const XCB_WINDOW_NONE: Type = 0;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_key_press_event_t {
    pub response_type: u8,
    pub detail: xcb_keycode_t,
    pub sequence: u16,
    pub time: xcb_timestamp_t,
    pub root: xcb_window_t,
    pub event: xcb_window_t,
    pub child: xcb_window_t,
    pub root_x: i16,
    pub root_y: i16,
    pub event_x: i16,
    pub event_y: i16,
    pub state: u16,
    pub same_screen: u8,
    pub pad0: u8,
}
#[test]
fn bindgen_test_layout_xcb_key_press_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_key_press_event_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_key_press_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_key_press_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_key_press_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_key_press_event_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_key_press_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_key_press_event_t>())).detail as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_key_press_event_t),
            "::",
            stringify!(detail)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_key_press_event_t>())).sequence as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_key_press_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_key_press_event_t>())).time as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_key_press_event_t),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_key_press_event_t>())).root as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_key_press_event_t),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_key_press_event_t>())).event as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_key_press_event_t),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_key_press_event_t>())).child as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_key_press_event_t),
            "::",
            stringify!(child)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_key_press_event_t>())).root_x as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_key_press_event_t),
            "::",
            stringify!(root_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_key_press_event_t>())).root_y as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_key_press_event_t),
            "::",
            stringify!(root_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_key_press_event_t>())).event_x as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_key_press_event_t),
            "::",
            stringify!(event_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_key_press_event_t>())).event_y as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_key_press_event_t),
            "::",
            stringify!(event_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_key_press_event_t>())).state as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_key_press_event_t),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_key_press_event_t>())).same_screen as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_key_press_event_t),
            "::",
            stringify!(same_screen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_key_press_event_t>())).pad0 as *const _ as usize },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_key_press_event_t),
            "::",
            stringify!(pad0)
        )
    );
}
pub type xcb_key_release_event_t = xcb_key_press_event_t;
pub mod xcb_button_mask_t {
    pub type Type = u32;
    pub const XCB_BUTTON_MASK_1: Type = 256;
    pub const XCB_BUTTON_MASK_2: Type = 512;
    pub const XCB_BUTTON_MASK_3: Type = 1024;
    pub const XCB_BUTTON_MASK_4: Type = 2048;
    pub const XCB_BUTTON_MASK_5: Type = 4096;
    pub const XCB_BUTTON_MASK_ANY: Type = 32768;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_button_press_event_t {
    pub response_type: u8,
    pub detail: xcb_button_t,
    pub sequence: u16,
    pub time: xcb_timestamp_t,
    pub root: xcb_window_t,
    pub event: xcb_window_t,
    pub child: xcb_window_t,
    pub root_x: i16,
    pub root_y: i16,
    pub event_x: i16,
    pub event_y: i16,
    pub state: u16,
    pub same_screen: u8,
    pub pad0: u8,
}
#[test]
fn bindgen_test_layout_xcb_button_press_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_button_press_event_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_button_press_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_button_press_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_button_press_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_button_press_event_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_press_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_button_press_event_t>())).detail as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_press_event_t),
            "::",
            stringify!(detail)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_button_press_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_press_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_button_press_event_t>())).time as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_press_event_t),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_button_press_event_t>())).root as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_press_event_t),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_button_press_event_t>())).event as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_press_event_t),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_button_press_event_t>())).child as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_press_event_t),
            "::",
            stringify!(child)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_button_press_event_t>())).root_x as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_press_event_t),
            "::",
            stringify!(root_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_button_press_event_t>())).root_y as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_press_event_t),
            "::",
            stringify!(root_y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_button_press_event_t>())).event_x as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_press_event_t),
            "::",
            stringify!(event_x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_button_press_event_t>())).event_y as *const _ as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_press_event_t),
            "::",
            stringify!(event_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_button_press_event_t>())).state as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_press_event_t),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_button_press_event_t>())).same_screen as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_press_event_t),
            "::",
            stringify!(same_screen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_button_press_event_t>())).pad0 as *const _ as usize },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_press_event_t),
            "::",
            stringify!(pad0)
        )
    );
}
pub type xcb_button_release_event_t = xcb_button_press_event_t;
pub mod xcb_motion_t {
    pub type Type = u32;
    pub const XCB_MOTION_NORMAL: Type = 0;
    pub const XCB_MOTION_HINT: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_motion_notify_event_t {
    pub response_type: u8,
    pub detail: u8,
    pub sequence: u16,
    pub time: xcb_timestamp_t,
    pub root: xcb_window_t,
    pub event: xcb_window_t,
    pub child: xcb_window_t,
    pub root_x: i16,
    pub root_y: i16,
    pub event_x: i16,
    pub event_y: i16,
    pub state: u16,
    pub same_screen: u8,
    pub pad0: u8,
}
#[test]
fn bindgen_test_layout_xcb_motion_notify_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_motion_notify_event_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_motion_notify_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_motion_notify_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_motion_notify_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_motion_notify_event_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_motion_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_motion_notify_event_t>())).detail as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_motion_notify_event_t),
            "::",
            stringify!(detail)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_motion_notify_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_motion_notify_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_motion_notify_event_t>())).time as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_motion_notify_event_t),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_motion_notify_event_t>())).root as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_motion_notify_event_t),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_motion_notify_event_t>())).event as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_motion_notify_event_t),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_motion_notify_event_t>())).child as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_motion_notify_event_t),
            "::",
            stringify!(child)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_motion_notify_event_t>())).root_x as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_motion_notify_event_t),
            "::",
            stringify!(root_x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_motion_notify_event_t>())).root_y as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_motion_notify_event_t),
            "::",
            stringify!(root_y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_motion_notify_event_t>())).event_x as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_motion_notify_event_t),
            "::",
            stringify!(event_x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_motion_notify_event_t>())).event_y as *const _ as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_motion_notify_event_t),
            "::",
            stringify!(event_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_motion_notify_event_t>())).state as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_motion_notify_event_t),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_motion_notify_event_t>())).same_screen as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_motion_notify_event_t),
            "::",
            stringify!(same_screen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_motion_notify_event_t>())).pad0 as *const _ as usize },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_motion_notify_event_t),
            "::",
            stringify!(pad0)
        )
    );
}
pub mod xcb_notify_detail_t {
    pub type Type = u32;
    pub const XCB_NOTIFY_DETAIL_ANCESTOR: Type = 0;
    pub const XCB_NOTIFY_DETAIL_VIRTUAL: Type = 1;
    pub const XCB_NOTIFY_DETAIL_INFERIOR: Type = 2;
    pub const XCB_NOTIFY_DETAIL_NONLINEAR: Type = 3;
    pub const XCB_NOTIFY_DETAIL_NONLINEAR_VIRTUAL: Type = 4;
    pub const XCB_NOTIFY_DETAIL_POINTER: Type = 5;
    pub const XCB_NOTIFY_DETAIL_POINTER_ROOT: Type = 6;
    pub const XCB_NOTIFY_DETAIL_NONE: Type = 7;
}
pub mod xcb_notify_mode_t {
    pub type Type = u32;
    pub const XCB_NOTIFY_MODE_NORMAL: Type = 0;
    pub const XCB_NOTIFY_MODE_GRAB: Type = 1;
    pub const XCB_NOTIFY_MODE_UNGRAB: Type = 2;
    pub const XCB_NOTIFY_MODE_WHILE_GRABBED: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_enter_notify_event_t {
    pub response_type: u8,
    pub detail: u8,
    pub sequence: u16,
    pub time: xcb_timestamp_t,
    pub root: xcb_window_t,
    pub event: xcb_window_t,
    pub child: xcb_window_t,
    pub root_x: i16,
    pub root_y: i16,
    pub event_x: i16,
    pub event_y: i16,
    pub state: u16,
    pub mode: u8,
    pub same_screen_focus: u8,
}
#[test]
fn bindgen_test_layout_xcb_enter_notify_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_enter_notify_event_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_enter_notify_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_enter_notify_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_enter_notify_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_enter_notify_event_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_enter_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_enter_notify_event_t>())).detail as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_enter_notify_event_t),
            "::",
            stringify!(detail)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_enter_notify_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_enter_notify_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_enter_notify_event_t>())).time as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_enter_notify_event_t),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_enter_notify_event_t>())).root as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_enter_notify_event_t),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_enter_notify_event_t>())).event as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_enter_notify_event_t),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_enter_notify_event_t>())).child as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_enter_notify_event_t),
            "::",
            stringify!(child)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_enter_notify_event_t>())).root_x as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_enter_notify_event_t),
            "::",
            stringify!(root_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_enter_notify_event_t>())).root_y as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_enter_notify_event_t),
            "::",
            stringify!(root_y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_enter_notify_event_t>())).event_x as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_enter_notify_event_t),
            "::",
            stringify!(event_x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_enter_notify_event_t>())).event_y as *const _ as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_enter_notify_event_t),
            "::",
            stringify!(event_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_enter_notify_event_t>())).state as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_enter_notify_event_t),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_enter_notify_event_t>())).mode as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_enter_notify_event_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_enter_notify_event_t>())).same_screen_focus as *const _
                as usize
        },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_enter_notify_event_t),
            "::",
            stringify!(same_screen_focus)
        )
    );
}
pub type xcb_leave_notify_event_t = xcb_enter_notify_event_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_focus_in_event_t {
    pub response_type: u8,
    pub detail: u8,
    pub sequence: u16,
    pub event: xcb_window_t,
    pub mode: u8,
    pub pad0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_focus_in_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_focus_in_event_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_focus_in_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_focus_in_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_focus_in_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_focus_in_event_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_focus_in_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_focus_in_event_t>())).detail as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_focus_in_event_t),
            "::",
            stringify!(detail)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_focus_in_event_t>())).sequence as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_focus_in_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_focus_in_event_t>())).event as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_focus_in_event_t),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_focus_in_event_t>())).mode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_focus_in_event_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_focus_in_event_t>())).pad0 as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_focus_in_event_t),
            "::",
            stringify!(pad0)
        )
    );
}
pub type xcb_focus_out_event_t = xcb_focus_in_event_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_keymap_notify_event_t {
    pub response_type: u8,
    pub keys: [u8; 31usize],
}
#[test]
fn bindgen_test_layout_xcb_keymap_notify_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_keymap_notify_event_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_keymap_notify_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_keymap_notify_event_t>(),
        1usize,
        concat!("Alignment of ", stringify!(xcb_keymap_notify_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_keymap_notify_event_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_keymap_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_keymap_notify_event_t>())).keys as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_keymap_notify_event_t),
            "::",
            stringify!(keys)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_expose_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub window: xcb_window_t,
    pub x: u16,
    pub y: u16,
    pub width: u16,
    pub height: u16,
    pub count: u16,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_expose_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_expose_event_t>(),
        20usize,
        concat!("Size of: ", stringify!(xcb_expose_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_expose_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_expose_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_expose_event_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_expose_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_expose_event_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_expose_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_expose_event_t>())).sequence as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_expose_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_expose_event_t>())).window as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_expose_event_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_expose_event_t>())).x as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_expose_event_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_expose_event_t>())).y as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_expose_event_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_expose_event_t>())).width as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_expose_event_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_expose_event_t>())).height as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_expose_event_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_expose_event_t>())).count as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_expose_event_t),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_expose_event_t>())).pad1 as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_expose_event_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_graphics_exposure_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub drawable: xcb_drawable_t,
    pub x: u16,
    pub y: u16,
    pub width: u16,
    pub height: u16,
    pub minor_opcode: u16,
    pub count: u16,
    pub major_opcode: u8,
    pub pad1: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_graphics_exposure_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_graphics_exposure_event_t>(),
        24usize,
        concat!("Size of: ", stringify!(xcb_graphics_exposure_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_graphics_exposure_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_graphics_exposure_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_graphics_exposure_event_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_graphics_exposure_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_graphics_exposure_event_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_graphics_exposure_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_graphics_exposure_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_graphics_exposure_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_graphics_exposure_event_t>())).drawable as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_graphics_exposure_event_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_graphics_exposure_event_t>())).x as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_graphics_exposure_event_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_graphics_exposure_event_t>())).y as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_graphics_exposure_event_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_graphics_exposure_event_t>())).width as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_graphics_exposure_event_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_graphics_exposure_event_t>())).height as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_graphics_exposure_event_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_graphics_exposure_event_t>())).minor_opcode as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_graphics_exposure_event_t),
            "::",
            stringify!(minor_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_graphics_exposure_event_t>())).count as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_graphics_exposure_event_t),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_graphics_exposure_event_t>())).major_opcode as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_graphics_exposure_event_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_graphics_exposure_event_t>())).pad1 as *const _ as usize
        },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_graphics_exposure_event_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_no_exposure_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub drawable: xcb_drawable_t,
    pub minor_opcode: u16,
    pub major_opcode: u8,
    pub pad1: u8,
}
#[test]
fn bindgen_test_layout_xcb_no_exposure_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_no_exposure_event_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_no_exposure_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_no_exposure_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_no_exposure_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_no_exposure_event_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_no_exposure_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_no_exposure_event_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_no_exposure_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_no_exposure_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_no_exposure_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_no_exposure_event_t>())).drawable as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_no_exposure_event_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_no_exposure_event_t>())).minor_opcode as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_no_exposure_event_t),
            "::",
            stringify!(minor_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_no_exposure_event_t>())).major_opcode as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_no_exposure_event_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_no_exposure_event_t>())).pad1 as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_no_exposure_event_t),
            "::",
            stringify!(pad1)
        )
    );
}
pub mod xcb_visibility_t {
    pub type Type = u32;
    pub const XCB_VISIBILITY_UNOBSCURED: Type = 0;
    pub const XCB_VISIBILITY_PARTIALLY_OBSCURED: Type = 1;
    pub const XCB_VISIBILITY_FULLY_OBSCURED: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_visibility_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub window: xcb_window_t,
    pub state: u8,
    pub pad1: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_visibility_notify_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_visibility_notify_event_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_visibility_notify_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_visibility_notify_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_visibility_notify_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_visibility_notify_event_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visibility_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_visibility_notify_event_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visibility_notify_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_visibility_notify_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visibility_notify_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_visibility_notify_event_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visibility_notify_event_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_visibility_notify_event_t>())).state as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visibility_notify_event_t),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_visibility_notify_event_t>())).pad1 as *const _ as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visibility_notify_event_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_create_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub parent: xcb_window_t,
    pub window: xcb_window_t,
    pub x: i16,
    pub y: i16,
    pub width: u16,
    pub height: u16,
    pub border_width: u16,
    pub override_redirect: u8,
    pub pad1: u8,
}
#[test]
fn bindgen_test_layout_xcb_create_notify_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_create_notify_event_t>(),
        24usize,
        concat!("Size of: ", stringify!(xcb_create_notify_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_create_notify_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_create_notify_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_notify_event_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_create_notify_event_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_notify_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_notify_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_notify_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_notify_event_t>())).parent as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_notify_event_t),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_notify_event_t>())).window as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_notify_event_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_create_notify_event_t>())).x as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_notify_event_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_create_notify_event_t>())).y as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_notify_event_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_create_notify_event_t>())).width as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_notify_event_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_notify_event_t>())).height as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_notify_event_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_notify_event_t>())).border_width as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_notify_event_t),
            "::",
            stringify!(border_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_notify_event_t>())).override_redirect as *const _
                as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_notify_event_t),
            "::",
            stringify!(override_redirect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_create_notify_event_t>())).pad1 as *const _ as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_notify_event_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_destroy_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub event: xcb_window_t,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_destroy_notify_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_destroy_notify_event_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_destroy_notify_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_destroy_notify_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_destroy_notify_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_destroy_notify_event_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_destroy_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_destroy_notify_event_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_destroy_notify_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_destroy_notify_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_destroy_notify_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_destroy_notify_event_t>())).event as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_destroy_notify_event_t),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_destroy_notify_event_t>())).window as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_destroy_notify_event_t),
            "::",
            stringify!(window)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_unmap_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub event: xcb_window_t,
    pub window: xcb_window_t,
    pub from_configure: u8,
    pub pad1: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_unmap_notify_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_unmap_notify_event_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_unmap_notify_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_unmap_notify_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_unmap_notify_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_unmap_notify_event_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_unmap_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_unmap_notify_event_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_unmap_notify_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_unmap_notify_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_unmap_notify_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_unmap_notify_event_t>())).event as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_unmap_notify_event_t),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_unmap_notify_event_t>())).window as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_unmap_notify_event_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_unmap_notify_event_t>())).from_configure as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_unmap_notify_event_t),
            "::",
            stringify!(from_configure)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_unmap_notify_event_t>())).pad1 as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_unmap_notify_event_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_map_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub event: xcb_window_t,
    pub window: xcb_window_t,
    pub override_redirect: u8,
    pub pad1: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_map_notify_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_map_notify_event_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_map_notify_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_map_notify_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_map_notify_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_map_notify_event_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_map_notify_event_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_notify_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_map_notify_event_t>())).sequence as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_notify_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_map_notify_event_t>())).event as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_notify_event_t),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_map_notify_event_t>())).window as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_notify_event_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_map_notify_event_t>())).override_redirect as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_notify_event_t),
            "::",
            stringify!(override_redirect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_map_notify_event_t>())).pad1 as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_notify_event_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_map_request_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub parent: xcb_window_t,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_map_request_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_map_request_event_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_map_request_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_map_request_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_map_request_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_map_request_event_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_request_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_map_request_event_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_request_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_map_request_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_request_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_map_request_event_t>())).parent as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_request_event_t),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_map_request_event_t>())).window as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_request_event_t),
            "::",
            stringify!(window)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_reparent_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub event: xcb_window_t,
    pub window: xcb_window_t,
    pub parent: xcb_window_t,
    pub x: i16,
    pub y: i16,
    pub override_redirect: u8,
    pub pad1: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_reparent_notify_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_reparent_notify_event_t>(),
        24usize,
        concat!("Size of: ", stringify!(xcb_reparent_notify_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_reparent_notify_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_reparent_notify_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_reparent_notify_event_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_reparent_notify_event_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_notify_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_reparent_notify_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_notify_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_reparent_notify_event_t>())).event as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_notify_event_t),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_reparent_notify_event_t>())).window as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_notify_event_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_reparent_notify_event_t>())).parent as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_notify_event_t),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_reparent_notify_event_t>())).x as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_notify_event_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_reparent_notify_event_t>())).y as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_notify_event_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_reparent_notify_event_t>())).override_redirect as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_notify_event_t),
            "::",
            stringify!(override_redirect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_reparent_notify_event_t>())).pad1 as *const _ as usize
        },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_notify_event_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_configure_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub event: xcb_window_t,
    pub window: xcb_window_t,
    pub above_sibling: xcb_window_t,
    pub x: i16,
    pub y: i16,
    pub width: u16,
    pub height: u16,
    pub border_width: u16,
    pub override_redirect: u8,
    pub pad1: u8,
}
#[test]
fn bindgen_test_layout_xcb_configure_notify_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_configure_notify_event_t>(),
        28usize,
        concat!("Size of: ", stringify!(xcb_configure_notify_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_configure_notify_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_configure_notify_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_notify_event_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_notify_event_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_notify_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_notify_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_notify_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_notify_event_t>())).event as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_notify_event_t),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_notify_event_t>())).window as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_notify_event_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_notify_event_t>())).above_sibling as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_notify_event_t),
            "::",
            stringify!(above_sibling)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_configure_notify_event_t>())).x as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_notify_event_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_configure_notify_event_t>())).y as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_notify_event_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_notify_event_t>())).width as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_notify_event_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_notify_event_t>())).height as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_notify_event_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_notify_event_t>())).border_width as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_notify_event_t),
            "::",
            stringify!(border_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_notify_event_t>())).override_redirect as *const _
                as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_notify_event_t),
            "::",
            stringify!(override_redirect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_notify_event_t>())).pad1 as *const _ as usize
        },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_notify_event_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_configure_request_event_t {
    pub response_type: u8,
    pub stack_mode: u8,
    pub sequence: u16,
    pub parent: xcb_window_t,
    pub window: xcb_window_t,
    pub sibling: xcb_window_t,
    pub x: i16,
    pub y: i16,
    pub width: u16,
    pub height: u16,
    pub border_width: u16,
    pub value_mask: u16,
}
#[test]
fn bindgen_test_layout_xcb_configure_request_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_configure_request_event_t>(),
        28usize,
        concat!("Size of: ", stringify!(xcb_configure_request_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_configure_request_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_configure_request_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_request_event_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_request_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_request_event_t>())).stack_mode as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_request_event_t),
            "::",
            stringify!(stack_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_request_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_request_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_request_event_t>())).parent as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_request_event_t),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_request_event_t>())).window as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_request_event_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_request_event_t>())).sibling as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_request_event_t),
            "::",
            stringify!(sibling)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_configure_request_event_t>())).x as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_request_event_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_configure_request_event_t>())).y as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_request_event_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_request_event_t>())).width as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_request_event_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_request_event_t>())).height as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_request_event_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_request_event_t>())).border_width as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_request_event_t),
            "::",
            stringify!(border_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_request_event_t>())).value_mask as *const _
                as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_request_event_t),
            "::",
            stringify!(value_mask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_gravity_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub event: xcb_window_t,
    pub window: xcb_window_t,
    pub x: i16,
    pub y: i16,
}
#[test]
fn bindgen_test_layout_xcb_gravity_notify_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_gravity_notify_event_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_gravity_notify_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_gravity_notify_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_gravity_notify_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_gravity_notify_event_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_gravity_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_gravity_notify_event_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_gravity_notify_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_gravity_notify_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_gravity_notify_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_gravity_notify_event_t>())).event as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_gravity_notify_event_t),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_gravity_notify_event_t>())).window as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_gravity_notify_event_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_gravity_notify_event_t>())).x as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_gravity_notify_event_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_gravity_notify_event_t>())).y as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_gravity_notify_event_t),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_resize_request_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub window: xcb_window_t,
    pub width: u16,
    pub height: u16,
}
#[test]
fn bindgen_test_layout_xcb_resize_request_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_resize_request_event_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_resize_request_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_resize_request_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_resize_request_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_resize_request_event_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_resize_request_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_resize_request_event_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_resize_request_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_resize_request_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_resize_request_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_resize_request_event_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_resize_request_event_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_resize_request_event_t>())).width as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_resize_request_event_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_resize_request_event_t>())).height as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_resize_request_event_t),
            "::",
            stringify!(height)
        )
    );
}
pub mod xcb_place_t {
    pub type Type = u32;
    pub const XCB_PLACE_ON_TOP: Type = 0;
    pub const XCB_PLACE_ON_BOTTOM: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_circulate_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub event: xcb_window_t,
    pub window: xcb_window_t,
    pub pad1: [u8; 4usize],
    pub place: u8,
    pub pad2: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_circulate_notify_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_circulate_notify_event_t>(),
        20usize,
        concat!("Size of: ", stringify!(xcb_circulate_notify_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_circulate_notify_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_circulate_notify_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_circulate_notify_event_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_circulate_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_circulate_notify_event_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_circulate_notify_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_circulate_notify_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_circulate_notify_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_circulate_notify_event_t>())).event as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_circulate_notify_event_t),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_circulate_notify_event_t>())).window as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_circulate_notify_event_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_circulate_notify_event_t>())).pad1 as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_circulate_notify_event_t),
            "::",
            stringify!(pad1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_circulate_notify_event_t>())).place as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_circulate_notify_event_t),
            "::",
            stringify!(place)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_circulate_notify_event_t>())).pad2 as *const _ as usize
        },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_circulate_notify_event_t),
            "::",
            stringify!(pad2)
        )
    );
}
pub type xcb_circulate_request_event_t = xcb_circulate_notify_event_t;
pub mod xcb_property_t {
    pub type Type = u32;
    pub const XCB_PROPERTY_NEW_VALUE: Type = 0;
    pub const XCB_PROPERTY_DELETE: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_property_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub window: xcb_window_t,
    pub atom: xcb_atom_t,
    pub time: xcb_timestamp_t,
    pub state: u8,
    pub pad1: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_property_notify_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_property_notify_event_t>(),
        20usize,
        concat!("Size of: ", stringify!(xcb_property_notify_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_property_notify_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_property_notify_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_property_notify_event_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_property_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_property_notify_event_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_property_notify_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_property_notify_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_property_notify_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_property_notify_event_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_property_notify_event_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_property_notify_event_t>())).atom as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_property_notify_event_t),
            "::",
            stringify!(atom)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_property_notify_event_t>())).time as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_property_notify_event_t),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_property_notify_event_t>())).state as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_property_notify_event_t),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_property_notify_event_t>())).pad1 as *const _ as usize
        },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_property_notify_event_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_selection_clear_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub time: xcb_timestamp_t,
    pub owner: xcb_window_t,
    pub selection: xcb_atom_t,
}
#[test]
fn bindgen_test_layout_xcb_selection_clear_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_selection_clear_event_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_selection_clear_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_selection_clear_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_selection_clear_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_selection_clear_event_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_clear_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_selection_clear_event_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_clear_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_selection_clear_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_clear_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_selection_clear_event_t>())).time as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_clear_event_t),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_selection_clear_event_t>())).owner as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_clear_event_t),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_selection_clear_event_t>())).selection as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_clear_event_t),
            "::",
            stringify!(selection)
        )
    );
}
pub mod xcb_time_t {
    pub type Type = u32;
    pub const XCB_TIME_CURRENT_TIME: Type = 0;
}
pub mod xcb_atom_enum_t {
    pub type Type = u32;
    pub const XCB_ATOM_NONE: Type = 0;
    pub const XCB_ATOM_ANY: Type = 0;
    pub const XCB_ATOM_PRIMARY: Type = 1;
    pub const XCB_ATOM_SECONDARY: Type = 2;
    pub const XCB_ATOM_ARC: Type = 3;
    pub const XCB_ATOM_ATOM: Type = 4;
    pub const XCB_ATOM_BITMAP: Type = 5;
    pub const XCB_ATOM_CARDINAL: Type = 6;
    pub const XCB_ATOM_COLORMAP: Type = 7;
    pub const XCB_ATOM_CURSOR: Type = 8;
    pub const XCB_ATOM_CUT_BUFFER0: Type = 9;
    pub const XCB_ATOM_CUT_BUFFER1: Type = 10;
    pub const XCB_ATOM_CUT_BUFFER2: Type = 11;
    pub const XCB_ATOM_CUT_BUFFER3: Type = 12;
    pub const XCB_ATOM_CUT_BUFFER4: Type = 13;
    pub const XCB_ATOM_CUT_BUFFER5: Type = 14;
    pub const XCB_ATOM_CUT_BUFFER6: Type = 15;
    pub const XCB_ATOM_CUT_BUFFER7: Type = 16;
    pub const XCB_ATOM_DRAWABLE: Type = 17;
    pub const XCB_ATOM_FONT: Type = 18;
    pub const XCB_ATOM_INTEGER: Type = 19;
    pub const XCB_ATOM_PIXMAP: Type = 20;
    pub const XCB_ATOM_POINT: Type = 21;
    pub const XCB_ATOM_RECTANGLE: Type = 22;
    pub const XCB_ATOM_RESOURCE_MANAGER: Type = 23;
    pub const XCB_ATOM_RGB_COLOR_MAP: Type = 24;
    pub const XCB_ATOM_RGB_BEST_MAP: Type = 25;
    pub const XCB_ATOM_RGB_BLUE_MAP: Type = 26;
    pub const XCB_ATOM_RGB_DEFAULT_MAP: Type = 27;
    pub const XCB_ATOM_RGB_GRAY_MAP: Type = 28;
    pub const XCB_ATOM_RGB_GREEN_MAP: Type = 29;
    pub const XCB_ATOM_RGB_RED_MAP: Type = 30;
    pub const XCB_ATOM_STRING: Type = 31;
    pub const XCB_ATOM_VISUALID: Type = 32;
    pub const XCB_ATOM_WINDOW: Type = 33;
    pub const XCB_ATOM_WM_COMMAND: Type = 34;
    pub const XCB_ATOM_WM_HINTS: Type = 35;
    pub const XCB_ATOM_WM_CLIENT_MACHINE: Type = 36;
    pub const XCB_ATOM_WM_ICON_NAME: Type = 37;
    pub const XCB_ATOM_WM_ICON_SIZE: Type = 38;
    pub const XCB_ATOM_WM_NAME: Type = 39;
    pub const XCB_ATOM_WM_NORMAL_HINTS: Type = 40;
    pub const XCB_ATOM_WM_SIZE_HINTS: Type = 41;
    pub const XCB_ATOM_WM_ZOOM_HINTS: Type = 42;
    pub const XCB_ATOM_MIN_SPACE: Type = 43;
    pub const XCB_ATOM_NORM_SPACE: Type = 44;
    pub const XCB_ATOM_MAX_SPACE: Type = 45;
    pub const XCB_ATOM_END_SPACE: Type = 46;
    pub const XCB_ATOM_SUPERSCRIPT_X: Type = 47;
    pub const XCB_ATOM_SUPERSCRIPT_Y: Type = 48;
    pub const XCB_ATOM_SUBSCRIPT_X: Type = 49;
    pub const XCB_ATOM_SUBSCRIPT_Y: Type = 50;
    pub const XCB_ATOM_UNDERLINE_POSITION: Type = 51;
    pub const XCB_ATOM_UNDERLINE_THICKNESS: Type = 52;
    pub const XCB_ATOM_STRIKEOUT_ASCENT: Type = 53;
    pub const XCB_ATOM_STRIKEOUT_DESCENT: Type = 54;
    pub const XCB_ATOM_ITALIC_ANGLE: Type = 55;
    pub const XCB_ATOM_X_HEIGHT: Type = 56;
    pub const XCB_ATOM_QUAD_WIDTH: Type = 57;
    pub const XCB_ATOM_WEIGHT: Type = 58;
    pub const XCB_ATOM_POINT_SIZE: Type = 59;
    pub const XCB_ATOM_RESOLUTION: Type = 60;
    pub const XCB_ATOM_COPYRIGHT: Type = 61;
    pub const XCB_ATOM_NOTICE: Type = 62;
    pub const XCB_ATOM_FONT_NAME: Type = 63;
    pub const XCB_ATOM_FAMILY_NAME: Type = 64;
    pub const XCB_ATOM_FULL_NAME: Type = 65;
    pub const XCB_ATOM_CAP_HEIGHT: Type = 66;
    pub const XCB_ATOM_WM_CLASS: Type = 67;
    pub const XCB_ATOM_WM_TRANSIENT_FOR: Type = 68;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_selection_request_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub time: xcb_timestamp_t,
    pub owner: xcb_window_t,
    pub requestor: xcb_window_t,
    pub selection: xcb_atom_t,
    pub target: xcb_atom_t,
    pub property: xcb_atom_t,
}
#[test]
fn bindgen_test_layout_xcb_selection_request_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_selection_request_event_t>(),
        28usize,
        concat!("Size of: ", stringify!(xcb_selection_request_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_selection_request_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_selection_request_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_selection_request_event_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_request_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_selection_request_event_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_request_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_selection_request_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_request_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_selection_request_event_t>())).time as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_request_event_t),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_selection_request_event_t>())).owner as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_request_event_t),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_selection_request_event_t>())).requestor as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_request_event_t),
            "::",
            stringify!(requestor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_selection_request_event_t>())).selection as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_request_event_t),
            "::",
            stringify!(selection)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_selection_request_event_t>())).target as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_request_event_t),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_selection_request_event_t>())).property as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_request_event_t),
            "::",
            stringify!(property)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_selection_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub time: xcb_timestamp_t,
    pub requestor: xcb_window_t,
    pub selection: xcb_atom_t,
    pub target: xcb_atom_t,
    pub property: xcb_atom_t,
}
#[test]
fn bindgen_test_layout_xcb_selection_notify_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_selection_notify_event_t>(),
        24usize,
        concat!("Size of: ", stringify!(xcb_selection_notify_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_selection_notify_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_selection_notify_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_selection_notify_event_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_selection_notify_event_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_notify_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_selection_notify_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_notify_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_selection_notify_event_t>())).time as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_notify_event_t),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_selection_notify_event_t>())).requestor as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_notify_event_t),
            "::",
            stringify!(requestor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_selection_notify_event_t>())).selection as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_notify_event_t),
            "::",
            stringify!(selection)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_selection_notify_event_t>())).target as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_notify_event_t),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_selection_notify_event_t>())).property as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_notify_event_t),
            "::",
            stringify!(property)
        )
    );
}
pub mod xcb_colormap_state_t {
    pub type Type = u32;
    pub const XCB_COLORMAP_STATE_UNINSTALLED: Type = 0;
    pub const XCB_COLORMAP_STATE_INSTALLED: Type = 1;
}
pub mod xcb_colormap_enum_t {
    pub type Type = u32;
    pub const XCB_COLORMAP_NONE: Type = 0;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_colormap_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub window: xcb_window_t,
    pub colormap: xcb_colormap_t,
    pub _new: u8,
    pub state: u8,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_colormap_notify_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_colormap_notify_event_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_colormap_notify_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_colormap_notify_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_colormap_notify_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_colormap_notify_event_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_colormap_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_colormap_notify_event_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_colormap_notify_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_colormap_notify_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_colormap_notify_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_colormap_notify_event_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_colormap_notify_event_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_colormap_notify_event_t>())).colormap as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_colormap_notify_event_t),
            "::",
            stringify!(colormap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_colormap_notify_event_t>()))._new as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_colormap_notify_event_t),
            "::",
            stringify!(_new)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_colormap_notify_event_t>())).state as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_colormap_notify_event_t),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_colormap_notify_event_t>())).pad1 as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_colormap_notify_event_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union xcb_client_message_data_t {
    pub data8: [u8; 20usize],
    pub data16: [u16; 10usize],
    pub data32: [u32; 5usize],
    _bindgen_union_align: [u32; 5usize],
}
#[test]
fn bindgen_test_layout_xcb_client_message_data_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_client_message_data_t>(),
        20usize,
        concat!("Size of: ", stringify!(xcb_client_message_data_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_client_message_data_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_client_message_data_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_client_message_data_t>())).data8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_client_message_data_t),
            "::",
            stringify!(data8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_client_message_data_t>())).data16 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_client_message_data_t),
            "::",
            stringify!(data16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_client_message_data_t>())).data32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_client_message_data_t),
            "::",
            stringify!(data32)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_client_message_data_iterator_t {
    pub data: *mut xcb_client_message_data_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_client_message_data_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_client_message_data_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_client_message_data_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_client_message_data_iterator_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_client_message_data_iterator_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_client_message_data_iterator_t>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_client_message_data_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_client_message_data_iterator_t>())).rem as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_client_message_data_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_client_message_data_iterator_t>())).index as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_client_message_data_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xcb_client_message_event_t {
    pub response_type: u8,
    pub format: u8,
    pub sequence: u16,
    pub window: xcb_window_t,
    pub type_: xcb_atom_t,
    pub data: xcb_client_message_data_t,
}
#[test]
fn bindgen_test_layout_xcb_client_message_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_client_message_event_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_client_message_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_client_message_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_client_message_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_client_message_event_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_client_message_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_client_message_event_t>())).format as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_client_message_event_t),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_client_message_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_client_message_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_client_message_event_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_client_message_event_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_client_message_event_t>())).type_ as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_client_message_event_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_client_message_event_t>())).data as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_client_message_event_t),
            "::",
            stringify!(data)
        )
    );
}
pub mod xcb_mapping_t {
    pub type Type = u32;
    pub const XCB_MAPPING_MODIFIER: Type = 0;
    pub const XCB_MAPPING_KEYBOARD: Type = 1;
    pub const XCB_MAPPING_POINTER: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_mapping_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub request: u8,
    pub first_keycode: xcb_keycode_t,
    pub count: u8,
    pub pad1: u8,
}
#[test]
fn bindgen_test_layout_xcb_mapping_notify_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_mapping_notify_event_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_mapping_notify_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_mapping_notify_event_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_mapping_notify_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_mapping_notify_event_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_mapping_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_mapping_notify_event_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_mapping_notify_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_mapping_notify_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_mapping_notify_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_mapping_notify_event_t>())).request as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_mapping_notify_event_t),
            "::",
            stringify!(request)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_mapping_notify_event_t>())).first_keycode as *const _
                as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_mapping_notify_event_t),
            "::",
            stringify!(first_keycode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_mapping_notify_event_t>())).count as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_mapping_notify_event_t),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_mapping_notify_event_t>())).pad1 as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_mapping_notify_event_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_ge_generic_event_t {
    pub response_type: u8,
    pub extension: u8,
    pub sequence: u16,
    pub length: u32,
    pub event_type: u16,
    pub pad0: [u8; 22usize],
    pub full_sequence: u32,
}
#[test]
fn bindgen_test_layout_xcb_ge_generic_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_ge_generic_event_t>(),
        36usize,
        concat!("Size of: ", stringify!(xcb_ge_generic_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_ge_generic_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_ge_generic_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_ge_generic_event_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ge_generic_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_ge_generic_event_t>())).extension as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ge_generic_event_t),
            "::",
            stringify!(extension)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_ge_generic_event_t>())).sequence as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ge_generic_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_ge_generic_event_t>())).length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ge_generic_event_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_ge_generic_event_t>())).event_type as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ge_generic_event_t),
            "::",
            stringify!(event_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_ge_generic_event_t>())).pad0 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ge_generic_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_ge_generic_event_t>())).full_sequence as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ge_generic_event_t),
            "::",
            stringify!(full_sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_request_error_t {
    pub response_type: u8,
    pub error_code: u8,
    pub sequence: u16,
    pub bad_value: u32,
    pub minor_opcode: u16,
    pub major_opcode: u8,
    pub pad0: u8,
}
#[test]
fn bindgen_test_layout_xcb_request_error_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_request_error_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_request_error_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_request_error_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_request_error_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_request_error_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_request_error_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_request_error_t>())).error_code as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_request_error_t),
            "::",
            stringify!(error_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_request_error_t>())).sequence as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_request_error_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_request_error_t>())).bad_value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_request_error_t),
            "::",
            stringify!(bad_value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_request_error_t>())).minor_opcode as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_request_error_t),
            "::",
            stringify!(minor_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_request_error_t>())).major_opcode as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_request_error_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_request_error_t>())).pad0 as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_request_error_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_value_error_t {
    pub response_type: u8,
    pub error_code: u8,
    pub sequence: u16,
    pub bad_value: u32,
    pub minor_opcode: u16,
    pub major_opcode: u8,
    pub pad0: u8,
}
#[test]
fn bindgen_test_layout_xcb_value_error_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_value_error_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_value_error_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_value_error_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_value_error_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_value_error_t>())).response_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_value_error_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_value_error_t>())).error_code as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_value_error_t),
            "::",
            stringify!(error_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_value_error_t>())).sequence as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_value_error_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_value_error_t>())).bad_value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_value_error_t),
            "::",
            stringify!(bad_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_value_error_t>())).minor_opcode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_value_error_t),
            "::",
            stringify!(minor_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_value_error_t>())).major_opcode as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_value_error_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_value_error_t>())).pad0 as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_value_error_t),
            "::",
            stringify!(pad0)
        )
    );
}
pub type xcb_window_error_t = xcb_value_error_t;
pub type xcb_pixmap_error_t = xcb_value_error_t;
pub type xcb_atom_error_t = xcb_value_error_t;
pub type xcb_cursor_error_t = xcb_value_error_t;
pub type xcb_font_error_t = xcb_value_error_t;
pub type xcb_match_error_t = xcb_request_error_t;
pub type xcb_drawable_error_t = xcb_value_error_t;
pub type xcb_access_error_t = xcb_request_error_t;
pub type xcb_alloc_error_t = xcb_request_error_t;
pub type xcb_colormap_error_t = xcb_value_error_t;
pub type xcb_g_context_error_t = xcb_value_error_t;
pub type xcb_id_choice_error_t = xcb_value_error_t;
pub type xcb_name_error_t = xcb_request_error_t;
pub type xcb_length_error_t = xcb_request_error_t;
pub type xcb_implementation_error_t = xcb_request_error_t;
pub mod xcb_window_class_t {
    pub type Type = u32;
    pub const XCB_WINDOW_CLASS_COPY_FROM_PARENT: Type = 0;
    pub const XCB_WINDOW_CLASS_INPUT_OUTPUT: Type = 1;
    pub const XCB_WINDOW_CLASS_INPUT_ONLY: Type = 2;
}
pub mod xcb_cw_t {
    pub type Type = u32;
    pub const XCB_CW_BACK_PIXMAP: Type = 1;
    pub const XCB_CW_BACK_PIXEL: Type = 2;
    pub const XCB_CW_BORDER_PIXMAP: Type = 4;
    pub const XCB_CW_BORDER_PIXEL: Type = 8;
    pub const XCB_CW_BIT_GRAVITY: Type = 16;
    pub const XCB_CW_WIN_GRAVITY: Type = 32;
    pub const XCB_CW_BACKING_STORE: Type = 64;
    pub const XCB_CW_BACKING_PLANES: Type = 128;
    pub const XCB_CW_BACKING_PIXEL: Type = 256;
    pub const XCB_CW_OVERRIDE_REDIRECT: Type = 512;
    pub const XCB_CW_SAVE_UNDER: Type = 1024;
    pub const XCB_CW_EVENT_MASK: Type = 2048;
    pub const XCB_CW_DONT_PROPAGATE: Type = 4096;
    pub const XCB_CW_COLORMAP: Type = 8192;
    pub const XCB_CW_CURSOR: Type = 16384;
}
pub mod xcb_back_pixmap_t {
    pub type Type = u32;
    pub const XCB_BACK_PIXMAP_NONE: Type = 0;
    pub const XCB_BACK_PIXMAP_PARENT_RELATIVE: Type = 1;
}
pub mod xcb_gravity_t {
    pub type Type = u32;
    pub const XCB_GRAVITY_BIT_FORGET: Type = 0;
    pub const XCB_GRAVITY_WIN_UNMAP: Type = 0;
    pub const XCB_GRAVITY_NORTH_WEST: Type = 1;
    pub const XCB_GRAVITY_NORTH: Type = 2;
    pub const XCB_GRAVITY_NORTH_EAST: Type = 3;
    pub const XCB_GRAVITY_WEST: Type = 4;
    pub const XCB_GRAVITY_CENTER: Type = 5;
    pub const XCB_GRAVITY_EAST: Type = 6;
    pub const XCB_GRAVITY_SOUTH_WEST: Type = 7;
    pub const XCB_GRAVITY_SOUTH: Type = 8;
    pub const XCB_GRAVITY_SOUTH_EAST: Type = 9;
    pub const XCB_GRAVITY_STATIC: Type = 10;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_create_window_value_list_t {
    pub background_pixmap: xcb_pixmap_t,
    pub background_pixel: u32,
    pub border_pixmap: xcb_pixmap_t,
    pub border_pixel: u32,
    pub bit_gravity: u32,
    pub win_gravity: u32,
    pub backing_store: u32,
    pub backing_planes: u32,
    pub backing_pixel: u32,
    pub override_redirect: xcb_bool32_t,
    pub save_under: xcb_bool32_t,
    pub event_mask: u32,
    pub do_not_propogate_mask: u32,
    pub colormap: xcb_colormap_t,
    pub cursor: xcb_cursor_t,
}
#[test]
fn bindgen_test_layout_xcb_create_window_value_list_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_create_window_value_list_t>(),
        60usize,
        concat!("Size of: ", stringify!(xcb_create_window_value_list_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_create_window_value_list_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_create_window_value_list_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_window_value_list_t>())).background_pixmap as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_value_list_t),
            "::",
            stringify!(background_pixmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_window_value_list_t>())).background_pixel as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_value_list_t),
            "::",
            stringify!(background_pixel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_window_value_list_t>())).border_pixmap as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_value_list_t),
            "::",
            stringify!(border_pixmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_window_value_list_t>())).border_pixel as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_value_list_t),
            "::",
            stringify!(border_pixel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_window_value_list_t>())).bit_gravity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_value_list_t),
            "::",
            stringify!(bit_gravity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_window_value_list_t>())).win_gravity as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_value_list_t),
            "::",
            stringify!(win_gravity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_window_value_list_t>())).backing_store as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_value_list_t),
            "::",
            stringify!(backing_store)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_window_value_list_t>())).backing_planes as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_value_list_t),
            "::",
            stringify!(backing_planes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_window_value_list_t>())).backing_pixel as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_value_list_t),
            "::",
            stringify!(backing_pixel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_window_value_list_t>())).override_redirect as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_value_list_t),
            "::",
            stringify!(override_redirect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_window_value_list_t>())).save_under as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_value_list_t),
            "::",
            stringify!(save_under)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_window_value_list_t>())).event_mask as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_value_list_t),
            "::",
            stringify!(event_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_window_value_list_t>())).do_not_propogate_mask
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_value_list_t),
            "::",
            stringify!(do_not_propogate_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_window_value_list_t>())).colormap as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_value_list_t),
            "::",
            stringify!(colormap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_window_value_list_t>())).cursor as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_value_list_t),
            "::",
            stringify!(cursor)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_create_window_request_t {
    pub major_opcode: u8,
    pub depth: u8,
    pub length: u16,
    pub wid: xcb_window_t,
    pub parent: xcb_window_t,
    pub x: i16,
    pub y: i16,
    pub width: u16,
    pub height: u16,
    pub border_width: u16,
    pub _class: u16,
    pub visual: xcb_visualid_t,
    pub value_mask: u32,
}
#[test]
fn bindgen_test_layout_xcb_create_window_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_create_window_request_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_create_window_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_create_window_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_create_window_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_window_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_window_request_t>())).depth as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_request_t),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_window_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_create_window_request_t>())).wid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_request_t),
            "::",
            stringify!(wid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_window_request_t>())).parent as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_request_t),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_create_window_request_t>())).x as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_request_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_create_window_request_t>())).y as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_request_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_window_request_t>())).width as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_request_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_window_request_t>())).height as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_request_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_window_request_t>())).border_width as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_request_t),
            "::",
            stringify!(border_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_window_request_t>()))._class as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_request_t),
            "::",
            stringify!(_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_window_request_t>())).visual as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_request_t),
            "::",
            stringify!(visual)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_window_request_t>())).value_mask as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_request_t),
            "::",
            stringify!(value_mask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_change_window_attributes_value_list_t {
    pub background_pixmap: xcb_pixmap_t,
    pub background_pixel: u32,
    pub border_pixmap: xcb_pixmap_t,
    pub border_pixel: u32,
    pub bit_gravity: u32,
    pub win_gravity: u32,
    pub backing_store: u32,
    pub backing_planes: u32,
    pub backing_pixel: u32,
    pub override_redirect: xcb_bool32_t,
    pub save_under: xcb_bool32_t,
    pub event_mask: u32,
    pub do_not_propogate_mask: u32,
    pub colormap: xcb_colormap_t,
    pub cursor: xcb_cursor_t,
}
#[test]
fn bindgen_test_layout_xcb_change_window_attributes_value_list_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_change_window_attributes_value_list_t>(),
        60usize,
        concat!(
            "Size of: ",
            stringify!(xcb_change_window_attributes_value_list_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_change_window_attributes_value_list_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_change_window_attributes_value_list_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_window_attributes_value_list_t>())).background_pixmap
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_value_list_t),
            "::",
            stringify!(background_pixmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_window_attributes_value_list_t>())).background_pixel
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_value_list_t),
            "::",
            stringify!(background_pixel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_window_attributes_value_list_t>())).border_pixmap
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_value_list_t),
            "::",
            stringify!(border_pixmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_window_attributes_value_list_t>())).border_pixel
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_value_list_t),
            "::",
            stringify!(border_pixel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_window_attributes_value_list_t>())).bit_gravity
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_value_list_t),
            "::",
            stringify!(bit_gravity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_window_attributes_value_list_t>())).win_gravity
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_value_list_t),
            "::",
            stringify!(win_gravity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_window_attributes_value_list_t>())).backing_store
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_value_list_t),
            "::",
            stringify!(backing_store)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_window_attributes_value_list_t>())).backing_planes
                as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_value_list_t),
            "::",
            stringify!(backing_planes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_window_attributes_value_list_t>())).backing_pixel
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_value_list_t),
            "::",
            stringify!(backing_pixel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_window_attributes_value_list_t>())).override_redirect
                as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_value_list_t),
            "::",
            stringify!(override_redirect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_window_attributes_value_list_t>())).save_under
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_value_list_t),
            "::",
            stringify!(save_under)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_window_attributes_value_list_t>())).event_mask
                as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_value_list_t),
            "::",
            stringify!(event_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_window_attributes_value_list_t>()))
                .do_not_propogate_mask as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_value_list_t),
            "::",
            stringify!(do_not_propogate_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_window_attributes_value_list_t>())).colormap
                as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_value_list_t),
            "::",
            stringify!(colormap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_window_attributes_value_list_t>())).cursor as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_value_list_t),
            "::",
            stringify!(cursor)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_change_window_attributes_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
    pub value_mask: u32,
}
#[test]
fn bindgen_test_layout_xcb_change_window_attributes_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_change_window_attributes_request_t>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(xcb_change_window_attributes_request_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_change_window_attributes_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_change_window_attributes_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_window_attributes_request_t>())).major_opcode
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_window_attributes_request_t>())).pad0 as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_window_attributes_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_window_attributes_request_t>())).window as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_request_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_window_attributes_request_t>())).value_mask
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_request_t),
            "::",
            stringify!(value_mask)
        )
    );
}
pub mod xcb_map_state_t {
    pub type Type = u32;
    pub const XCB_MAP_STATE_UNMAPPED: Type = 0;
    pub const XCB_MAP_STATE_UNVIEWABLE: Type = 1;
    pub const XCB_MAP_STATE_VIEWABLE: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_window_attributes_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_window_attributes_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_window_attributes_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_window_attributes_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_window_attributes_cookie_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_window_attributes_cookie_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_window_attributes_cookie_t>())).sequence as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_window_attributes_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_get_window_attributes_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_window_attributes_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_get_window_attributes_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_window_attributes_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_window_attributes_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_window_attributes_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_window_attributes_request_t>())).pad0 as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_window_attributes_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_window_attributes_request_t>())).window as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_request_t),
            "::",
            stringify!(window)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_window_attributes_reply_t {
    pub response_type: u8,
    pub backing_store: u8,
    pub sequence: u16,
    pub length: u32,
    pub visual: xcb_visualid_t,
    pub _class: u16,
    pub bit_gravity: u8,
    pub win_gravity: u8,
    pub backing_planes: u32,
    pub backing_pixel: u32,
    pub save_under: u8,
    pub map_is_installed: u8,
    pub map_state: u8,
    pub override_redirect: u8,
    pub colormap: xcb_colormap_t,
    pub all_event_masks: u32,
    pub your_event_mask: u32,
    pub do_not_propagate_mask: u16,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_get_window_attributes_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_window_attributes_reply_t>(),
        44usize,
        concat!("Size of: ", stringify!(xcb_get_window_attributes_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_window_attributes_reply_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_window_attributes_reply_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_window_attributes_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_window_attributes_reply_t>())).backing_store as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(backing_store)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_window_attributes_reply_t>())).sequence as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_window_attributes_reply_t>())).length as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_window_attributes_reply_t>())).visual as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(visual)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_window_attributes_reply_t>()))._class as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_window_attributes_reply_t>())).bit_gravity as *const _
                as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(bit_gravity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_window_attributes_reply_t>())).win_gravity as *const _
                as usize
        },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(win_gravity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_window_attributes_reply_t>())).backing_planes as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(backing_planes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_window_attributes_reply_t>())).backing_pixel as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(backing_pixel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_window_attributes_reply_t>())).save_under as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(save_under)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_window_attributes_reply_t>())).map_is_installed
                as *const _ as usize
        },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(map_is_installed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_window_attributes_reply_t>())).map_state as *const _
                as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(map_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_window_attributes_reply_t>())).override_redirect
                as *const _ as usize
        },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(override_redirect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_window_attributes_reply_t>())).colormap as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(colormap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_window_attributes_reply_t>())).all_event_masks
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(all_event_masks)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_window_attributes_reply_t>())).your_event_mask
                as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(your_event_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_window_attributes_reply_t>())).do_not_propagate_mask
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(do_not_propagate_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_window_attributes_reply_t>())).pad0 as *const _ as usize
        },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_destroy_window_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_destroy_window_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_destroy_window_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_destroy_window_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_destroy_window_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_destroy_window_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_destroy_window_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_destroy_window_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_destroy_window_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_destroy_window_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_destroy_window_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_destroy_window_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_destroy_window_request_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_destroy_window_request_t),
            "::",
            stringify!(window)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_destroy_subwindows_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_destroy_subwindows_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_destroy_subwindows_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_destroy_subwindows_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_destroy_subwindows_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_destroy_subwindows_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_destroy_subwindows_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_destroy_subwindows_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_destroy_subwindows_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_destroy_subwindows_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_destroy_subwindows_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_destroy_subwindows_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_destroy_subwindows_request_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_destroy_subwindows_request_t),
            "::",
            stringify!(window)
        )
    );
}
pub mod xcb_set_mode_t {
    pub type Type = u32;
    pub const XCB_SET_MODE_INSERT: Type = 0;
    pub const XCB_SET_MODE_DELETE: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_change_save_set_request_t {
    pub major_opcode: u8,
    pub mode: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_change_save_set_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_change_save_set_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_change_save_set_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_change_save_set_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_change_save_set_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_save_set_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_save_set_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_save_set_request_t>())).mode as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_save_set_request_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_save_set_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_save_set_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_save_set_request_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_save_set_request_t),
            "::",
            stringify!(window)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_reparent_window_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
    pub parent: xcb_window_t,
    pub x: i16,
    pub y: i16,
}
#[test]
fn bindgen_test_layout_xcb_reparent_window_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_reparent_window_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_reparent_window_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_reparent_window_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_reparent_window_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_reparent_window_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_window_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_reparent_window_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_window_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_reparent_window_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_window_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_reparent_window_request_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_window_request_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_reparent_window_request_t>())).parent as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_window_request_t),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_reparent_window_request_t>())).x as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_window_request_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_reparent_window_request_t>())).y as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_window_request_t),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_map_window_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_map_window_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_map_window_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_map_window_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_map_window_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_map_window_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_map_window_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_window_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_map_window_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_window_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_map_window_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_window_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_map_window_request_t>())).window as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_window_request_t),
            "::",
            stringify!(window)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_map_subwindows_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_map_subwindows_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_map_subwindows_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_map_subwindows_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_map_subwindows_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_map_subwindows_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_map_subwindows_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_subwindows_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_map_subwindows_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_subwindows_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_map_subwindows_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_subwindows_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_map_subwindows_request_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_subwindows_request_t),
            "::",
            stringify!(window)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_unmap_window_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_unmap_window_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_unmap_window_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_unmap_window_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_unmap_window_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_unmap_window_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_unmap_window_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_unmap_window_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_unmap_window_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_unmap_window_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_unmap_window_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_unmap_window_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_unmap_window_request_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_unmap_window_request_t),
            "::",
            stringify!(window)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_unmap_subwindows_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_unmap_subwindows_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_unmap_subwindows_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_unmap_subwindows_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_unmap_subwindows_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_unmap_subwindows_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_unmap_subwindows_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_unmap_subwindows_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_unmap_subwindows_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_unmap_subwindows_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_unmap_subwindows_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_unmap_subwindows_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_unmap_subwindows_request_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_unmap_subwindows_request_t),
            "::",
            stringify!(window)
        )
    );
}
pub mod xcb_config_window_t {
    pub type Type = u32;
    pub const XCB_CONFIG_WINDOW_X: Type = 1;
    pub const XCB_CONFIG_WINDOW_Y: Type = 2;
    pub const XCB_CONFIG_WINDOW_WIDTH: Type = 4;
    pub const XCB_CONFIG_WINDOW_HEIGHT: Type = 8;
    pub const XCB_CONFIG_WINDOW_BORDER_WIDTH: Type = 16;
    pub const XCB_CONFIG_WINDOW_SIBLING: Type = 32;
    pub const XCB_CONFIG_WINDOW_STACK_MODE: Type = 64;
}
pub mod xcb_stack_mode_t {
    pub type Type = u32;
    pub const XCB_STACK_MODE_ABOVE: Type = 0;
    pub const XCB_STACK_MODE_BELOW: Type = 1;
    pub const XCB_STACK_MODE_TOP_IF: Type = 2;
    pub const XCB_STACK_MODE_BOTTOM_IF: Type = 3;
    pub const XCB_STACK_MODE_OPPOSITE: Type = 4;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_configure_window_value_list_t {
    pub x: i32,
    pub y: i32,
    pub width: u32,
    pub height: u32,
    pub border_width: u32,
    pub sibling: xcb_window_t,
    pub stack_mode: u32,
}
#[test]
fn bindgen_test_layout_xcb_configure_window_value_list_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_configure_window_value_list_t>(),
        28usize,
        concat!("Size of: ", stringify!(xcb_configure_window_value_list_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_configure_window_value_list_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_configure_window_value_list_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_window_value_list_t>())).x as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_window_value_list_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_window_value_list_t>())).y as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_window_value_list_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_window_value_list_t>())).width as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_window_value_list_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_window_value_list_t>())).height as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_window_value_list_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_window_value_list_t>())).border_width as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_window_value_list_t),
            "::",
            stringify!(border_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_window_value_list_t>())).sibling as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_window_value_list_t),
            "::",
            stringify!(sibling)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_window_value_list_t>())).stack_mode as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_window_value_list_t),
            "::",
            stringify!(stack_mode)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_configure_window_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
    pub value_mask: u16,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_configure_window_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_configure_window_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_configure_window_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_configure_window_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_configure_window_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_window_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_window_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_window_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_window_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_window_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_window_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_window_request_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_window_request_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_window_request_t>())).value_mask as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_window_request_t),
            "::",
            stringify!(value_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_window_request_t>())).pad1 as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_window_request_t),
            "::",
            stringify!(pad1)
        )
    );
}
pub mod xcb_circulate_t {
    pub type Type = u32;
    pub const XCB_CIRCULATE_RAISE_LOWEST: Type = 0;
    pub const XCB_CIRCULATE_LOWER_HIGHEST: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_circulate_window_request_t {
    pub major_opcode: u8,
    pub direction: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_circulate_window_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_circulate_window_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_circulate_window_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_circulate_window_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_circulate_window_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_circulate_window_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_circulate_window_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_circulate_window_request_t>())).direction as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_circulate_window_request_t),
            "::",
            stringify!(direction)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_circulate_window_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_circulate_window_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_circulate_window_request_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_circulate_window_request_t),
            "::",
            stringify!(window)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_geometry_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_geometry_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_geometry_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_geometry_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_geometry_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_geometry_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_geometry_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_geometry_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
}
#[test]
fn bindgen_test_layout_xcb_get_geometry_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_geometry_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_get_geometry_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_geometry_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_geometry_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_geometry_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_get_geometry_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_geometry_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_geometry_request_t>())).drawable as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_request_t),
            "::",
            stringify!(drawable)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_geometry_reply_t {
    pub response_type: u8,
    pub depth: u8,
    pub sequence: u16,
    pub length: u32,
    pub root: xcb_window_t,
    pub x: i16,
    pub y: i16,
    pub width: u16,
    pub height: u16,
    pub border_width: u16,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_get_geometry_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_geometry_reply_t>(),
        24usize,
        concat!("Size of: ", stringify!(xcb_get_geometry_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_geometry_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_geometry_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_geometry_reply_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_get_geometry_reply_t>())).depth as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_reply_t),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_geometry_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_get_geometry_reply_t>())).length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_get_geometry_reply_t>())).root as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_reply_t),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_get_geometry_reply_t>())).x as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_reply_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_get_geometry_reply_t>())).y as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_reply_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_get_geometry_reply_t>())).width as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_reply_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_get_geometry_reply_t>())).height as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_reply_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_geometry_reply_t>())).border_width as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_reply_t),
            "::",
            stringify!(border_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_get_geometry_reply_t>())).pad0 as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_reply_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_tree_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_query_tree_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_query_tree_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_query_tree_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_tree_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_tree_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_tree_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_tree_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_tree_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_query_tree_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_query_tree_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_query_tree_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_tree_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_tree_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_tree_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_tree_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_tree_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_tree_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_tree_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_tree_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_tree_request_t>())).window as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_tree_request_t),
            "::",
            stringify!(window)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_tree_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub root: xcb_window_t,
    pub parent: xcb_window_t,
    pub children_len: u16,
    pub pad1: [u8; 14usize],
}
#[test]
fn bindgen_test_layout_xcb_query_tree_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_query_tree_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_query_tree_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_tree_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_tree_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_tree_reply_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_tree_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_tree_reply_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_tree_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_tree_reply_t>())).sequence as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_tree_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_tree_reply_t>())).length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_tree_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_tree_reply_t>())).root as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_tree_reply_t),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_tree_reply_t>())).parent as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_tree_reply_t),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_tree_reply_t>())).children_len as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_tree_reply_t),
            "::",
            stringify!(children_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_tree_reply_t>())).pad1 as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_tree_reply_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_intern_atom_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_intern_atom_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_intern_atom_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_intern_atom_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_intern_atom_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_intern_atom_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_intern_atom_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_intern_atom_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_intern_atom_request_t {
    pub major_opcode: u8,
    pub only_if_exists: u8,
    pub length: u16,
    pub name_len: u16,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_intern_atom_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_intern_atom_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_intern_atom_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_intern_atom_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_intern_atom_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_intern_atom_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_intern_atom_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_intern_atom_request_t>())).only_if_exists as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_intern_atom_request_t),
            "::",
            stringify!(only_if_exists)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_intern_atom_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_intern_atom_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_intern_atom_request_t>())).name_len as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_intern_atom_request_t),
            "::",
            stringify!(name_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_intern_atom_request_t>())).pad0 as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_intern_atom_request_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_intern_atom_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub atom: xcb_atom_t,
}
#[test]
fn bindgen_test_layout_xcb_intern_atom_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_intern_atom_reply_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_intern_atom_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_intern_atom_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_intern_atom_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_intern_atom_reply_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_intern_atom_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_intern_atom_reply_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_intern_atom_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_intern_atom_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_intern_atom_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_intern_atom_reply_t>())).length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_intern_atom_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_intern_atom_reply_t>())).atom as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_intern_atom_reply_t),
            "::",
            stringify!(atom)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_atom_name_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_atom_name_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_atom_name_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_atom_name_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_atom_name_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_atom_name_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_atom_name_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_atom_name_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_atom_name_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub atom: xcb_atom_t,
}
#[test]
fn bindgen_test_layout_xcb_get_atom_name_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_atom_name_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_get_atom_name_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_atom_name_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_atom_name_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_atom_name_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_atom_name_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_atom_name_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_atom_name_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_atom_name_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_atom_name_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_atom_name_request_t>())).atom as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_atom_name_request_t),
            "::",
            stringify!(atom)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_atom_name_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub name_len: u16,
    pub pad1: [u8; 22usize],
}
#[test]
fn bindgen_test_layout_xcb_get_atom_name_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_atom_name_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_get_atom_name_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_atom_name_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_atom_name_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_atom_name_reply_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_atom_name_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_get_atom_name_reply_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_atom_name_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_atom_name_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_atom_name_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_atom_name_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_atom_name_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_atom_name_reply_t>())).name_len as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_atom_name_reply_t),
            "::",
            stringify!(name_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_get_atom_name_reply_t>())).pad1 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_atom_name_reply_t),
            "::",
            stringify!(pad1)
        )
    );
}
pub mod xcb_prop_mode_t {
    pub type Type = u32;
    pub const XCB_PROP_MODE_REPLACE: Type = 0;
    pub const XCB_PROP_MODE_PREPEND: Type = 1;
    pub const XCB_PROP_MODE_APPEND: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_change_property_request_t {
    pub major_opcode: u8,
    pub mode: u8,
    pub length: u16,
    pub window: xcb_window_t,
    pub property: xcb_atom_t,
    pub type_: xcb_atom_t,
    pub format: u8,
    pub pad0: [u8; 3usize],
    pub data_len: u32,
}
#[test]
fn bindgen_test_layout_xcb_change_property_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_change_property_request_t>(),
        24usize,
        concat!("Size of: ", stringify!(xcb_change_property_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_change_property_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_change_property_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_property_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_property_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_property_request_t>())).mode as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_property_request_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_property_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_property_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_property_request_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_property_request_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_property_request_t>())).property as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_property_request_t),
            "::",
            stringify!(property)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_property_request_t>())).type_ as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_property_request_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_property_request_t>())).format as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_property_request_t),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_property_request_t>())).pad0 as *const _ as usize
        },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_property_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_property_request_t>())).data_len as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_property_request_t),
            "::",
            stringify!(data_len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_delete_property_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
    pub property: xcb_atom_t,
}
#[test]
fn bindgen_test_layout_xcb_delete_property_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_delete_property_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_delete_property_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_delete_property_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_delete_property_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_delete_property_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_delete_property_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_delete_property_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_delete_property_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_delete_property_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_delete_property_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_delete_property_request_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_delete_property_request_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_delete_property_request_t>())).property as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_delete_property_request_t),
            "::",
            stringify!(property)
        )
    );
}
pub mod xcb_get_property_type_t {
    pub type Type = u32;
    pub const XCB_GET_PROPERTY_TYPE_ANY: Type = 0;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_property_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_property_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_property_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_property_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_property_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_property_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_property_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_property_request_t {
    pub major_opcode: u8,
    pub _delete: u8,
    pub length: u16,
    pub window: xcb_window_t,
    pub property: xcb_atom_t,
    pub type_: xcb_atom_t,
    pub long_offset: u32,
    pub long_length: u32,
}
#[test]
fn bindgen_test_layout_xcb_get_property_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_property_request_t>(),
        24usize,
        concat!("Size of: ", stringify!(xcb_get_property_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_property_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_property_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_property_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_property_request_t>()))._delete as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_request_t),
            "::",
            stringify!(_delete)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_property_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_property_request_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_request_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_property_request_t>())).property as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_request_t),
            "::",
            stringify!(property)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_property_request_t>())).type_ as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_request_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_property_request_t>())).long_offset as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_request_t),
            "::",
            stringify!(long_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_property_request_t>())).long_length as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_request_t),
            "::",
            stringify!(long_length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_property_reply_t {
    pub response_type: u8,
    pub format: u8,
    pub sequence: u16,
    pub length: u32,
    pub type_: xcb_atom_t,
    pub bytes_after: u32,
    pub value_len: u32,
    pub pad0: [u8; 12usize],
}
#[test]
fn bindgen_test_layout_xcb_get_property_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_property_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_get_property_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_property_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_property_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_property_reply_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_get_property_reply_t>())).format as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_reply_t),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_property_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_get_property_reply_t>())).length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_get_property_reply_t>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_reply_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_property_reply_t>())).bytes_after as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_reply_t),
            "::",
            stringify!(bytes_after)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_property_reply_t>())).value_len as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_reply_t),
            "::",
            stringify!(value_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_get_property_reply_t>())).pad0 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_reply_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_properties_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_list_properties_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_list_properties_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_list_properties_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_list_properties_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_list_properties_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_properties_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_properties_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_properties_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_list_properties_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_list_properties_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_list_properties_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_list_properties_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_list_properties_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_properties_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_properties_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_properties_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_properties_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_properties_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_properties_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_properties_request_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_properties_request_t),
            "::",
            stringify!(window)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_properties_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub atoms_len: u16,
    pub pad1: [u8; 22usize],
}
#[test]
fn bindgen_test_layout_xcb_list_properties_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_list_properties_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_list_properties_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_list_properties_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_list_properties_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_properties_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_properties_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_properties_reply_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_properties_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_properties_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_properties_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_properties_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_properties_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_properties_reply_t>())).atoms_len as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_properties_reply_t),
            "::",
            stringify!(atoms_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_properties_reply_t>())).pad1 as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_properties_reply_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_set_selection_owner_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub owner: xcb_window_t,
    pub selection: xcb_atom_t,
    pub time: xcb_timestamp_t,
}
#[test]
fn bindgen_test_layout_xcb_set_selection_owner_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_set_selection_owner_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_set_selection_owner_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_set_selection_owner_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_set_selection_owner_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_selection_owner_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_selection_owner_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_selection_owner_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_selection_owner_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_selection_owner_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_selection_owner_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_selection_owner_request_t>())).owner as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_selection_owner_request_t),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_selection_owner_request_t>())).selection as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_selection_owner_request_t),
            "::",
            stringify!(selection)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_selection_owner_request_t>())).time as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_selection_owner_request_t),
            "::",
            stringify!(time)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_selection_owner_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_selection_owner_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_selection_owner_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_selection_owner_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_selection_owner_cookie_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_selection_owner_cookie_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_selection_owner_cookie_t>())).sequence as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_selection_owner_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_selection_owner_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub selection: xcb_atom_t,
}
#[test]
fn bindgen_test_layout_xcb_get_selection_owner_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_selection_owner_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_get_selection_owner_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_selection_owner_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_selection_owner_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_selection_owner_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_selection_owner_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_selection_owner_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_selection_owner_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_selection_owner_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_selection_owner_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_selection_owner_request_t>())).selection as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_selection_owner_request_t),
            "::",
            stringify!(selection)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_selection_owner_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub owner: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_get_selection_owner_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_selection_owner_reply_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_get_selection_owner_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_selection_owner_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_selection_owner_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_selection_owner_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_selection_owner_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_selection_owner_reply_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_selection_owner_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_selection_owner_reply_t>())).sequence as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_selection_owner_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_selection_owner_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_selection_owner_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_selection_owner_reply_t>())).owner as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_selection_owner_reply_t),
            "::",
            stringify!(owner)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_convert_selection_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub requestor: xcb_window_t,
    pub selection: xcb_atom_t,
    pub target: xcb_atom_t,
    pub property: xcb_atom_t,
    pub time: xcb_timestamp_t,
}
#[test]
fn bindgen_test_layout_xcb_convert_selection_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_convert_selection_request_t>(),
        24usize,
        concat!("Size of: ", stringify!(xcb_convert_selection_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_convert_selection_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_convert_selection_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_convert_selection_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_convert_selection_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_convert_selection_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_convert_selection_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_convert_selection_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_convert_selection_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_convert_selection_request_t>())).requestor as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_convert_selection_request_t),
            "::",
            stringify!(requestor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_convert_selection_request_t>())).selection as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_convert_selection_request_t),
            "::",
            stringify!(selection)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_convert_selection_request_t>())).target as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_convert_selection_request_t),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_convert_selection_request_t>())).property as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_convert_selection_request_t),
            "::",
            stringify!(property)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_convert_selection_request_t>())).time as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_convert_selection_request_t),
            "::",
            stringify!(time)
        )
    );
}
pub mod xcb_send_event_dest_t {
    pub type Type = u32;
    pub const XCB_SEND_EVENT_DEST_POINTER_WINDOW: Type = 0;
    pub const XCB_SEND_EVENT_DEST_ITEM_FOCUS: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_send_event_request_t {
    pub major_opcode: u8,
    pub propagate: u8,
    pub length: u16,
    pub destination: xcb_window_t,
    pub event_mask: u32,
    pub event: [::std::os::raw::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_xcb_send_event_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_send_event_request_t>(),
        44usize,
        concat!("Size of: ", stringify!(xcb_send_event_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_send_event_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_send_event_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_send_event_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_send_event_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_send_event_request_t>())).propagate as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_send_event_request_t),
            "::",
            stringify!(propagate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_send_event_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_send_event_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_send_event_request_t>())).destination as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_send_event_request_t),
            "::",
            stringify!(destination)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_send_event_request_t>())).event_mask as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_send_event_request_t),
            "::",
            stringify!(event_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_send_event_request_t>())).event as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_send_event_request_t),
            "::",
            stringify!(event)
        )
    );
}
pub mod xcb_grab_mode_t {
    pub type Type = u32;
    pub const XCB_GRAB_MODE_SYNC: Type = 0;
    pub const XCB_GRAB_MODE_ASYNC: Type = 1;
}
pub mod xcb_grab_status_t {
    pub type Type = u32;
    pub const XCB_GRAB_STATUS_SUCCESS: Type = 0;
    pub const XCB_GRAB_STATUS_ALREADY_GRABBED: Type = 1;
    pub const XCB_GRAB_STATUS_INVALID_TIME: Type = 2;
    pub const XCB_GRAB_STATUS_NOT_VIEWABLE: Type = 3;
    pub const XCB_GRAB_STATUS_FROZEN: Type = 4;
}
pub mod xcb_cursor_enum_t {
    pub type Type = u32;
    pub const XCB_CURSOR_NONE: Type = 0;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_grab_pointer_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_grab_pointer_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_grab_pointer_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_grab_pointer_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_grab_pointer_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_grab_pointer_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_pointer_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_pointer_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_grab_pointer_request_t {
    pub major_opcode: u8,
    pub owner_events: u8,
    pub length: u16,
    pub grab_window: xcb_window_t,
    pub event_mask: u16,
    pub pointer_mode: u8,
    pub keyboard_mode: u8,
    pub confine_to: xcb_window_t,
    pub cursor: xcb_cursor_t,
    pub time: xcb_timestamp_t,
}
#[test]
fn bindgen_test_layout_xcb_grab_pointer_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_grab_pointer_request_t>(),
        24usize,
        concat!("Size of: ", stringify!(xcb_grab_pointer_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_grab_pointer_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_grab_pointer_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_pointer_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_pointer_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_pointer_request_t>())).owner_events as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_pointer_request_t),
            "::",
            stringify!(owner_events)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_pointer_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_pointer_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_pointer_request_t>())).grab_window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_pointer_request_t),
            "::",
            stringify!(grab_window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_pointer_request_t>())).event_mask as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_pointer_request_t),
            "::",
            stringify!(event_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_pointer_request_t>())).pointer_mode as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_pointer_request_t),
            "::",
            stringify!(pointer_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_pointer_request_t>())).keyboard_mode as *const _
                as usize
        },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_pointer_request_t),
            "::",
            stringify!(keyboard_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_pointer_request_t>())).confine_to as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_pointer_request_t),
            "::",
            stringify!(confine_to)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_pointer_request_t>())).cursor as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_pointer_request_t),
            "::",
            stringify!(cursor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_grab_pointer_request_t>())).time as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_pointer_request_t),
            "::",
            stringify!(time)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_grab_pointer_reply_t {
    pub response_type: u8,
    pub status: u8,
    pub sequence: u16,
    pub length: u32,
}
#[test]
fn bindgen_test_layout_xcb_grab_pointer_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_grab_pointer_reply_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_grab_pointer_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_grab_pointer_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_grab_pointer_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_pointer_reply_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_pointer_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_grab_pointer_reply_t>())).status as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_pointer_reply_t),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_pointer_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_pointer_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_grab_pointer_reply_t>())).length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_pointer_reply_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_ungrab_pointer_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub time: xcb_timestamp_t,
}
#[test]
fn bindgen_test_layout_xcb_ungrab_pointer_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_ungrab_pointer_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_ungrab_pointer_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_ungrab_pointer_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_ungrab_pointer_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_ungrab_pointer_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_pointer_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_ungrab_pointer_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_pointer_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_ungrab_pointer_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_pointer_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_ungrab_pointer_request_t>())).time as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_pointer_request_t),
            "::",
            stringify!(time)
        )
    );
}
pub mod xcb_button_index_t {
    pub type Type = u32;
    pub const XCB_BUTTON_INDEX_ANY: Type = 0;
    pub const XCB_BUTTON_INDEX_1: Type = 1;
    pub const XCB_BUTTON_INDEX_2: Type = 2;
    pub const XCB_BUTTON_INDEX_3: Type = 3;
    pub const XCB_BUTTON_INDEX_4: Type = 4;
    pub const XCB_BUTTON_INDEX_5: Type = 5;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_grab_button_request_t {
    pub major_opcode: u8,
    pub owner_events: u8,
    pub length: u16,
    pub grab_window: xcb_window_t,
    pub event_mask: u16,
    pub pointer_mode: u8,
    pub keyboard_mode: u8,
    pub confine_to: xcb_window_t,
    pub cursor: xcb_cursor_t,
    pub button: u8,
    pub pad0: u8,
    pub modifiers: u16,
}
#[test]
fn bindgen_test_layout_xcb_grab_button_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_grab_button_request_t>(),
        24usize,
        concat!("Size of: ", stringify!(xcb_grab_button_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_grab_button_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_grab_button_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_button_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_button_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_button_request_t>())).owner_events as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_button_request_t),
            "::",
            stringify!(owner_events)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_button_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_button_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_button_request_t>())).grab_window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_button_request_t),
            "::",
            stringify!(grab_window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_button_request_t>())).event_mask as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_button_request_t),
            "::",
            stringify!(event_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_button_request_t>())).pointer_mode as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_button_request_t),
            "::",
            stringify!(pointer_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_button_request_t>())).keyboard_mode as *const _ as usize
        },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_button_request_t),
            "::",
            stringify!(keyboard_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_button_request_t>())).confine_to as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_button_request_t),
            "::",
            stringify!(confine_to)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_button_request_t>())).cursor as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_button_request_t),
            "::",
            stringify!(cursor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_button_request_t>())).button as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_button_request_t),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_grab_button_request_t>())).pad0 as *const _ as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_button_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_button_request_t>())).modifiers as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_button_request_t),
            "::",
            stringify!(modifiers)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_ungrab_button_request_t {
    pub major_opcode: u8,
    pub button: u8,
    pub length: u16,
    pub grab_window: xcb_window_t,
    pub modifiers: u16,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_ungrab_button_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_ungrab_button_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_ungrab_button_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_ungrab_button_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_ungrab_button_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_ungrab_button_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_button_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_ungrab_button_request_t>())).button as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_button_request_t),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_ungrab_button_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_button_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_ungrab_button_request_t>())).grab_window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_button_request_t),
            "::",
            stringify!(grab_window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_ungrab_button_request_t>())).modifiers as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_button_request_t),
            "::",
            stringify!(modifiers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_ungrab_button_request_t>())).pad0 as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_button_request_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_change_active_pointer_grab_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cursor: xcb_cursor_t,
    pub time: xcb_timestamp_t,
    pub event_mask: u16,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_change_active_pointer_grab_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_change_active_pointer_grab_request_t>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(xcb_change_active_pointer_grab_request_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_change_active_pointer_grab_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_change_active_pointer_grab_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_active_pointer_grab_request_t>())).major_opcode
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_active_pointer_grab_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_active_pointer_grab_request_t>())).pad0 as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_active_pointer_grab_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_active_pointer_grab_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_active_pointer_grab_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_active_pointer_grab_request_t>())).cursor as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_active_pointer_grab_request_t),
            "::",
            stringify!(cursor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_active_pointer_grab_request_t>())).time as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_active_pointer_grab_request_t),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_active_pointer_grab_request_t>())).event_mask
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_active_pointer_grab_request_t),
            "::",
            stringify!(event_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_active_pointer_grab_request_t>())).pad1 as *const _
                as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_active_pointer_grab_request_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_grab_keyboard_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_grab_keyboard_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_grab_keyboard_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_grab_keyboard_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_grab_keyboard_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_grab_keyboard_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_keyboard_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_keyboard_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_grab_keyboard_request_t {
    pub major_opcode: u8,
    pub owner_events: u8,
    pub length: u16,
    pub grab_window: xcb_window_t,
    pub time: xcb_timestamp_t,
    pub pointer_mode: u8,
    pub keyboard_mode: u8,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_grab_keyboard_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_grab_keyboard_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_grab_keyboard_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_grab_keyboard_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_grab_keyboard_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_keyboard_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_keyboard_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_keyboard_request_t>())).owner_events as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_keyboard_request_t),
            "::",
            stringify!(owner_events)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_keyboard_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_keyboard_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_keyboard_request_t>())).grab_window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_keyboard_request_t),
            "::",
            stringify!(grab_window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_keyboard_request_t>())).time as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_keyboard_request_t),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_keyboard_request_t>())).pointer_mode as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_keyboard_request_t),
            "::",
            stringify!(pointer_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_keyboard_request_t>())).keyboard_mode as *const _
                as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_keyboard_request_t),
            "::",
            stringify!(keyboard_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_keyboard_request_t>())).pad0 as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_keyboard_request_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_grab_keyboard_reply_t {
    pub response_type: u8,
    pub status: u8,
    pub sequence: u16,
    pub length: u32,
}
#[test]
fn bindgen_test_layout_xcb_grab_keyboard_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_grab_keyboard_reply_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_grab_keyboard_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_grab_keyboard_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_grab_keyboard_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_keyboard_reply_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_keyboard_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_keyboard_reply_t>())).status as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_keyboard_reply_t),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_keyboard_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_keyboard_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_keyboard_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_keyboard_reply_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_ungrab_keyboard_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub time: xcb_timestamp_t,
}
#[test]
fn bindgen_test_layout_xcb_ungrab_keyboard_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_ungrab_keyboard_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_ungrab_keyboard_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_ungrab_keyboard_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_ungrab_keyboard_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_ungrab_keyboard_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_keyboard_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_ungrab_keyboard_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_keyboard_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_ungrab_keyboard_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_keyboard_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_ungrab_keyboard_request_t>())).time as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_keyboard_request_t),
            "::",
            stringify!(time)
        )
    );
}
pub mod xcb_grab_t {
    pub type Type = u32;
    pub const XCB_GRAB_ANY: Type = 0;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_grab_key_request_t {
    pub major_opcode: u8,
    pub owner_events: u8,
    pub length: u16,
    pub grab_window: xcb_window_t,
    pub modifiers: u16,
    pub key: xcb_keycode_t,
    pub pointer_mode: u8,
    pub keyboard_mode: u8,
    pub pad0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_grab_key_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_grab_key_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_grab_key_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_grab_key_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_grab_key_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_key_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_key_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_key_request_t>())).owner_events as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_key_request_t),
            "::",
            stringify!(owner_events)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_grab_key_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_key_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_key_request_t>())).grab_window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_key_request_t),
            "::",
            stringify!(grab_window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_key_request_t>())).modifiers as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_key_request_t),
            "::",
            stringify!(modifiers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_grab_key_request_t>())).key as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_key_request_t),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_key_request_t>())).pointer_mode as *const _ as usize
        },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_key_request_t),
            "::",
            stringify!(pointer_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_key_request_t>())).keyboard_mode as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_key_request_t),
            "::",
            stringify!(keyboard_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_grab_key_request_t>())).pad0 as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_key_request_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_ungrab_key_request_t {
    pub major_opcode: u8,
    pub key: xcb_keycode_t,
    pub length: u16,
    pub grab_window: xcb_window_t,
    pub modifiers: u16,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_ungrab_key_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_ungrab_key_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_ungrab_key_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_ungrab_key_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_ungrab_key_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_ungrab_key_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_key_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_ungrab_key_request_t>())).key as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_key_request_t),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_ungrab_key_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_key_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_ungrab_key_request_t>())).grab_window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_key_request_t),
            "::",
            stringify!(grab_window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_ungrab_key_request_t>())).modifiers as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_key_request_t),
            "::",
            stringify!(modifiers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_ungrab_key_request_t>())).pad0 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_key_request_t),
            "::",
            stringify!(pad0)
        )
    );
}
pub mod xcb_allow_t {
    pub type Type = u32;
    pub const XCB_ALLOW_ASYNC_POINTER: Type = 0;
    pub const XCB_ALLOW_SYNC_POINTER: Type = 1;
    pub const XCB_ALLOW_REPLAY_POINTER: Type = 2;
    pub const XCB_ALLOW_ASYNC_KEYBOARD: Type = 3;
    pub const XCB_ALLOW_SYNC_KEYBOARD: Type = 4;
    pub const XCB_ALLOW_REPLAY_KEYBOARD: Type = 5;
    pub const XCB_ALLOW_ASYNC_BOTH: Type = 6;
    pub const XCB_ALLOW_SYNC_BOTH: Type = 7;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_allow_events_request_t {
    pub major_opcode: u8,
    pub mode: u8,
    pub length: u16,
    pub time: xcb_timestamp_t,
}
#[test]
fn bindgen_test_layout_xcb_allow_events_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_allow_events_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_allow_events_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_allow_events_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_allow_events_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_allow_events_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_allow_events_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_allow_events_request_t>())).mode as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_allow_events_request_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_allow_events_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_allow_events_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_allow_events_request_t>())).time as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_allow_events_request_t),
            "::",
            stringify!(time)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_grab_server_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_grab_server_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_grab_server_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_grab_server_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_grab_server_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_grab_server_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_server_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_server_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_grab_server_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_server_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_server_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_server_request_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_ungrab_server_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_ungrab_server_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_ungrab_server_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_ungrab_server_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_ungrab_server_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_ungrab_server_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_ungrab_server_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_server_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_ungrab_server_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_server_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_ungrab_server_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_server_request_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_pointer_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_query_pointer_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_query_pointer_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_query_pointer_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_pointer_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_pointer_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_pointer_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_pointer_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_query_pointer_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_query_pointer_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_query_pointer_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_pointer_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_pointer_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_pointer_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_pointer_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_pointer_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_pointer_request_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_request_t),
            "::",
            stringify!(window)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_pointer_reply_t {
    pub response_type: u8,
    pub same_screen: u8,
    pub sequence: u16,
    pub length: u32,
    pub root: xcb_window_t,
    pub child: xcb_window_t,
    pub root_x: i16,
    pub root_y: i16,
    pub win_x: i16,
    pub win_y: i16,
    pub mask: u16,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_query_pointer_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_query_pointer_reply_t>(),
        28usize,
        concat!("Size of: ", stringify!(xcb_query_pointer_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_pointer_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_pointer_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_pointer_reply_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_pointer_reply_t>())).same_screen as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_reply_t),
            "::",
            stringify!(same_screen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_pointer_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_pointer_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_pointer_reply_t>())).root as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_reply_t),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_pointer_reply_t>())).child as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_reply_t),
            "::",
            stringify!(child)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_pointer_reply_t>())).root_x as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_reply_t),
            "::",
            stringify!(root_x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_pointer_reply_t>())).root_y as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_reply_t),
            "::",
            stringify!(root_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_pointer_reply_t>())).win_x as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_reply_t),
            "::",
            stringify!(win_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_pointer_reply_t>())).win_y as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_reply_t),
            "::",
            stringify!(win_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_pointer_reply_t>())).mask as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_reply_t),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_pointer_reply_t>())).pad0 as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_reply_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_timecoord_t {
    pub time: xcb_timestamp_t,
    pub x: i16,
    pub y: i16,
}
#[test]
fn bindgen_test_layout_xcb_timecoord_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_timecoord_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_timecoord_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_timecoord_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_timecoord_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_timecoord_t>())).time as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_timecoord_t),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_timecoord_t>())).x as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_timecoord_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_timecoord_t>())).y as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_timecoord_t),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_timecoord_iterator_t {
    pub data: *mut xcb_timecoord_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_timecoord_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_timecoord_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_timecoord_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_timecoord_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_timecoord_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_timecoord_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_timecoord_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_timecoord_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_timecoord_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_timecoord_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_timecoord_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_motion_events_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_motion_events_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_motion_events_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_motion_events_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_motion_events_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_motion_events_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_motion_events_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_motion_events_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_motion_events_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
    pub start: xcb_timestamp_t,
    pub stop: xcb_timestamp_t,
}
#[test]
fn bindgen_test_layout_xcb_get_motion_events_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_motion_events_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_get_motion_events_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_motion_events_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_motion_events_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_motion_events_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_motion_events_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_motion_events_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_motion_events_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_motion_events_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_motion_events_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_motion_events_request_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_motion_events_request_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_motion_events_request_t>())).start as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_motion_events_request_t),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_motion_events_request_t>())).stop as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_motion_events_request_t),
            "::",
            stringify!(stop)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_motion_events_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub events_len: u32,
    pub pad1: [u8; 20usize],
}
#[test]
fn bindgen_test_layout_xcb_get_motion_events_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_motion_events_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_get_motion_events_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_motion_events_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_motion_events_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_motion_events_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_motion_events_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_motion_events_reply_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_motion_events_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_motion_events_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_motion_events_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_motion_events_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_motion_events_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_motion_events_reply_t>())).events_len as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_motion_events_reply_t),
            "::",
            stringify!(events_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_motion_events_reply_t>())).pad1 as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_motion_events_reply_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_translate_coordinates_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_translate_coordinates_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_translate_coordinates_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_translate_coordinates_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_translate_coordinates_cookie_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_translate_coordinates_cookie_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_translate_coordinates_cookie_t>())).sequence as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_translate_coordinates_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_translate_coordinates_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub src_window: xcb_window_t,
    pub dst_window: xcb_window_t,
    pub src_x: i16,
    pub src_y: i16,
}
#[test]
fn bindgen_test_layout_xcb_translate_coordinates_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_translate_coordinates_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_translate_coordinates_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_translate_coordinates_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_translate_coordinates_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_translate_coordinates_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_translate_coordinates_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_translate_coordinates_request_t>())).pad0 as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_translate_coordinates_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_translate_coordinates_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_translate_coordinates_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_translate_coordinates_request_t>())).src_window as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_translate_coordinates_request_t),
            "::",
            stringify!(src_window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_translate_coordinates_request_t>())).dst_window as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_translate_coordinates_request_t),
            "::",
            stringify!(dst_window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_translate_coordinates_request_t>())).src_x as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_translate_coordinates_request_t),
            "::",
            stringify!(src_x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_translate_coordinates_request_t>())).src_y as *const _
                as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_translate_coordinates_request_t),
            "::",
            stringify!(src_y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_translate_coordinates_reply_t {
    pub response_type: u8,
    pub same_screen: u8,
    pub sequence: u16,
    pub length: u32,
    pub child: xcb_window_t,
    pub dst_x: i16,
    pub dst_y: i16,
}
#[test]
fn bindgen_test_layout_xcb_translate_coordinates_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_translate_coordinates_reply_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_translate_coordinates_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_translate_coordinates_reply_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_translate_coordinates_reply_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_translate_coordinates_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_translate_coordinates_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_translate_coordinates_reply_t>())).same_screen as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_translate_coordinates_reply_t),
            "::",
            stringify!(same_screen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_translate_coordinates_reply_t>())).sequence as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_translate_coordinates_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_translate_coordinates_reply_t>())).length as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_translate_coordinates_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_translate_coordinates_reply_t>())).child as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_translate_coordinates_reply_t),
            "::",
            stringify!(child)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_translate_coordinates_reply_t>())).dst_x as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_translate_coordinates_reply_t),
            "::",
            stringify!(dst_x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_translate_coordinates_reply_t>())).dst_y as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_translate_coordinates_reply_t),
            "::",
            stringify!(dst_y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_warp_pointer_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub src_window: xcb_window_t,
    pub dst_window: xcb_window_t,
    pub src_x: i16,
    pub src_y: i16,
    pub src_width: u16,
    pub src_height: u16,
    pub dst_x: i16,
    pub dst_y: i16,
}
#[test]
fn bindgen_test_layout_xcb_warp_pointer_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_warp_pointer_request_t>(),
        24usize,
        concat!("Size of: ", stringify!(xcb_warp_pointer_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_warp_pointer_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_warp_pointer_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_warp_pointer_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_warp_pointer_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_warp_pointer_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_warp_pointer_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_warp_pointer_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_warp_pointer_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_warp_pointer_request_t>())).src_window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_warp_pointer_request_t),
            "::",
            stringify!(src_window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_warp_pointer_request_t>())).dst_window as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_warp_pointer_request_t),
            "::",
            stringify!(dst_window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_warp_pointer_request_t>())).src_x as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_warp_pointer_request_t),
            "::",
            stringify!(src_x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_warp_pointer_request_t>())).src_y as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_warp_pointer_request_t),
            "::",
            stringify!(src_y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_warp_pointer_request_t>())).src_width as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_warp_pointer_request_t),
            "::",
            stringify!(src_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_warp_pointer_request_t>())).src_height as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_warp_pointer_request_t),
            "::",
            stringify!(src_height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_warp_pointer_request_t>())).dst_x as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_warp_pointer_request_t),
            "::",
            stringify!(dst_x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_warp_pointer_request_t>())).dst_y as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_warp_pointer_request_t),
            "::",
            stringify!(dst_y)
        )
    );
}
pub mod xcb_input_focus_t {
    pub type Type = u32;
    pub const XCB_INPUT_FOCUS_NONE: Type = 0;
    pub const XCB_INPUT_FOCUS_POINTER_ROOT: Type = 1;
    pub const XCB_INPUT_FOCUS_PARENT: Type = 2;
    pub const XCB_INPUT_FOCUS_FOLLOW_KEYBOARD: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_set_input_focus_request_t {
    pub major_opcode: u8,
    pub revert_to: u8,
    pub length: u16,
    pub focus: xcb_window_t,
    pub time: xcb_timestamp_t,
}
#[test]
fn bindgen_test_layout_xcb_set_input_focus_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_set_input_focus_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_set_input_focus_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_set_input_focus_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_set_input_focus_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_input_focus_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_input_focus_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_input_focus_request_t>())).revert_to as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_input_focus_request_t),
            "::",
            stringify!(revert_to)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_input_focus_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_input_focus_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_input_focus_request_t>())).focus as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_input_focus_request_t),
            "::",
            stringify!(focus)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_input_focus_request_t>())).time as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_input_focus_request_t),
            "::",
            stringify!(time)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_input_focus_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_input_focus_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_input_focus_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_input_focus_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_input_focus_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_input_focus_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_input_focus_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_input_focus_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_input_focus_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_get_input_focus_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_input_focus_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_input_focus_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_input_focus_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_get_input_focus_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_input_focus_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_input_focus_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_input_focus_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_input_focus_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_input_focus_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_input_focus_request_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_input_focus_reply_t {
    pub response_type: u8,
    pub revert_to: u8,
    pub sequence: u16,
    pub length: u32,
    pub focus: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_get_input_focus_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_input_focus_reply_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_get_input_focus_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_input_focus_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_input_focus_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_input_focus_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_input_focus_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_input_focus_reply_t>())).revert_to as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_input_focus_reply_t),
            "::",
            stringify!(revert_to)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_input_focus_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_input_focus_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_input_focus_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_input_focus_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_input_focus_reply_t>())).focus as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_input_focus_reply_t),
            "::",
            stringify!(focus)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_keymap_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_query_keymap_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_query_keymap_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_query_keymap_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_keymap_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_keymap_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_keymap_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_keymap_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_keymap_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_query_keymap_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_query_keymap_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_query_keymap_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_keymap_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_query_keymap_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_keymap_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_keymap_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_keymap_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_keymap_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_keymap_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_keymap_request_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_keymap_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub keys: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_xcb_query_keymap_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_query_keymap_reply_t>(),
        40usize,
        concat!("Size of: ", stringify!(xcb_query_keymap_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_keymap_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_keymap_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_keymap_reply_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_keymap_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_keymap_reply_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_keymap_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_keymap_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_keymap_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_keymap_reply_t>())).length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_keymap_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_keymap_reply_t>())).keys as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_keymap_reply_t),
            "::",
            stringify!(keys)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_open_font_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub fid: xcb_font_t,
    pub name_len: u16,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_open_font_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_open_font_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_open_font_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_open_font_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_open_font_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_open_font_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_open_font_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_open_font_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_open_font_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_open_font_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_open_font_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_open_font_request_t>())).fid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_open_font_request_t),
            "::",
            stringify!(fid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_open_font_request_t>())).name_len as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_open_font_request_t),
            "::",
            stringify!(name_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_open_font_request_t>())).pad1 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_open_font_request_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_close_font_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub font: xcb_font_t,
}
#[test]
fn bindgen_test_layout_xcb_close_font_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_close_font_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_close_font_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_close_font_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_close_font_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_close_font_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_close_font_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_close_font_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_close_font_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_close_font_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_close_font_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_close_font_request_t>())).font as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_close_font_request_t),
            "::",
            stringify!(font)
        )
    );
}
pub mod xcb_font_draw_t {
    pub type Type = u32;
    pub const XCB_FONT_DRAW_LEFT_TO_RIGHT: Type = 0;
    pub const XCB_FONT_DRAW_RIGHT_TO_LEFT: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_fontprop_t {
    pub name: xcb_atom_t,
    pub value: u32,
}
#[test]
fn bindgen_test_layout_xcb_fontprop_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_fontprop_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_fontprop_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_fontprop_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_fontprop_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_fontprop_t>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fontprop_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_fontprop_t>())).value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fontprop_t),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_fontprop_iterator_t {
    pub data: *mut xcb_fontprop_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_fontprop_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_fontprop_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_fontprop_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_fontprop_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_fontprop_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_fontprop_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fontprop_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_fontprop_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fontprop_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_fontprop_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fontprop_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_charinfo_t {
    pub left_side_bearing: i16,
    pub right_side_bearing: i16,
    pub character_width: i16,
    pub ascent: i16,
    pub descent: i16,
    pub attributes: u16,
}
#[test]
fn bindgen_test_layout_xcb_charinfo_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_charinfo_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_charinfo_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_charinfo_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_charinfo_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_charinfo_t>())).left_side_bearing as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_charinfo_t),
            "::",
            stringify!(left_side_bearing)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_charinfo_t>())).right_side_bearing as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_charinfo_t),
            "::",
            stringify!(right_side_bearing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_charinfo_t>())).character_width as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_charinfo_t),
            "::",
            stringify!(character_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_charinfo_t>())).ascent as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_charinfo_t),
            "::",
            stringify!(ascent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_charinfo_t>())).descent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_charinfo_t),
            "::",
            stringify!(descent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_charinfo_t>())).attributes as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_charinfo_t),
            "::",
            stringify!(attributes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_charinfo_iterator_t {
    pub data: *mut xcb_charinfo_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_charinfo_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_charinfo_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_charinfo_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_charinfo_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_charinfo_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_charinfo_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_charinfo_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_charinfo_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_charinfo_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_charinfo_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_charinfo_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_font_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_query_font_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_query_font_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_query_font_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_font_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_font_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_font_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_font_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub font: xcb_fontable_t,
}
#[test]
fn bindgen_test_layout_xcb_query_font_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_query_font_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_query_font_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_font_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_font_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_font_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_font_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_font_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_font_request_t>())).font as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_request_t),
            "::",
            stringify!(font)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_font_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub min_bounds: xcb_charinfo_t,
    pub pad1: [u8; 4usize],
    pub max_bounds: xcb_charinfo_t,
    pub pad2: [u8; 4usize],
    pub min_char_or_byte2: u16,
    pub max_char_or_byte2: u16,
    pub default_char: u16,
    pub properties_len: u16,
    pub draw_direction: u8,
    pub min_byte1: u8,
    pub max_byte1: u8,
    pub all_chars_exist: u8,
    pub font_ascent: i16,
    pub font_descent: i16,
    pub char_infos_len: u32,
}
#[test]
fn bindgen_test_layout_xcb_query_font_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_query_font_reply_t>(),
        60usize,
        concat!("Size of: ", stringify!(xcb_query_font_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_font_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_font_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_font_reply_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_font_reply_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_font_reply_t>())).sequence as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_font_reply_t>())).length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_font_reply_t>())).min_bounds as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(min_bounds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_font_reply_t>())).pad1 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(pad1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_font_reply_t>())).max_bounds as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(max_bounds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_font_reply_t>())).pad2 as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(pad2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_font_reply_t>())).min_char_or_byte2 as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(min_char_or_byte2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_font_reply_t>())).max_char_or_byte2 as *const _
                as usize
        },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(max_char_or_byte2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_font_reply_t>())).default_char as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(default_char)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_font_reply_t>())).properties_len as *const _ as usize
        },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(properties_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_font_reply_t>())).draw_direction as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(draw_direction)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_font_reply_t>())).min_byte1 as *const _ as usize
        },
        49usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(min_byte1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_font_reply_t>())).max_byte1 as *const _ as usize
        },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(max_byte1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_font_reply_t>())).all_chars_exist as *const _ as usize
        },
        51usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(all_chars_exist)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_font_reply_t>())).font_ascent as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(font_ascent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_font_reply_t>())).font_descent as *const _ as usize
        },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(font_descent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_font_reply_t>())).char_infos_len as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(char_infos_len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_text_extents_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_query_text_extents_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_query_text_extents_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_query_text_extents_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_text_extents_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_text_extents_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_text_extents_cookie_t>())).sequence as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_text_extents_request_t {
    pub major_opcode: u8,
    pub odd_length: u8,
    pub length: u16,
    pub font: xcb_fontable_t,
}
#[test]
fn bindgen_test_layout_xcb_query_text_extents_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_query_text_extents_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_query_text_extents_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_text_extents_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_query_text_extents_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_text_extents_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_text_extents_request_t>())).odd_length as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_request_t),
            "::",
            stringify!(odd_length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_text_extents_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_text_extents_request_t>())).font as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_request_t),
            "::",
            stringify!(font)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_text_extents_reply_t {
    pub response_type: u8,
    pub draw_direction: u8,
    pub sequence: u16,
    pub length: u32,
    pub font_ascent: i16,
    pub font_descent: i16,
    pub overall_ascent: i16,
    pub overall_descent: i16,
    pub overall_width: i32,
    pub overall_left: i32,
    pub overall_right: i32,
}
#[test]
fn bindgen_test_layout_xcb_query_text_extents_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_query_text_extents_reply_t>(),
        28usize,
        concat!("Size of: ", stringify!(xcb_query_text_extents_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_text_extents_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_text_extents_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_text_extents_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_text_extents_reply_t>())).draw_direction as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_reply_t),
            "::",
            stringify!(draw_direction)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_text_extents_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_text_extents_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_text_extents_reply_t>())).font_ascent as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_reply_t),
            "::",
            stringify!(font_ascent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_text_extents_reply_t>())).font_descent as *const _
                as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_reply_t),
            "::",
            stringify!(font_descent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_text_extents_reply_t>())).overall_ascent as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_reply_t),
            "::",
            stringify!(overall_ascent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_text_extents_reply_t>())).overall_descent as *const _
                as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_reply_t),
            "::",
            stringify!(overall_descent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_text_extents_reply_t>())).overall_width as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_reply_t),
            "::",
            stringify!(overall_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_text_extents_reply_t>())).overall_left as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_reply_t),
            "::",
            stringify!(overall_left)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_text_extents_reply_t>())).overall_right as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_reply_t),
            "::",
            stringify!(overall_right)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_str_t {
    pub name_len: u8,
}
#[test]
fn bindgen_test_layout_xcb_str_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_str_t>(),
        1usize,
        concat!("Size of: ", stringify!(xcb_str_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_str_t>(),
        1usize,
        concat!("Alignment of ", stringify!(xcb_str_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_str_t>())).name_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_str_t),
            "::",
            stringify!(name_len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_str_iterator_t {
    pub data: *mut xcb_str_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_str_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_str_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_str_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_str_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_str_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_str_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_str_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_str_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_str_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_str_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_str_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_fonts_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_list_fonts_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_list_fonts_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_list_fonts_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_list_fonts_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_list_fonts_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_fonts_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub max_names: u16,
    pub pattern_len: u16,
}
#[test]
fn bindgen_test_layout_xcb_list_fonts_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_list_fonts_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_list_fonts_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_list_fonts_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_list_fonts_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_list_fonts_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_list_fonts_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_request_t>())).max_names as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_request_t),
            "::",
            stringify!(max_names)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_request_t>())).pattern_len as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_request_t),
            "::",
            stringify!(pattern_len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_fonts_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub names_len: u16,
    pub pad1: [u8; 22usize],
}
#[test]
fn bindgen_test_layout_xcb_list_fonts_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_list_fonts_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_list_fonts_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_list_fonts_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_list_fonts_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_reply_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_list_fonts_reply_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_list_fonts_reply_t>())).sequence as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_list_fonts_reply_t>())).length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_reply_t>())).names_len as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_reply_t),
            "::",
            stringify!(names_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_list_fonts_reply_t>())).pad1 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_reply_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_fonts_with_info_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_list_fonts_with_info_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_list_fonts_with_info_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_list_fonts_with_info_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_list_fonts_with_info_cookie_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_list_fonts_with_info_cookie_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_with_info_cookie_t>())).sequence as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_fonts_with_info_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub max_names: u16,
    pub pattern_len: u16,
}
#[test]
fn bindgen_test_layout_xcb_list_fonts_with_info_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_list_fonts_with_info_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_list_fonts_with_info_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_list_fonts_with_info_request_t>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_list_fonts_with_info_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_with_info_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_with_info_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_with_info_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_with_info_request_t>())).max_names as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_request_t),
            "::",
            stringify!(max_names)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_with_info_request_t>())).pattern_len as *const _
                as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_request_t),
            "::",
            stringify!(pattern_len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_fonts_with_info_reply_t {
    pub response_type: u8,
    pub name_len: u8,
    pub sequence: u16,
    pub length: u32,
    pub min_bounds: xcb_charinfo_t,
    pub pad0: [u8; 4usize],
    pub max_bounds: xcb_charinfo_t,
    pub pad1: [u8; 4usize],
    pub min_char_or_byte2: u16,
    pub max_char_or_byte2: u16,
    pub default_char: u16,
    pub properties_len: u16,
    pub draw_direction: u8,
    pub min_byte1: u8,
    pub max_byte1: u8,
    pub all_chars_exist: u8,
    pub font_ascent: i16,
    pub font_descent: i16,
    pub replies_hint: u32,
}
#[test]
fn bindgen_test_layout_xcb_list_fonts_with_info_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_list_fonts_with_info_reply_t>(),
        60usize,
        concat!("Size of: ", stringify!(xcb_list_fonts_with_info_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_list_fonts_with_info_reply_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_list_fonts_with_info_reply_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_with_info_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_with_info_reply_t>())).name_len as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(name_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_with_info_reply_t>())).sequence as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_with_info_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_with_info_reply_t>())).min_bounds as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(min_bounds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_with_info_reply_t>())).pad0 as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_with_info_reply_t>())).max_bounds as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(max_bounds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_with_info_reply_t>())).pad1 as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(pad1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_with_info_reply_t>())).min_char_or_byte2
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(min_char_or_byte2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_with_info_reply_t>())).max_char_or_byte2
                as *const _ as usize
        },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(max_char_or_byte2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_with_info_reply_t>())).default_char as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(default_char)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_with_info_reply_t>())).properties_len as *const _
                as usize
        },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(properties_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_with_info_reply_t>())).draw_direction as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(draw_direction)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_with_info_reply_t>())).min_byte1 as *const _
                as usize
        },
        49usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(min_byte1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_with_info_reply_t>())).max_byte1 as *const _
                as usize
        },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(max_byte1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_with_info_reply_t>())).all_chars_exist as *const _
                as usize
        },
        51usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(all_chars_exist)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_with_info_reply_t>())).font_ascent as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(font_ascent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_with_info_reply_t>())).font_descent as *const _
                as usize
        },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(font_descent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_with_info_reply_t>())).replies_hint as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(replies_hint)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_set_font_path_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub font_qty: u16,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_set_font_path_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_set_font_path_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_set_font_path_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_set_font_path_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_set_font_path_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_font_path_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_font_path_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_font_path_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_font_path_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_font_path_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_font_path_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_font_path_request_t>())).font_qty as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_font_path_request_t),
            "::",
            stringify!(font_qty)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_font_path_request_t>())).pad1 as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_font_path_request_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_font_path_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_font_path_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_font_path_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_font_path_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_font_path_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_font_path_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_font_path_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_font_path_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_font_path_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_get_font_path_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_font_path_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_font_path_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_font_path_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_get_font_path_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_font_path_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_font_path_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_font_path_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_font_path_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_font_path_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_font_path_request_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_font_path_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub path_len: u16,
    pub pad1: [u8; 22usize],
}
#[test]
fn bindgen_test_layout_xcb_get_font_path_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_font_path_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_get_font_path_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_font_path_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_font_path_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_font_path_reply_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_font_path_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_get_font_path_reply_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_font_path_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_font_path_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_font_path_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_font_path_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_font_path_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_font_path_reply_t>())).path_len as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_font_path_reply_t),
            "::",
            stringify!(path_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_get_font_path_reply_t>())).pad1 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_font_path_reply_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_create_pixmap_request_t {
    pub major_opcode: u8,
    pub depth: u8,
    pub length: u16,
    pub pid: xcb_pixmap_t,
    pub drawable: xcb_drawable_t,
    pub width: u16,
    pub height: u16,
}
#[test]
fn bindgen_test_layout_xcb_create_pixmap_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_create_pixmap_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_create_pixmap_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_create_pixmap_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_create_pixmap_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_pixmap_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_pixmap_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_pixmap_request_t>())).depth as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_pixmap_request_t),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_pixmap_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_pixmap_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_create_pixmap_request_t>())).pid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_pixmap_request_t),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_pixmap_request_t>())).drawable as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_pixmap_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_pixmap_request_t>())).width as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_pixmap_request_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_pixmap_request_t>())).height as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_pixmap_request_t),
            "::",
            stringify!(height)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_free_pixmap_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub pixmap: xcb_pixmap_t,
}
#[test]
fn bindgen_test_layout_xcb_free_pixmap_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_free_pixmap_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_free_pixmap_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_free_pixmap_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_free_pixmap_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_free_pixmap_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_pixmap_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_free_pixmap_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_pixmap_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_free_pixmap_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_pixmap_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_free_pixmap_request_t>())).pixmap as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_pixmap_request_t),
            "::",
            stringify!(pixmap)
        )
    );
}
pub mod xcb_gc_t {
    pub type Type = u32;
    pub const XCB_GC_FUNCTION: Type = 1;
    pub const XCB_GC_PLANE_MASK: Type = 2;
    pub const XCB_GC_FOREGROUND: Type = 4;
    pub const XCB_GC_BACKGROUND: Type = 8;
    pub const XCB_GC_LINE_WIDTH: Type = 16;
    pub const XCB_GC_LINE_STYLE: Type = 32;
    pub const XCB_GC_CAP_STYLE: Type = 64;
    pub const XCB_GC_JOIN_STYLE: Type = 128;
    pub const XCB_GC_FILL_STYLE: Type = 256;
    pub const XCB_GC_FILL_RULE: Type = 512;
    pub const XCB_GC_TILE: Type = 1024;
    pub const XCB_GC_STIPPLE: Type = 2048;
    pub const XCB_GC_TILE_STIPPLE_ORIGIN_X: Type = 4096;
    pub const XCB_GC_TILE_STIPPLE_ORIGIN_Y: Type = 8192;
    pub const XCB_GC_FONT: Type = 16384;
    pub const XCB_GC_SUBWINDOW_MODE: Type = 32768;
    pub const XCB_GC_GRAPHICS_EXPOSURES: Type = 65536;
    pub const XCB_GC_CLIP_ORIGIN_X: Type = 131072;
    pub const XCB_GC_CLIP_ORIGIN_Y: Type = 262144;
    pub const XCB_GC_CLIP_MASK: Type = 524288;
    pub const XCB_GC_DASH_OFFSET: Type = 1048576;
    pub const XCB_GC_DASH_LIST: Type = 2097152;
    pub const XCB_GC_ARC_MODE: Type = 4194304;
}
pub mod xcb_gx_t {
    pub type Type = u32;
    pub const XCB_GX_CLEAR: Type = 0;
    pub const XCB_GX_AND: Type = 1;
    pub const XCB_GX_AND_REVERSE: Type = 2;
    pub const XCB_GX_COPY: Type = 3;
    pub const XCB_GX_AND_INVERTED: Type = 4;
    pub const XCB_GX_NOOP: Type = 5;
    pub const XCB_GX_XOR: Type = 6;
    pub const XCB_GX_OR: Type = 7;
    pub const XCB_GX_NOR: Type = 8;
    pub const XCB_GX_EQUIV: Type = 9;
    pub const XCB_GX_INVERT: Type = 10;
    pub const XCB_GX_OR_REVERSE: Type = 11;
    pub const XCB_GX_COPY_INVERTED: Type = 12;
    pub const XCB_GX_OR_INVERTED: Type = 13;
    pub const XCB_GX_NAND: Type = 14;
    pub const XCB_GX_SET: Type = 15;
}
pub mod xcb_line_style_t {
    pub type Type = u32;
    pub const XCB_LINE_STYLE_SOLID: Type = 0;
    pub const XCB_LINE_STYLE_ON_OFF_DASH: Type = 1;
    pub const XCB_LINE_STYLE_DOUBLE_DASH: Type = 2;
}
pub mod xcb_cap_style_t {
    pub type Type = u32;
    pub const XCB_CAP_STYLE_NOT_LAST: Type = 0;
    pub const XCB_CAP_STYLE_BUTT: Type = 1;
    pub const XCB_CAP_STYLE_ROUND: Type = 2;
    pub const XCB_CAP_STYLE_PROJECTING: Type = 3;
}
pub mod xcb_join_style_t {
    pub type Type = u32;
    pub const XCB_JOIN_STYLE_MITER: Type = 0;
    pub const XCB_JOIN_STYLE_ROUND: Type = 1;
    pub const XCB_JOIN_STYLE_BEVEL: Type = 2;
}
pub mod xcb_fill_style_t {
    pub type Type = u32;
    pub const XCB_FILL_STYLE_SOLID: Type = 0;
    pub const XCB_FILL_STYLE_TILED: Type = 1;
    pub const XCB_FILL_STYLE_STIPPLED: Type = 2;
    pub const XCB_FILL_STYLE_OPAQUE_STIPPLED: Type = 3;
}
pub mod xcb_fill_rule_t {
    pub type Type = u32;
    pub const XCB_FILL_RULE_EVEN_ODD: Type = 0;
    pub const XCB_FILL_RULE_WINDING: Type = 1;
}
pub mod xcb_subwindow_mode_t {
    pub type Type = u32;
    pub const XCB_SUBWINDOW_MODE_CLIP_BY_CHILDREN: Type = 0;
    pub const XCB_SUBWINDOW_MODE_INCLUDE_INFERIORS: Type = 1;
}
pub mod xcb_arc_mode_t {
    pub type Type = u32;
    pub const XCB_ARC_MODE_CHORD: Type = 0;
    pub const XCB_ARC_MODE_PIE_SLICE: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_create_gc_value_list_t {
    pub function: u32,
    pub plane_mask: u32,
    pub foreground: u32,
    pub background: u32,
    pub line_width: u32,
    pub line_style: u32,
    pub cap_style: u32,
    pub join_style: u32,
    pub fill_style: u32,
    pub fill_rule: u32,
    pub tile: xcb_pixmap_t,
    pub stipple: xcb_pixmap_t,
    pub tile_stipple_x_origin: i32,
    pub tile_stipple_y_origin: i32,
    pub font: xcb_font_t,
    pub subwindow_mode: u32,
    pub graphics_exposures: xcb_bool32_t,
    pub clip_x_origin: i32,
    pub clip_y_origin: i32,
    pub clip_mask: xcb_pixmap_t,
    pub dash_offset: u32,
    pub dashes: u32,
    pub arc_mode: u32,
}
#[test]
fn bindgen_test_layout_xcb_create_gc_value_list_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_create_gc_value_list_t>(),
        92usize,
        concat!("Size of: ", stringify!(xcb_create_gc_value_list_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_create_gc_value_list_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_create_gc_value_list_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_gc_value_list_t>())).function as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_gc_value_list_t>())).plane_mask as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(plane_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_gc_value_list_t>())).foreground as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(foreground)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_gc_value_list_t>())).background as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(background)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_gc_value_list_t>())).line_width as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(line_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_gc_value_list_t>())).line_style as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(line_style)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_gc_value_list_t>())).cap_style as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(cap_style)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_gc_value_list_t>())).join_style as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(join_style)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_gc_value_list_t>())).fill_style as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(fill_style)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_gc_value_list_t>())).fill_rule as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(fill_rule)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_create_gc_value_list_t>())).tile as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(tile)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_gc_value_list_t>())).stipple as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(stipple)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_gc_value_list_t>())).tile_stipple_x_origin as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(tile_stipple_x_origin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_gc_value_list_t>())).tile_stipple_y_origin as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(tile_stipple_y_origin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_create_gc_value_list_t>())).font as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(font)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_gc_value_list_t>())).subwindow_mode as *const _
                as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(subwindow_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_gc_value_list_t>())).graphics_exposures as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(graphics_exposures)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_gc_value_list_t>())).clip_x_origin as *const _
                as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(clip_x_origin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_gc_value_list_t>())).clip_y_origin as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(clip_y_origin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_gc_value_list_t>())).clip_mask as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(clip_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_gc_value_list_t>())).dash_offset as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(dash_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_gc_value_list_t>())).dashes as *const _ as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(dashes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_gc_value_list_t>())).arc_mode as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(arc_mode)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_create_gc_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cid: xcb_gcontext_t,
    pub drawable: xcb_drawable_t,
    pub value_mask: u32,
}
#[test]
fn bindgen_test_layout_xcb_create_gc_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_create_gc_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_create_gc_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_create_gc_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_create_gc_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_gc_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_create_gc_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_create_gc_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_create_gc_request_t>())).cid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_request_t),
            "::",
            stringify!(cid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_gc_request_t>())).drawable as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_gc_request_t>())).value_mask as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_request_t),
            "::",
            stringify!(value_mask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_change_gc_value_list_t {
    pub function: u32,
    pub plane_mask: u32,
    pub foreground: u32,
    pub background: u32,
    pub line_width: u32,
    pub line_style: u32,
    pub cap_style: u32,
    pub join_style: u32,
    pub fill_style: u32,
    pub fill_rule: u32,
    pub tile: xcb_pixmap_t,
    pub stipple: xcb_pixmap_t,
    pub tile_stipple_x_origin: i32,
    pub tile_stipple_y_origin: i32,
    pub font: xcb_font_t,
    pub subwindow_mode: u32,
    pub graphics_exposures: xcb_bool32_t,
    pub clip_x_origin: i32,
    pub clip_y_origin: i32,
    pub clip_mask: xcb_pixmap_t,
    pub dash_offset: u32,
    pub dashes: u32,
    pub arc_mode: u32,
}
#[test]
fn bindgen_test_layout_xcb_change_gc_value_list_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_change_gc_value_list_t>(),
        92usize,
        concat!("Size of: ", stringify!(xcb_change_gc_value_list_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_change_gc_value_list_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_change_gc_value_list_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_gc_value_list_t>())).function as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_gc_value_list_t>())).plane_mask as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(plane_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_gc_value_list_t>())).foreground as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(foreground)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_gc_value_list_t>())).background as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(background)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_gc_value_list_t>())).line_width as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(line_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_gc_value_list_t>())).line_style as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(line_style)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_gc_value_list_t>())).cap_style as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(cap_style)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_gc_value_list_t>())).join_style as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(join_style)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_gc_value_list_t>())).fill_style as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(fill_style)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_gc_value_list_t>())).fill_rule as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(fill_rule)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_change_gc_value_list_t>())).tile as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(tile)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_gc_value_list_t>())).stipple as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(stipple)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_gc_value_list_t>())).tile_stipple_x_origin as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(tile_stipple_x_origin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_gc_value_list_t>())).tile_stipple_y_origin as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(tile_stipple_y_origin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_change_gc_value_list_t>())).font as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(font)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_gc_value_list_t>())).subwindow_mode as *const _
                as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(subwindow_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_gc_value_list_t>())).graphics_exposures as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(graphics_exposures)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_gc_value_list_t>())).clip_x_origin as *const _
                as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(clip_x_origin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_gc_value_list_t>())).clip_y_origin as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(clip_y_origin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_gc_value_list_t>())).clip_mask as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(clip_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_gc_value_list_t>())).dash_offset as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(dash_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_gc_value_list_t>())).dashes as *const _ as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(dashes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_gc_value_list_t>())).arc_mode as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(arc_mode)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_change_gc_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub gc: xcb_gcontext_t,
    pub value_mask: u32,
}
#[test]
fn bindgen_test_layout_xcb_change_gc_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_change_gc_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_change_gc_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_change_gc_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_change_gc_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_gc_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_change_gc_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_change_gc_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_change_gc_request_t>())).gc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_request_t),
            "::",
            stringify!(gc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_gc_request_t>())).value_mask as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_request_t),
            "::",
            stringify!(value_mask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_copy_gc_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub src_gc: xcb_gcontext_t,
    pub dst_gc: xcb_gcontext_t,
    pub value_mask: u32,
}
#[test]
fn bindgen_test_layout_xcb_copy_gc_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_copy_gc_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_copy_gc_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_copy_gc_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_copy_gc_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_copy_gc_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_gc_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_copy_gc_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_gc_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_copy_gc_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_gc_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_copy_gc_request_t>())).src_gc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_gc_request_t),
            "::",
            stringify!(src_gc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_copy_gc_request_t>())).dst_gc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_gc_request_t),
            "::",
            stringify!(dst_gc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_copy_gc_request_t>())).value_mask as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_gc_request_t),
            "::",
            stringify!(value_mask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_set_dashes_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub gc: xcb_gcontext_t,
    pub dash_offset: u16,
    pub dashes_len: u16,
}
#[test]
fn bindgen_test_layout_xcb_set_dashes_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_set_dashes_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_set_dashes_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_set_dashes_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_set_dashes_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_dashes_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_dashes_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_set_dashes_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_dashes_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_set_dashes_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_dashes_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_set_dashes_request_t>())).gc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_dashes_request_t),
            "::",
            stringify!(gc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_dashes_request_t>())).dash_offset as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_dashes_request_t),
            "::",
            stringify!(dash_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_dashes_request_t>())).dashes_len as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_dashes_request_t),
            "::",
            stringify!(dashes_len)
        )
    );
}
pub mod xcb_clip_ordering_t {
    pub type Type = u32;
    pub const XCB_CLIP_ORDERING_UNSORTED: Type = 0;
    pub const XCB_CLIP_ORDERING_Y_SORTED: Type = 1;
    pub const XCB_CLIP_ORDERING_YX_SORTED: Type = 2;
    pub const XCB_CLIP_ORDERING_YX_BANDED: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_set_clip_rectangles_request_t {
    pub major_opcode: u8,
    pub ordering: u8,
    pub length: u16,
    pub gc: xcb_gcontext_t,
    pub clip_x_origin: i16,
    pub clip_y_origin: i16,
}
#[test]
fn bindgen_test_layout_xcb_set_clip_rectangles_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_set_clip_rectangles_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_set_clip_rectangles_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_set_clip_rectangles_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_set_clip_rectangles_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_clip_rectangles_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_clip_rectangles_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_clip_rectangles_request_t>())).ordering as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_clip_rectangles_request_t),
            "::",
            stringify!(ordering)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_clip_rectangles_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_clip_rectangles_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_clip_rectangles_request_t>())).gc as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_clip_rectangles_request_t),
            "::",
            stringify!(gc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_clip_rectangles_request_t>())).clip_x_origin as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_clip_rectangles_request_t),
            "::",
            stringify!(clip_x_origin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_clip_rectangles_request_t>())).clip_y_origin as *const _
                as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_clip_rectangles_request_t),
            "::",
            stringify!(clip_y_origin)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_free_gc_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub gc: xcb_gcontext_t,
}
#[test]
fn bindgen_test_layout_xcb_free_gc_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_free_gc_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_free_gc_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_free_gc_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_free_gc_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_free_gc_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_gc_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_free_gc_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_gc_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_free_gc_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_gc_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_free_gc_request_t>())).gc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_gc_request_t),
            "::",
            stringify!(gc)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_clear_area_request_t {
    pub major_opcode: u8,
    pub exposures: u8,
    pub length: u16,
    pub window: xcb_window_t,
    pub x: i16,
    pub y: i16,
    pub width: u16,
    pub height: u16,
}
#[test]
fn bindgen_test_layout_xcb_clear_area_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_clear_area_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_clear_area_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_clear_area_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_clear_area_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_clear_area_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_clear_area_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_clear_area_request_t>())).exposures as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_clear_area_request_t),
            "::",
            stringify!(exposures)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_clear_area_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_clear_area_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_clear_area_request_t>())).window as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_clear_area_request_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_clear_area_request_t>())).x as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_clear_area_request_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_clear_area_request_t>())).y as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_clear_area_request_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_clear_area_request_t>())).width as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_clear_area_request_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_clear_area_request_t>())).height as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_clear_area_request_t),
            "::",
            stringify!(height)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_copy_area_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub src_drawable: xcb_drawable_t,
    pub dst_drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
    pub src_x: i16,
    pub src_y: i16,
    pub dst_x: i16,
    pub dst_y: i16,
    pub width: u16,
    pub height: u16,
}
#[test]
fn bindgen_test_layout_xcb_copy_area_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_copy_area_request_t>(),
        28usize,
        concat!("Size of: ", stringify!(xcb_copy_area_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_copy_area_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_copy_area_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_copy_area_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_area_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_copy_area_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_area_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_copy_area_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_area_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_copy_area_request_t>())).src_drawable as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_area_request_t),
            "::",
            stringify!(src_drawable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_copy_area_request_t>())).dst_drawable as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_area_request_t),
            "::",
            stringify!(dst_drawable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_copy_area_request_t>())).gc as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_area_request_t),
            "::",
            stringify!(gc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_copy_area_request_t>())).src_x as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_area_request_t),
            "::",
            stringify!(src_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_copy_area_request_t>())).src_y as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_area_request_t),
            "::",
            stringify!(src_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_copy_area_request_t>())).dst_x as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_area_request_t),
            "::",
            stringify!(dst_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_copy_area_request_t>())).dst_y as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_area_request_t),
            "::",
            stringify!(dst_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_copy_area_request_t>())).width as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_area_request_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_copy_area_request_t>())).height as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_area_request_t),
            "::",
            stringify!(height)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_copy_plane_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub src_drawable: xcb_drawable_t,
    pub dst_drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
    pub src_x: i16,
    pub src_y: i16,
    pub dst_x: i16,
    pub dst_y: i16,
    pub width: u16,
    pub height: u16,
    pub bit_plane: u32,
}
#[test]
fn bindgen_test_layout_xcb_copy_plane_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_copy_plane_request_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_copy_plane_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_copy_plane_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_copy_plane_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_copy_plane_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_plane_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_copy_plane_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_plane_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_copy_plane_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_plane_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_copy_plane_request_t>())).src_drawable as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_plane_request_t),
            "::",
            stringify!(src_drawable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_copy_plane_request_t>())).dst_drawable as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_plane_request_t),
            "::",
            stringify!(dst_drawable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_copy_plane_request_t>())).gc as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_plane_request_t),
            "::",
            stringify!(gc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_copy_plane_request_t>())).src_x as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_plane_request_t),
            "::",
            stringify!(src_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_copy_plane_request_t>())).src_y as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_plane_request_t),
            "::",
            stringify!(src_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_copy_plane_request_t>())).dst_x as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_plane_request_t),
            "::",
            stringify!(dst_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_copy_plane_request_t>())).dst_y as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_plane_request_t),
            "::",
            stringify!(dst_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_copy_plane_request_t>())).width as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_plane_request_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_copy_plane_request_t>())).height as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_plane_request_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_copy_plane_request_t>())).bit_plane as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_plane_request_t),
            "::",
            stringify!(bit_plane)
        )
    );
}
pub mod xcb_coord_mode_t {
    pub type Type = u32;
    pub const XCB_COORD_MODE_ORIGIN: Type = 0;
    pub const XCB_COORD_MODE_PREVIOUS: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_poly_point_request_t {
    pub major_opcode: u8,
    pub coordinate_mode: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
}
#[test]
fn bindgen_test_layout_xcb_poly_point_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_poly_point_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_poly_point_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_poly_point_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_poly_point_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_poly_point_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_point_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_poly_point_request_t>())).coordinate_mode as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_point_request_t),
            "::",
            stringify!(coordinate_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_poly_point_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_point_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_poly_point_request_t>())).drawable as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_point_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_poly_point_request_t>())).gc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_point_request_t),
            "::",
            stringify!(gc)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_poly_line_request_t {
    pub major_opcode: u8,
    pub coordinate_mode: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
}
#[test]
fn bindgen_test_layout_xcb_poly_line_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_poly_line_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_poly_line_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_poly_line_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_poly_line_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_poly_line_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_line_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_poly_line_request_t>())).coordinate_mode as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_line_request_t),
            "::",
            stringify!(coordinate_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_poly_line_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_line_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_poly_line_request_t>())).drawable as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_line_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_poly_line_request_t>())).gc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_line_request_t),
            "::",
            stringify!(gc)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_segment_t {
    pub x1: i16,
    pub y1: i16,
    pub x2: i16,
    pub y2: i16,
}
#[test]
fn bindgen_test_layout_xcb_segment_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_segment_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_segment_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_segment_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_segment_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_segment_t>())).x1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_segment_t),
            "::",
            stringify!(x1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_segment_t>())).y1 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_segment_t),
            "::",
            stringify!(y1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_segment_t>())).x2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_segment_t),
            "::",
            stringify!(x2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_segment_t>())).y2 as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_segment_t),
            "::",
            stringify!(y2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_segment_iterator_t {
    pub data: *mut xcb_segment_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_segment_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_segment_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_segment_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_segment_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_segment_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_segment_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_segment_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_segment_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_segment_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_segment_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_segment_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_poly_segment_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
}
#[test]
fn bindgen_test_layout_xcb_poly_segment_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_poly_segment_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_poly_segment_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_poly_segment_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_poly_segment_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_poly_segment_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_segment_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_poly_segment_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_segment_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_poly_segment_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_segment_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_poly_segment_request_t>())).drawable as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_segment_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_poly_segment_request_t>())).gc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_segment_request_t),
            "::",
            stringify!(gc)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_poly_rectangle_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
}
#[test]
fn bindgen_test_layout_xcb_poly_rectangle_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_poly_rectangle_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_poly_rectangle_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_poly_rectangle_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_poly_rectangle_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_poly_rectangle_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_rectangle_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_poly_rectangle_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_rectangle_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_poly_rectangle_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_rectangle_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_poly_rectangle_request_t>())).drawable as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_rectangle_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_poly_rectangle_request_t>())).gc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_rectangle_request_t),
            "::",
            stringify!(gc)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_poly_arc_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
}
#[test]
fn bindgen_test_layout_xcb_poly_arc_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_poly_arc_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_poly_arc_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_poly_arc_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_poly_arc_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_poly_arc_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_arc_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_poly_arc_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_arc_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_poly_arc_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_arc_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_poly_arc_request_t>())).drawable as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_arc_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_poly_arc_request_t>())).gc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_arc_request_t),
            "::",
            stringify!(gc)
        )
    );
}
pub mod xcb_poly_shape_t {
    pub type Type = u32;
    pub const XCB_POLY_SHAPE_COMPLEX: Type = 0;
    pub const XCB_POLY_SHAPE_NONCONVEX: Type = 1;
    pub const XCB_POLY_SHAPE_CONVEX: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_fill_poly_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
    pub shape: u8,
    pub coordinate_mode: u8,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_fill_poly_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_fill_poly_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_fill_poly_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_fill_poly_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_fill_poly_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_fill_poly_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fill_poly_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_fill_poly_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fill_poly_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_fill_poly_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fill_poly_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_fill_poly_request_t>())).drawable as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fill_poly_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_fill_poly_request_t>())).gc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fill_poly_request_t),
            "::",
            stringify!(gc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_fill_poly_request_t>())).shape as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fill_poly_request_t),
            "::",
            stringify!(shape)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_fill_poly_request_t>())).coordinate_mode as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fill_poly_request_t),
            "::",
            stringify!(coordinate_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_fill_poly_request_t>())).pad1 as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fill_poly_request_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_poly_fill_rectangle_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
}
#[test]
fn bindgen_test_layout_xcb_poly_fill_rectangle_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_poly_fill_rectangle_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_poly_fill_rectangle_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_poly_fill_rectangle_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_poly_fill_rectangle_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_poly_fill_rectangle_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_fill_rectangle_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_poly_fill_rectangle_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_fill_rectangle_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_poly_fill_rectangle_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_fill_rectangle_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_poly_fill_rectangle_request_t>())).drawable as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_fill_rectangle_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_poly_fill_rectangle_request_t>())).gc as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_fill_rectangle_request_t),
            "::",
            stringify!(gc)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_poly_fill_arc_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
}
#[test]
fn bindgen_test_layout_xcb_poly_fill_arc_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_poly_fill_arc_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_poly_fill_arc_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_poly_fill_arc_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_poly_fill_arc_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_poly_fill_arc_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_fill_arc_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_poly_fill_arc_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_fill_arc_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_poly_fill_arc_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_fill_arc_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_poly_fill_arc_request_t>())).drawable as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_fill_arc_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_poly_fill_arc_request_t>())).gc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_fill_arc_request_t),
            "::",
            stringify!(gc)
        )
    );
}
pub mod xcb_image_format_t {
    pub type Type = u32;
    pub const XCB_IMAGE_FORMAT_XY_BITMAP: Type = 0;
    pub const XCB_IMAGE_FORMAT_XY_PIXMAP: Type = 1;
    pub const XCB_IMAGE_FORMAT_Z_PIXMAP: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_put_image_request_t {
    pub major_opcode: u8,
    pub format: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
    pub width: u16,
    pub height: u16,
    pub dst_x: i16,
    pub dst_y: i16,
    pub left_pad: u8,
    pub depth: u8,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_put_image_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_put_image_request_t>(),
        24usize,
        concat!("Size of: ", stringify!(xcb_put_image_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_put_image_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_put_image_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_put_image_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_put_image_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_put_image_request_t>())).format as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_put_image_request_t),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_put_image_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_put_image_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_put_image_request_t>())).drawable as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_put_image_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_put_image_request_t>())).gc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_put_image_request_t),
            "::",
            stringify!(gc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_put_image_request_t>())).width as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_put_image_request_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_put_image_request_t>())).height as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_put_image_request_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_put_image_request_t>())).dst_x as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_put_image_request_t),
            "::",
            stringify!(dst_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_put_image_request_t>())).dst_y as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_put_image_request_t),
            "::",
            stringify!(dst_y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_put_image_request_t>())).left_pad as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_put_image_request_t),
            "::",
            stringify!(left_pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_put_image_request_t>())).depth as *const _ as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_put_image_request_t),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_put_image_request_t>())).pad0 as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_put_image_request_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_image_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_image_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_image_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_image_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_image_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_image_cookie_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_get_image_cookie_t>())).sequence as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_image_request_t {
    pub major_opcode: u8,
    pub format: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub x: i16,
    pub y: i16,
    pub width: u16,
    pub height: u16,
    pub plane_mask: u32,
}
#[test]
fn bindgen_test_layout_xcb_get_image_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_image_request_t>(),
        20usize,
        concat!("Size of: ", stringify!(xcb_get_image_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_image_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_image_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_image_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_get_image_request_t>())).format as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_request_t),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_get_image_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_image_request_t>())).drawable as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_get_image_request_t>())).x as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_request_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_get_image_request_t>())).y as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_request_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_get_image_request_t>())).width as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_request_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_get_image_request_t>())).height as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_request_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_image_request_t>())).plane_mask as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_request_t),
            "::",
            stringify!(plane_mask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_image_reply_t {
    pub response_type: u8,
    pub depth: u8,
    pub sequence: u16,
    pub length: u32,
    pub visual: xcb_visualid_t,
    pub pad0: [u8; 20usize],
}
#[test]
fn bindgen_test_layout_xcb_get_image_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_image_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_get_image_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_image_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_image_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_image_reply_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_get_image_reply_t>())).depth as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_reply_t),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_get_image_reply_t>())).sequence as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_get_image_reply_t>())).length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_get_image_reply_t>())).visual as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_reply_t),
            "::",
            stringify!(visual)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_get_image_reply_t>())).pad0 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_reply_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_poly_text_8_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
    pub x: i16,
    pub y: i16,
}
#[test]
fn bindgen_test_layout_xcb_poly_text_8_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_poly_text_8_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_poly_text_8_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_poly_text_8_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_poly_text_8_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_poly_text_8_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_text_8_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_poly_text_8_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_text_8_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_poly_text_8_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_text_8_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_poly_text_8_request_t>())).drawable as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_text_8_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_poly_text_8_request_t>())).gc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_text_8_request_t),
            "::",
            stringify!(gc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_poly_text_8_request_t>())).x as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_text_8_request_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_poly_text_8_request_t>())).y as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_text_8_request_t),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_poly_text_16_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
    pub x: i16,
    pub y: i16,
}
#[test]
fn bindgen_test_layout_xcb_poly_text_16_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_poly_text_16_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_poly_text_16_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_poly_text_16_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_poly_text_16_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_poly_text_16_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_text_16_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_poly_text_16_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_text_16_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_poly_text_16_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_text_16_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_poly_text_16_request_t>())).drawable as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_text_16_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_poly_text_16_request_t>())).gc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_text_16_request_t),
            "::",
            stringify!(gc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_poly_text_16_request_t>())).x as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_text_16_request_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_poly_text_16_request_t>())).y as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_text_16_request_t),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_image_text_8_request_t {
    pub major_opcode: u8,
    pub string_len: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
    pub x: i16,
    pub y: i16,
}
#[test]
fn bindgen_test_layout_xcb_image_text_8_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_image_text_8_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_image_text_8_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_image_text_8_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_image_text_8_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_image_text_8_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_image_text_8_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_image_text_8_request_t>())).string_len as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_image_text_8_request_t),
            "::",
            stringify!(string_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_image_text_8_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_image_text_8_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_image_text_8_request_t>())).drawable as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_image_text_8_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_image_text_8_request_t>())).gc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_image_text_8_request_t),
            "::",
            stringify!(gc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_image_text_8_request_t>())).x as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_image_text_8_request_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_image_text_8_request_t>())).y as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_image_text_8_request_t),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_image_text_16_request_t {
    pub major_opcode: u8,
    pub string_len: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
    pub x: i16,
    pub y: i16,
}
#[test]
fn bindgen_test_layout_xcb_image_text_16_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_image_text_16_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_image_text_16_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_image_text_16_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_image_text_16_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_image_text_16_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_image_text_16_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_image_text_16_request_t>())).string_len as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_image_text_16_request_t),
            "::",
            stringify!(string_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_image_text_16_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_image_text_16_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_image_text_16_request_t>())).drawable as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_image_text_16_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_image_text_16_request_t>())).gc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_image_text_16_request_t),
            "::",
            stringify!(gc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_image_text_16_request_t>())).x as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_image_text_16_request_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_image_text_16_request_t>())).y as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_image_text_16_request_t),
            "::",
            stringify!(y)
        )
    );
}
pub mod xcb_colormap_alloc_t {
    pub type Type = u32;
    pub const XCB_COLORMAP_ALLOC_NONE: Type = 0;
    pub const XCB_COLORMAP_ALLOC_ALL: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_create_colormap_request_t {
    pub major_opcode: u8,
    pub alloc: u8,
    pub length: u16,
    pub mid: xcb_colormap_t,
    pub window: xcb_window_t,
    pub visual: xcb_visualid_t,
}
#[test]
fn bindgen_test_layout_xcb_create_colormap_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_create_colormap_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_create_colormap_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_create_colormap_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_create_colormap_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_colormap_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_colormap_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_colormap_request_t>())).alloc as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_colormap_request_t),
            "::",
            stringify!(alloc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_colormap_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_colormap_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_colormap_request_t>())).mid as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_colormap_request_t),
            "::",
            stringify!(mid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_colormap_request_t>())).window as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_colormap_request_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_colormap_request_t>())).visual as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_colormap_request_t),
            "::",
            stringify!(visual)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_free_colormap_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
}
#[test]
fn bindgen_test_layout_xcb_free_colormap_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_free_colormap_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_free_colormap_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_free_colormap_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_free_colormap_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_free_colormap_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_colormap_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_free_colormap_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_colormap_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_free_colormap_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_colormap_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_free_colormap_request_t>())).cmap as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_colormap_request_t),
            "::",
            stringify!(cmap)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_copy_colormap_and_free_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub mid: xcb_colormap_t,
    pub src_cmap: xcb_colormap_t,
}
#[test]
fn bindgen_test_layout_xcb_copy_colormap_and_free_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_copy_colormap_and_free_request_t>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(xcb_copy_colormap_and_free_request_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_copy_colormap_and_free_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_copy_colormap_and_free_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_copy_colormap_and_free_request_t>())).major_opcode
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_colormap_and_free_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_copy_colormap_and_free_request_t>())).pad0 as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_colormap_and_free_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_copy_colormap_and_free_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_colormap_and_free_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_copy_colormap_and_free_request_t>())).mid as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_colormap_and_free_request_t),
            "::",
            stringify!(mid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_copy_colormap_and_free_request_t>())).src_cmap as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_colormap_and_free_request_t),
            "::",
            stringify!(src_cmap)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_install_colormap_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
}
#[test]
fn bindgen_test_layout_xcb_install_colormap_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_install_colormap_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_install_colormap_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_install_colormap_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_install_colormap_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_install_colormap_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_install_colormap_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_install_colormap_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_install_colormap_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_install_colormap_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_install_colormap_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_install_colormap_request_t>())).cmap as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_install_colormap_request_t),
            "::",
            stringify!(cmap)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_uninstall_colormap_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
}
#[test]
fn bindgen_test_layout_xcb_uninstall_colormap_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_uninstall_colormap_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_uninstall_colormap_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_uninstall_colormap_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_uninstall_colormap_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_uninstall_colormap_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_uninstall_colormap_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_uninstall_colormap_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_uninstall_colormap_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_uninstall_colormap_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_uninstall_colormap_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_uninstall_colormap_request_t>())).cmap as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_uninstall_colormap_request_t),
            "::",
            stringify!(cmap)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_installed_colormaps_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_list_installed_colormaps_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_list_installed_colormaps_cookie_t>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(xcb_list_installed_colormaps_cookie_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_list_installed_colormaps_cookie_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_list_installed_colormaps_cookie_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_installed_colormaps_cookie_t>())).sequence as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_installed_colormaps_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_installed_colormaps_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_list_installed_colormaps_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_list_installed_colormaps_request_t>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(xcb_list_installed_colormaps_request_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_list_installed_colormaps_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_list_installed_colormaps_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_installed_colormaps_request_t>())).major_opcode
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_installed_colormaps_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_installed_colormaps_request_t>())).pad0 as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_installed_colormaps_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_installed_colormaps_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_installed_colormaps_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_installed_colormaps_request_t>())).window as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_installed_colormaps_request_t),
            "::",
            stringify!(window)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_installed_colormaps_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub cmaps_len: u16,
    pub pad1: [u8; 22usize],
}
#[test]
fn bindgen_test_layout_xcb_list_installed_colormaps_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_list_installed_colormaps_reply_t>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(xcb_list_installed_colormaps_reply_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_list_installed_colormaps_reply_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_list_installed_colormaps_reply_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_installed_colormaps_reply_t>())).response_type
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_installed_colormaps_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_installed_colormaps_reply_t>())).pad0 as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_installed_colormaps_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_installed_colormaps_reply_t>())).sequence as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_installed_colormaps_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_installed_colormaps_reply_t>())).length as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_installed_colormaps_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_installed_colormaps_reply_t>())).cmaps_len as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_installed_colormaps_reply_t),
            "::",
            stringify!(cmaps_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_installed_colormaps_reply_t>())).pad1 as *const _
                as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_installed_colormaps_reply_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_alloc_color_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_alloc_color_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_alloc_color_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_alloc_color_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_alloc_color_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_alloc_color_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
    pub red: u16,
    pub green: u16,
    pub blue: u16,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_alloc_color_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_alloc_color_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_alloc_color_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_alloc_color_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_alloc_color_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_alloc_color_request_t>())).cmap as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_request_t),
            "::",
            stringify!(cmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_alloc_color_request_t>())).red as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_request_t),
            "::",
            stringify!(red)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_alloc_color_request_t>())).green as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_request_t),
            "::",
            stringify!(green)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_alloc_color_request_t>())).blue as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_request_t),
            "::",
            stringify!(blue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_alloc_color_request_t>())).pad1 as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_request_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_alloc_color_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub red: u16,
    pub green: u16,
    pub blue: u16,
    pub pad1: [u8; 2usize],
    pub pixel: u32,
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_alloc_color_reply_t>(),
        20usize,
        concat!("Size of: ", stringify!(xcb_alloc_color_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_alloc_color_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_alloc_color_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_reply_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_alloc_color_reply_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_alloc_color_reply_t>())).length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_alloc_color_reply_t>())).red as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_reply_t),
            "::",
            stringify!(red)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_alloc_color_reply_t>())).green as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_reply_t),
            "::",
            stringify!(green)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_alloc_color_reply_t>())).blue as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_reply_t),
            "::",
            stringify!(blue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_alloc_color_reply_t>())).pad1 as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_reply_t),
            "::",
            stringify!(pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_alloc_color_reply_t>())).pixel as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_reply_t),
            "::",
            stringify!(pixel)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_alloc_named_color_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_alloc_named_color_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_alloc_named_color_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_alloc_named_color_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_alloc_named_color_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_alloc_named_color_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_named_color_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_alloc_named_color_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
    pub name_len: u16,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_alloc_named_color_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_alloc_named_color_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_alloc_named_color_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_alloc_named_color_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_alloc_named_color_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_named_color_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_named_color_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_named_color_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_named_color_request_t>())).cmap as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_request_t),
            "::",
            stringify!(cmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_named_color_request_t>())).name_len as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_request_t),
            "::",
            stringify!(name_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_named_color_request_t>())).pad1 as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_request_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_alloc_named_color_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub pixel: u32,
    pub exact_red: u16,
    pub exact_green: u16,
    pub exact_blue: u16,
    pub visual_red: u16,
    pub visual_green: u16,
    pub visual_blue: u16,
}
#[test]
fn bindgen_test_layout_xcb_alloc_named_color_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_alloc_named_color_reply_t>(),
        24usize,
        concat!("Size of: ", stringify!(xcb_alloc_named_color_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_alloc_named_color_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_alloc_named_color_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_named_color_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_named_color_reply_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_named_color_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_named_color_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_named_color_reply_t>())).pixel as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_reply_t),
            "::",
            stringify!(pixel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_named_color_reply_t>())).exact_red as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_reply_t),
            "::",
            stringify!(exact_red)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_named_color_reply_t>())).exact_green as *const _
                as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_reply_t),
            "::",
            stringify!(exact_green)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_named_color_reply_t>())).exact_blue as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_reply_t),
            "::",
            stringify!(exact_blue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_named_color_reply_t>())).visual_red as *const _
                as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_reply_t),
            "::",
            stringify!(visual_red)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_named_color_reply_t>())).visual_green as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_reply_t),
            "::",
            stringify!(visual_green)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_named_color_reply_t>())).visual_blue as *const _
                as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_reply_t),
            "::",
            stringify!(visual_blue)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_alloc_color_cells_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_cells_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_alloc_color_cells_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_alloc_color_cells_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_alloc_color_cells_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_alloc_color_cells_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_cells_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_cells_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_alloc_color_cells_request_t {
    pub major_opcode: u8,
    pub contiguous: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
    pub colors: u16,
    pub planes: u16,
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_cells_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_alloc_color_cells_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_alloc_color_cells_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_alloc_color_cells_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_alloc_color_cells_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_cells_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_cells_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_cells_request_t>())).contiguous as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_cells_request_t),
            "::",
            stringify!(contiguous)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_cells_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_cells_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_cells_request_t>())).cmap as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_cells_request_t),
            "::",
            stringify!(cmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_cells_request_t>())).colors as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_cells_request_t),
            "::",
            stringify!(colors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_cells_request_t>())).planes as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_cells_request_t),
            "::",
            stringify!(planes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_alloc_color_cells_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub pixels_len: u16,
    pub masks_len: u16,
    pub pad1: [u8; 20usize],
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_cells_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_alloc_color_cells_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_alloc_color_cells_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_alloc_color_cells_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_alloc_color_cells_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_cells_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_cells_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_cells_reply_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_cells_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_cells_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_cells_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_cells_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_cells_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_cells_reply_t>())).pixels_len as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_cells_reply_t),
            "::",
            stringify!(pixels_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_cells_reply_t>())).masks_len as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_cells_reply_t),
            "::",
            stringify!(masks_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_cells_reply_t>())).pad1 as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_cells_reply_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_alloc_color_planes_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_planes_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_alloc_color_planes_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_alloc_color_planes_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_alloc_color_planes_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_alloc_color_planes_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_planes_cookie_t>())).sequence as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_alloc_color_planes_request_t {
    pub major_opcode: u8,
    pub contiguous: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
    pub colors: u16,
    pub reds: u16,
    pub greens: u16,
    pub blues: u16,
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_planes_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_alloc_color_planes_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_alloc_color_planes_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_alloc_color_planes_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_alloc_color_planes_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_planes_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_planes_request_t>())).contiguous as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_request_t),
            "::",
            stringify!(contiguous)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_planes_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_planes_request_t>())).cmap as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_request_t),
            "::",
            stringify!(cmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_planes_request_t>())).colors as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_request_t),
            "::",
            stringify!(colors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_planes_request_t>())).reds as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_request_t),
            "::",
            stringify!(reds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_planes_request_t>())).greens as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_request_t),
            "::",
            stringify!(greens)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_planes_request_t>())).blues as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_request_t),
            "::",
            stringify!(blues)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_alloc_color_planes_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub pixels_len: u16,
    pub pad1: [u8; 2usize],
    pub red_mask: u32,
    pub green_mask: u32,
    pub blue_mask: u32,
    pub pad2: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_planes_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_alloc_color_planes_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_alloc_color_planes_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_alloc_color_planes_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_alloc_color_planes_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_planes_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_planes_reply_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_planes_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_planes_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_planes_reply_t>())).pixels_len as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_reply_t),
            "::",
            stringify!(pixels_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_planes_reply_t>())).pad1 as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_reply_t),
            "::",
            stringify!(pad1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_planes_reply_t>())).red_mask as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_reply_t),
            "::",
            stringify!(red_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_planes_reply_t>())).green_mask as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_reply_t),
            "::",
            stringify!(green_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_planes_reply_t>())).blue_mask as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_reply_t),
            "::",
            stringify!(blue_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_planes_reply_t>())).pad2 as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_reply_t),
            "::",
            stringify!(pad2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_free_colors_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
    pub plane_mask: u32,
}
#[test]
fn bindgen_test_layout_xcb_free_colors_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_free_colors_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_free_colors_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_free_colors_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_free_colors_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_free_colors_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_colors_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_free_colors_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_colors_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_free_colors_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_colors_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_free_colors_request_t>())).cmap as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_colors_request_t),
            "::",
            stringify!(cmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_free_colors_request_t>())).plane_mask as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_colors_request_t),
            "::",
            stringify!(plane_mask)
        )
    );
}
pub mod xcb_color_flag_t {
    pub type Type = u32;
    pub const XCB_COLOR_FLAG_RED: Type = 1;
    pub const XCB_COLOR_FLAG_GREEN: Type = 2;
    pub const XCB_COLOR_FLAG_BLUE: Type = 4;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_coloritem_t {
    pub pixel: u32,
    pub red: u16,
    pub green: u16,
    pub blue: u16,
    pub flags: u8,
    pub pad0: u8,
}
#[test]
fn bindgen_test_layout_xcb_coloritem_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_coloritem_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_coloritem_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_coloritem_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_coloritem_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_coloritem_t>())).pixel as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_coloritem_t),
            "::",
            stringify!(pixel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_coloritem_t>())).red as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_coloritem_t),
            "::",
            stringify!(red)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_coloritem_t>())).green as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_coloritem_t),
            "::",
            stringify!(green)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_coloritem_t>())).blue as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_coloritem_t),
            "::",
            stringify!(blue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_coloritem_t>())).flags as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_coloritem_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_coloritem_t>())).pad0 as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_coloritem_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_coloritem_iterator_t {
    pub data: *mut xcb_coloritem_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_coloritem_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_coloritem_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_coloritem_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_coloritem_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_coloritem_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_coloritem_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_coloritem_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_coloritem_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_coloritem_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_coloritem_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_coloritem_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_store_colors_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
}
#[test]
fn bindgen_test_layout_xcb_store_colors_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_store_colors_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_store_colors_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_store_colors_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_store_colors_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_store_colors_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_store_colors_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_store_colors_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_store_colors_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_store_colors_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_store_colors_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_store_colors_request_t>())).cmap as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_store_colors_request_t),
            "::",
            stringify!(cmap)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_store_named_color_request_t {
    pub major_opcode: u8,
    pub flags: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
    pub pixel: u32,
    pub name_len: u16,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_store_named_color_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_store_named_color_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_store_named_color_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_store_named_color_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_store_named_color_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_store_named_color_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_store_named_color_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_store_named_color_request_t>())).flags as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_store_named_color_request_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_store_named_color_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_store_named_color_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_store_named_color_request_t>())).cmap as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_store_named_color_request_t),
            "::",
            stringify!(cmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_store_named_color_request_t>())).pixel as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_store_named_color_request_t),
            "::",
            stringify!(pixel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_store_named_color_request_t>())).name_len as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_store_named_color_request_t),
            "::",
            stringify!(name_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_store_named_color_request_t>())).pad0 as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_store_named_color_request_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_rgb_t {
    pub red: u16,
    pub green: u16,
    pub blue: u16,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_rgb_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_rgb_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_rgb_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_rgb_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_rgb_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_rgb_t>())).red as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rgb_t),
            "::",
            stringify!(red)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_rgb_t>())).green as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rgb_t),
            "::",
            stringify!(green)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_rgb_t>())).blue as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rgb_t),
            "::",
            stringify!(blue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_rgb_t>())).pad0 as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rgb_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_rgb_iterator_t {
    pub data: *mut xcb_rgb_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_rgb_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_rgb_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_rgb_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_rgb_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_rgb_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_rgb_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rgb_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_rgb_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rgb_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_rgb_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rgb_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_colors_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_query_colors_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_query_colors_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_query_colors_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_colors_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_colors_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_colors_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_colors_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_colors_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
}
#[test]
fn bindgen_test_layout_xcb_query_colors_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_query_colors_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_query_colors_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_colors_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_colors_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_colors_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_colors_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_colors_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_colors_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_colors_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_colors_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_colors_request_t>())).cmap as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_colors_request_t),
            "::",
            stringify!(cmap)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_colors_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub colors_len: u16,
    pub pad1: [u8; 22usize],
}
#[test]
fn bindgen_test_layout_xcb_query_colors_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_query_colors_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_query_colors_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_colors_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_colors_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_colors_reply_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_colors_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_colors_reply_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_colors_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_colors_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_colors_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_colors_reply_t>())).length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_colors_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_colors_reply_t>())).colors_len as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_colors_reply_t),
            "::",
            stringify!(colors_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_colors_reply_t>())).pad1 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_colors_reply_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_lookup_color_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_lookup_color_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_lookup_color_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_lookup_color_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_lookup_color_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_lookup_color_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_lookup_color_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_lookup_color_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
    pub name_len: u16,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_lookup_color_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_lookup_color_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_lookup_color_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_lookup_color_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_lookup_color_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_lookup_color_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_lookup_color_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_lookup_color_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_lookup_color_request_t>())).cmap as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_request_t),
            "::",
            stringify!(cmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_lookup_color_request_t>())).name_len as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_request_t),
            "::",
            stringify!(name_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_lookup_color_request_t>())).pad1 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_request_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_lookup_color_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub exact_red: u16,
    pub exact_green: u16,
    pub exact_blue: u16,
    pub visual_red: u16,
    pub visual_green: u16,
    pub visual_blue: u16,
}
#[test]
fn bindgen_test_layout_xcb_lookup_color_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_lookup_color_reply_t>(),
        20usize,
        concat!("Size of: ", stringify!(xcb_lookup_color_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_lookup_color_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_lookup_color_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_lookup_color_reply_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_lookup_color_reply_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_lookup_color_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_lookup_color_reply_t>())).length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_lookup_color_reply_t>())).exact_red as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_reply_t),
            "::",
            stringify!(exact_red)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_lookup_color_reply_t>())).exact_green as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_reply_t),
            "::",
            stringify!(exact_green)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_lookup_color_reply_t>())).exact_blue as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_reply_t),
            "::",
            stringify!(exact_blue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_lookup_color_reply_t>())).visual_red as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_reply_t),
            "::",
            stringify!(visual_red)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_lookup_color_reply_t>())).visual_green as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_reply_t),
            "::",
            stringify!(visual_green)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_lookup_color_reply_t>())).visual_blue as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_reply_t),
            "::",
            stringify!(visual_blue)
        )
    );
}
pub mod xcb_pixmap_enum_t {
    pub type Type = u32;
    pub const XCB_PIXMAP_NONE: Type = 0;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_create_cursor_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cid: xcb_cursor_t,
    pub source: xcb_pixmap_t,
    pub mask: xcb_pixmap_t,
    pub fore_red: u16,
    pub fore_green: u16,
    pub fore_blue: u16,
    pub back_red: u16,
    pub back_green: u16,
    pub back_blue: u16,
    pub x: u16,
    pub y: u16,
}
#[test]
fn bindgen_test_layout_xcb_create_cursor_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_create_cursor_request_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_create_cursor_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_create_cursor_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_create_cursor_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_cursor_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_cursor_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_cursor_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_cursor_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_cursor_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_cursor_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_create_cursor_request_t>())).cid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_cursor_request_t),
            "::",
            stringify!(cid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_cursor_request_t>())).source as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_cursor_request_t),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_cursor_request_t>())).mask as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_cursor_request_t),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_cursor_request_t>())).fore_red as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_cursor_request_t),
            "::",
            stringify!(fore_red)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_cursor_request_t>())).fore_green as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_cursor_request_t),
            "::",
            stringify!(fore_green)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_cursor_request_t>())).fore_blue as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_cursor_request_t),
            "::",
            stringify!(fore_blue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_cursor_request_t>())).back_red as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_cursor_request_t),
            "::",
            stringify!(back_red)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_cursor_request_t>())).back_green as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_cursor_request_t),
            "::",
            stringify!(back_green)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_cursor_request_t>())).back_blue as *const _ as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_cursor_request_t),
            "::",
            stringify!(back_blue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_create_cursor_request_t>())).x as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_cursor_request_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_create_cursor_request_t>())).y as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_cursor_request_t),
            "::",
            stringify!(y)
        )
    );
}
pub mod xcb_font_enum_t {
    pub type Type = u32;
    pub const XCB_FONT_NONE: Type = 0;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_create_glyph_cursor_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cid: xcb_cursor_t,
    pub source_font: xcb_font_t,
    pub mask_font: xcb_font_t,
    pub source_char: u16,
    pub mask_char: u16,
    pub fore_red: u16,
    pub fore_green: u16,
    pub fore_blue: u16,
    pub back_red: u16,
    pub back_green: u16,
    pub back_blue: u16,
}
#[test]
fn bindgen_test_layout_xcb_create_glyph_cursor_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_create_glyph_cursor_request_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_create_glyph_cursor_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_create_glyph_cursor_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_create_glyph_cursor_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_glyph_cursor_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_glyph_cursor_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_glyph_cursor_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_glyph_cursor_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_glyph_cursor_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_glyph_cursor_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_glyph_cursor_request_t>())).cid as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_glyph_cursor_request_t),
            "::",
            stringify!(cid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_glyph_cursor_request_t>())).source_font as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_glyph_cursor_request_t),
            "::",
            stringify!(source_font)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_glyph_cursor_request_t>())).mask_font as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_glyph_cursor_request_t),
            "::",
            stringify!(mask_font)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_glyph_cursor_request_t>())).source_char as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_glyph_cursor_request_t),
            "::",
            stringify!(source_char)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_glyph_cursor_request_t>())).mask_char as *const _
                as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_glyph_cursor_request_t),
            "::",
            stringify!(mask_char)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_glyph_cursor_request_t>())).fore_red as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_glyph_cursor_request_t),
            "::",
            stringify!(fore_red)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_glyph_cursor_request_t>())).fore_green as *const _
                as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_glyph_cursor_request_t),
            "::",
            stringify!(fore_green)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_glyph_cursor_request_t>())).fore_blue as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_glyph_cursor_request_t),
            "::",
            stringify!(fore_blue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_glyph_cursor_request_t>())).back_red as *const _
                as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_glyph_cursor_request_t),
            "::",
            stringify!(back_red)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_glyph_cursor_request_t>())).back_green as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_glyph_cursor_request_t),
            "::",
            stringify!(back_green)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_glyph_cursor_request_t>())).back_blue as *const _
                as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_glyph_cursor_request_t),
            "::",
            stringify!(back_blue)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_free_cursor_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cursor: xcb_cursor_t,
}
#[test]
fn bindgen_test_layout_xcb_free_cursor_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_free_cursor_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_free_cursor_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_free_cursor_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_free_cursor_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_free_cursor_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_cursor_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_free_cursor_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_cursor_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_free_cursor_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_cursor_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_free_cursor_request_t>())).cursor as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_cursor_request_t),
            "::",
            stringify!(cursor)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_recolor_cursor_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cursor: xcb_cursor_t,
    pub fore_red: u16,
    pub fore_green: u16,
    pub fore_blue: u16,
    pub back_red: u16,
    pub back_green: u16,
    pub back_blue: u16,
}
#[test]
fn bindgen_test_layout_xcb_recolor_cursor_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_recolor_cursor_request_t>(),
        20usize,
        concat!("Size of: ", stringify!(xcb_recolor_cursor_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_recolor_cursor_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_recolor_cursor_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_recolor_cursor_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_recolor_cursor_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_recolor_cursor_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_recolor_cursor_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_recolor_cursor_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_recolor_cursor_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_recolor_cursor_request_t>())).cursor as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_recolor_cursor_request_t),
            "::",
            stringify!(cursor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_recolor_cursor_request_t>())).fore_red as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_recolor_cursor_request_t),
            "::",
            stringify!(fore_red)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_recolor_cursor_request_t>())).fore_green as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_recolor_cursor_request_t),
            "::",
            stringify!(fore_green)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_recolor_cursor_request_t>())).fore_blue as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_recolor_cursor_request_t),
            "::",
            stringify!(fore_blue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_recolor_cursor_request_t>())).back_red as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_recolor_cursor_request_t),
            "::",
            stringify!(back_red)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_recolor_cursor_request_t>())).back_green as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_recolor_cursor_request_t),
            "::",
            stringify!(back_green)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_recolor_cursor_request_t>())).back_blue as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_recolor_cursor_request_t),
            "::",
            stringify!(back_blue)
        )
    );
}
pub mod xcb_query_shape_of_t {
    pub type Type = u32;
    pub const XCB_QUERY_SHAPE_OF_LARGEST_CURSOR: Type = 0;
    pub const XCB_QUERY_SHAPE_OF_FASTEST_TILE: Type = 1;
    pub const XCB_QUERY_SHAPE_OF_FASTEST_STIPPLE: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_best_size_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_query_best_size_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_query_best_size_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_query_best_size_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_best_size_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_best_size_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_best_size_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_best_size_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_best_size_request_t {
    pub major_opcode: u8,
    pub _class: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub width: u16,
    pub height: u16,
}
#[test]
fn bindgen_test_layout_xcb_query_best_size_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_query_best_size_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_query_best_size_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_best_size_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_best_size_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_best_size_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_best_size_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_best_size_request_t>()))._class as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_best_size_request_t),
            "::",
            stringify!(_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_best_size_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_best_size_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_best_size_request_t>())).drawable as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_best_size_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_best_size_request_t>())).width as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_best_size_request_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_best_size_request_t>())).height as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_best_size_request_t),
            "::",
            stringify!(height)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_best_size_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub width: u16,
    pub height: u16,
}
#[test]
fn bindgen_test_layout_xcb_query_best_size_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_query_best_size_reply_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_query_best_size_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_best_size_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_best_size_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_best_size_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_best_size_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_best_size_reply_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_best_size_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_best_size_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_best_size_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_best_size_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_best_size_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_best_size_reply_t>())).width as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_best_size_reply_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_best_size_reply_t>())).height as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_best_size_reply_t),
            "::",
            stringify!(height)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_extension_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_query_extension_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_query_extension_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_query_extension_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_extension_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_extension_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_extension_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_extension_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_extension_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub name_len: u16,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_query_extension_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_query_extension_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_query_extension_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_extension_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_query_extension_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_extension_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_extension_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_extension_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_extension_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_extension_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_extension_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_extension_request_t>())).name_len as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_extension_request_t),
            "::",
            stringify!(name_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_extension_request_t>())).pad1 as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_extension_request_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_extension_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub present: u8,
    pub major_opcode: u8,
    pub first_event: u8,
    pub first_error: u8,
}
#[test]
fn bindgen_test_layout_xcb_query_extension_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_query_extension_reply_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_query_extension_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_extension_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_extension_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_extension_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_extension_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_extension_reply_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_extension_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_extension_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_extension_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_extension_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_extension_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_extension_reply_t>())).present as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_extension_reply_t),
            "::",
            stringify!(present)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_extension_reply_t>())).major_opcode as *const _
                as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_extension_reply_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_extension_reply_t>())).first_event as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_extension_reply_t),
            "::",
            stringify!(first_event)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_extension_reply_t>())).first_error as *const _ as usize
        },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_extension_reply_t),
            "::",
            stringify!(first_error)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_extensions_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_list_extensions_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_list_extensions_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_list_extensions_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_list_extensions_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_list_extensions_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_extensions_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_extensions_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_extensions_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_list_extensions_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_list_extensions_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_list_extensions_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_list_extensions_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_list_extensions_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_extensions_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_extensions_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_extensions_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_extensions_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_extensions_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_extensions_request_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_extensions_reply_t {
    pub response_type: u8,
    pub names_len: u8,
    pub sequence: u16,
    pub length: u32,
    pub pad0: [u8; 24usize],
}
#[test]
fn bindgen_test_layout_xcb_list_extensions_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_list_extensions_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_list_extensions_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_list_extensions_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_list_extensions_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_extensions_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_extensions_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_extensions_reply_t>())).names_len as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_extensions_reply_t),
            "::",
            stringify!(names_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_extensions_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_extensions_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_extensions_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_extensions_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_extensions_reply_t>())).pad0 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_extensions_reply_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_change_keyboard_mapping_request_t {
    pub major_opcode: u8,
    pub keycode_count: u8,
    pub length: u16,
    pub first_keycode: xcb_keycode_t,
    pub keysyms_per_keycode: u8,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_change_keyboard_mapping_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_change_keyboard_mapping_request_t>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(xcb_change_keyboard_mapping_request_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_change_keyboard_mapping_request_t>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_change_keyboard_mapping_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_keyboard_mapping_request_t>())).major_opcode
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_mapping_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_keyboard_mapping_request_t>())).keycode_count
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_mapping_request_t),
            "::",
            stringify!(keycode_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_keyboard_mapping_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_mapping_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_keyboard_mapping_request_t>())).first_keycode
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_mapping_request_t),
            "::",
            stringify!(first_keycode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_keyboard_mapping_request_t>())).keysyms_per_keycode
                as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_mapping_request_t),
            "::",
            stringify!(keysyms_per_keycode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_keyboard_mapping_request_t>())).pad0 as *const _
                as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_mapping_request_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_keyboard_mapping_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_keyboard_mapping_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_keyboard_mapping_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_keyboard_mapping_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_keyboard_mapping_cookie_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_keyboard_mapping_cookie_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_keyboard_mapping_cookie_t>())).sequence as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_mapping_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_keyboard_mapping_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub first_keycode: xcb_keycode_t,
    pub count: u8,
}
#[test]
fn bindgen_test_layout_xcb_get_keyboard_mapping_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_keyboard_mapping_request_t>(),
        6usize,
        concat!("Size of: ", stringify!(xcb_get_keyboard_mapping_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_keyboard_mapping_request_t>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_keyboard_mapping_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_keyboard_mapping_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_mapping_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_keyboard_mapping_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_mapping_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_keyboard_mapping_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_mapping_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_keyboard_mapping_request_t>())).first_keycode as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_mapping_request_t),
            "::",
            stringify!(first_keycode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_keyboard_mapping_request_t>())).count as *const _
                as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_mapping_request_t),
            "::",
            stringify!(count)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_keyboard_mapping_reply_t {
    pub response_type: u8,
    pub keysyms_per_keycode: u8,
    pub sequence: u16,
    pub length: u32,
    pub pad0: [u8; 24usize],
}
#[test]
fn bindgen_test_layout_xcb_get_keyboard_mapping_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_keyboard_mapping_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_get_keyboard_mapping_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_keyboard_mapping_reply_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_keyboard_mapping_reply_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_keyboard_mapping_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_mapping_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_keyboard_mapping_reply_t>())).keysyms_per_keycode
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_mapping_reply_t),
            "::",
            stringify!(keysyms_per_keycode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_keyboard_mapping_reply_t>())).sequence as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_mapping_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_keyboard_mapping_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_mapping_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_keyboard_mapping_reply_t>())).pad0 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_mapping_reply_t),
            "::",
            stringify!(pad0)
        )
    );
}
pub mod xcb_kb_t {
    pub type Type = u32;
    pub const XCB_KB_KEY_CLICK_PERCENT: Type = 1;
    pub const XCB_KB_BELL_PERCENT: Type = 2;
    pub const XCB_KB_BELL_PITCH: Type = 4;
    pub const XCB_KB_BELL_DURATION: Type = 8;
    pub const XCB_KB_LED: Type = 16;
    pub const XCB_KB_LED_MODE: Type = 32;
    pub const XCB_KB_KEY: Type = 64;
    pub const XCB_KB_AUTO_REPEAT_MODE: Type = 128;
}
pub mod xcb_led_mode_t {
    pub type Type = u32;
    pub const XCB_LED_MODE_OFF: Type = 0;
    pub const XCB_LED_MODE_ON: Type = 1;
}
pub mod xcb_auto_repeat_mode_t {
    pub type Type = u32;
    pub const XCB_AUTO_REPEAT_MODE_OFF: Type = 0;
    pub const XCB_AUTO_REPEAT_MODE_ON: Type = 1;
    pub const XCB_AUTO_REPEAT_MODE_DEFAULT: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_change_keyboard_control_value_list_t {
    pub key_click_percent: i32,
    pub bell_percent: i32,
    pub bell_pitch: i32,
    pub bell_duration: i32,
    pub led: u32,
    pub led_mode: u32,
    pub key: xcb_keycode32_t,
    pub auto_repeat_mode: u32,
}
#[test]
fn bindgen_test_layout_xcb_change_keyboard_control_value_list_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_change_keyboard_control_value_list_t>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(xcb_change_keyboard_control_value_list_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_change_keyboard_control_value_list_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_change_keyboard_control_value_list_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_keyboard_control_value_list_t>())).key_click_percent
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_control_value_list_t),
            "::",
            stringify!(key_click_percent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_keyboard_control_value_list_t>())).bell_percent
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_control_value_list_t),
            "::",
            stringify!(bell_percent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_keyboard_control_value_list_t>())).bell_pitch
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_control_value_list_t),
            "::",
            stringify!(bell_pitch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_keyboard_control_value_list_t>())).bell_duration
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_control_value_list_t),
            "::",
            stringify!(bell_duration)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_keyboard_control_value_list_t>())).led as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_control_value_list_t),
            "::",
            stringify!(led)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_keyboard_control_value_list_t>())).led_mode
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_control_value_list_t),
            "::",
            stringify!(led_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_keyboard_control_value_list_t>())).key as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_control_value_list_t),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_keyboard_control_value_list_t>())).auto_repeat_mode
                as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_control_value_list_t),
            "::",
            stringify!(auto_repeat_mode)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_change_keyboard_control_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub value_mask: u32,
}
#[test]
fn bindgen_test_layout_xcb_change_keyboard_control_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_change_keyboard_control_request_t>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(xcb_change_keyboard_control_request_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_change_keyboard_control_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_change_keyboard_control_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_keyboard_control_request_t>())).major_opcode
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_control_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_keyboard_control_request_t>())).pad0 as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_control_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_keyboard_control_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_control_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_keyboard_control_request_t>())).value_mask as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_control_request_t),
            "::",
            stringify!(value_mask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_keyboard_control_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_keyboard_control_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_keyboard_control_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_keyboard_control_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_keyboard_control_cookie_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_keyboard_control_cookie_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_keyboard_control_cookie_t>())).sequence as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_control_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_keyboard_control_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_get_keyboard_control_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_keyboard_control_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_keyboard_control_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_keyboard_control_request_t>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_keyboard_control_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_keyboard_control_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_control_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_keyboard_control_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_control_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_keyboard_control_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_control_request_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_keyboard_control_reply_t {
    pub response_type: u8,
    pub global_auto_repeat: u8,
    pub sequence: u16,
    pub length: u32,
    pub led_mask: u32,
    pub key_click_percent: u8,
    pub bell_percent: u8,
    pub bell_pitch: u16,
    pub bell_duration: u16,
    pub pad0: [u8; 2usize],
    pub auto_repeats: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_xcb_get_keyboard_control_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_keyboard_control_reply_t>(),
        52usize,
        concat!("Size of: ", stringify!(xcb_get_keyboard_control_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_keyboard_control_reply_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_keyboard_control_reply_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_keyboard_control_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_control_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_keyboard_control_reply_t>())).global_auto_repeat
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_control_reply_t),
            "::",
            stringify!(global_auto_repeat)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_keyboard_control_reply_t>())).sequence as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_control_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_keyboard_control_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_control_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_keyboard_control_reply_t>())).led_mask as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_control_reply_t),
            "::",
            stringify!(led_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_keyboard_control_reply_t>())).key_click_percent
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_control_reply_t),
            "::",
            stringify!(key_click_percent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_keyboard_control_reply_t>())).bell_percent as *const _
                as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_control_reply_t),
            "::",
            stringify!(bell_percent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_keyboard_control_reply_t>())).bell_pitch as *const _
                as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_control_reply_t),
            "::",
            stringify!(bell_pitch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_keyboard_control_reply_t>())).bell_duration as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_control_reply_t),
            "::",
            stringify!(bell_duration)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_keyboard_control_reply_t>())).pad0 as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_control_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_keyboard_control_reply_t>())).auto_repeats as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_control_reply_t),
            "::",
            stringify!(auto_repeats)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_bell_request_t {
    pub major_opcode: u8,
    pub percent: i8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_bell_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_bell_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_bell_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_bell_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_bell_request_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_bell_request_t>())).major_opcode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_bell_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_bell_request_t>())).percent as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_bell_request_t),
            "::",
            stringify!(percent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_bell_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_bell_request_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_change_pointer_control_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub acceleration_numerator: i16,
    pub acceleration_denominator: i16,
    pub threshold: i16,
    pub do_acceleration: u8,
    pub do_threshold: u8,
}
#[test]
fn bindgen_test_layout_xcb_change_pointer_control_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_change_pointer_control_request_t>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(xcb_change_pointer_control_request_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_change_pointer_control_request_t>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_change_pointer_control_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_pointer_control_request_t>())).major_opcode
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_pointer_control_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_pointer_control_request_t>())).pad0 as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_pointer_control_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_pointer_control_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_pointer_control_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_pointer_control_request_t>())).acceleration_numerator
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_pointer_control_request_t),
            "::",
            stringify!(acceleration_numerator)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_pointer_control_request_t>()))
                .acceleration_denominator as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_pointer_control_request_t),
            "::",
            stringify!(acceleration_denominator)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_pointer_control_request_t>())).threshold as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_pointer_control_request_t),
            "::",
            stringify!(threshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_pointer_control_request_t>())).do_acceleration
                as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_pointer_control_request_t),
            "::",
            stringify!(do_acceleration)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_pointer_control_request_t>())).do_threshold
                as *const _ as usize
        },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_pointer_control_request_t),
            "::",
            stringify!(do_threshold)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_pointer_control_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_pointer_control_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_pointer_control_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_pointer_control_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_pointer_control_cookie_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_pointer_control_cookie_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_pointer_control_cookie_t>())).sequence as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_control_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_pointer_control_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_get_pointer_control_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_pointer_control_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_pointer_control_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_pointer_control_request_t>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_pointer_control_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_pointer_control_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_control_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_pointer_control_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_control_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_pointer_control_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_control_request_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_pointer_control_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub acceleration_numerator: u16,
    pub acceleration_denominator: u16,
    pub threshold: u16,
    pub pad1: [u8; 18usize],
}
#[test]
fn bindgen_test_layout_xcb_get_pointer_control_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_pointer_control_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_get_pointer_control_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_pointer_control_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_pointer_control_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_pointer_control_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_control_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_pointer_control_reply_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_control_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_pointer_control_reply_t>())).sequence as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_control_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_pointer_control_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_control_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_pointer_control_reply_t>())).acceleration_numerator
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_control_reply_t),
            "::",
            stringify!(acceleration_numerator)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_pointer_control_reply_t>())).acceleration_denominator
                as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_control_reply_t),
            "::",
            stringify!(acceleration_denominator)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_pointer_control_reply_t>())).threshold as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_control_reply_t),
            "::",
            stringify!(threshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_pointer_control_reply_t>())).pad1 as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_control_reply_t),
            "::",
            stringify!(pad1)
        )
    );
}
pub mod xcb_blanking_t {
    pub type Type = u32;
    pub const XCB_BLANKING_NOT_PREFERRED: Type = 0;
    pub const XCB_BLANKING_PREFERRED: Type = 1;
    pub const XCB_BLANKING_DEFAULT: Type = 2;
}
pub mod xcb_exposures_t {
    pub type Type = u32;
    pub const XCB_EXPOSURES_NOT_ALLOWED: Type = 0;
    pub const XCB_EXPOSURES_ALLOWED: Type = 1;
    pub const XCB_EXPOSURES_DEFAULT: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_set_screen_saver_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub timeout: i16,
    pub interval: i16,
    pub prefer_blanking: u8,
    pub allow_exposures: u8,
}
#[test]
fn bindgen_test_layout_xcb_set_screen_saver_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_set_screen_saver_request_t>(),
        10usize,
        concat!("Size of: ", stringify!(xcb_set_screen_saver_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_set_screen_saver_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_set_screen_saver_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_screen_saver_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_screen_saver_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_screen_saver_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_screen_saver_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_screen_saver_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_screen_saver_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_screen_saver_request_t>())).timeout as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_screen_saver_request_t),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_screen_saver_request_t>())).interval as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_screen_saver_request_t),
            "::",
            stringify!(interval)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_screen_saver_request_t>())).prefer_blanking as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_screen_saver_request_t),
            "::",
            stringify!(prefer_blanking)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_screen_saver_request_t>())).allow_exposures as *const _
                as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_screen_saver_request_t),
            "::",
            stringify!(allow_exposures)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_screen_saver_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_screen_saver_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_screen_saver_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_screen_saver_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_screen_saver_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_screen_saver_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_screen_saver_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_screen_saver_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_screen_saver_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_get_screen_saver_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_screen_saver_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_screen_saver_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_screen_saver_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_get_screen_saver_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_screen_saver_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_screen_saver_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_screen_saver_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_screen_saver_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_screen_saver_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_screen_saver_request_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_screen_saver_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub timeout: u16,
    pub interval: u16,
    pub prefer_blanking: u8,
    pub allow_exposures: u8,
    pub pad1: [u8; 18usize],
}
#[test]
fn bindgen_test_layout_xcb_get_screen_saver_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_screen_saver_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_get_screen_saver_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_screen_saver_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_screen_saver_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_screen_saver_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_screen_saver_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_screen_saver_reply_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_screen_saver_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_screen_saver_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_screen_saver_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_screen_saver_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_screen_saver_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_screen_saver_reply_t>())).timeout as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_screen_saver_reply_t),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_screen_saver_reply_t>())).interval as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_screen_saver_reply_t),
            "::",
            stringify!(interval)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_screen_saver_reply_t>())).prefer_blanking as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_screen_saver_reply_t),
            "::",
            stringify!(prefer_blanking)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_screen_saver_reply_t>())).allow_exposures as *const _
                as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_screen_saver_reply_t),
            "::",
            stringify!(allow_exposures)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_screen_saver_reply_t>())).pad1 as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_screen_saver_reply_t),
            "::",
            stringify!(pad1)
        )
    );
}
pub mod xcb_host_mode_t {
    pub type Type = u32;
    pub const XCB_HOST_MODE_INSERT: Type = 0;
    pub const XCB_HOST_MODE_DELETE: Type = 1;
}
pub mod xcb_family_t {
    pub type Type = u32;
    pub const XCB_FAMILY_INTERNET: Type = 0;
    pub const XCB_FAMILY_DECNET: Type = 1;
    pub const XCB_FAMILY_CHAOS: Type = 2;
    pub const XCB_FAMILY_SERVER_INTERPRETED: Type = 5;
    pub const XCB_FAMILY_INTERNET_6: Type = 6;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_change_hosts_request_t {
    pub major_opcode: u8,
    pub mode: u8,
    pub length: u16,
    pub family: u8,
    pub pad0: u8,
    pub address_len: u16,
}
#[test]
fn bindgen_test_layout_xcb_change_hosts_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_change_hosts_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_change_hosts_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_change_hosts_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_change_hosts_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_hosts_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_hosts_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_change_hosts_request_t>())).mode as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_hosts_request_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_hosts_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_hosts_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_hosts_request_t>())).family as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_hosts_request_t),
            "::",
            stringify!(family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_change_hosts_request_t>())).pad0 as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_hosts_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_hosts_request_t>())).address_len as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_hosts_request_t),
            "::",
            stringify!(address_len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_host_t {
    pub family: u8,
    pub pad0: u8,
    pub address_len: u16,
}
#[test]
fn bindgen_test_layout_xcb_host_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_host_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_host_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_host_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_host_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_host_t>())).family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_host_t),
            "::",
            stringify!(family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_host_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_host_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_host_t>())).address_len as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_host_t),
            "::",
            stringify!(address_len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_host_iterator_t {
    pub data: *mut xcb_host_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_host_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_host_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_host_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_host_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_host_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_host_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_host_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_host_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_host_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_host_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_host_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_hosts_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_list_hosts_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_list_hosts_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_list_hosts_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_list_hosts_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_list_hosts_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_hosts_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_hosts_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_hosts_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_list_hosts_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_list_hosts_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_list_hosts_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_list_hosts_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_list_hosts_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_hosts_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_hosts_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_list_hosts_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_hosts_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_list_hosts_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_hosts_request_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_hosts_reply_t {
    pub response_type: u8,
    pub mode: u8,
    pub sequence: u16,
    pub length: u32,
    pub hosts_len: u16,
    pub pad0: [u8; 22usize],
}
#[test]
fn bindgen_test_layout_xcb_list_hosts_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_list_hosts_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_list_hosts_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_list_hosts_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_list_hosts_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_hosts_reply_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_hosts_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_list_hosts_reply_t>())).mode as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_hosts_reply_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_list_hosts_reply_t>())).sequence as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_hosts_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_list_hosts_reply_t>())).length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_hosts_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_hosts_reply_t>())).hosts_len as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_hosts_reply_t),
            "::",
            stringify!(hosts_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_list_hosts_reply_t>())).pad0 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_hosts_reply_t),
            "::",
            stringify!(pad0)
        )
    );
}
pub mod xcb_access_control_t {
    pub type Type = u32;
    pub const XCB_ACCESS_CONTROL_DISABLE: Type = 0;
    pub const XCB_ACCESS_CONTROL_ENABLE: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_set_access_control_request_t {
    pub major_opcode: u8,
    pub mode: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_set_access_control_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_set_access_control_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_set_access_control_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_set_access_control_request_t>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_set_access_control_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_access_control_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_access_control_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_access_control_request_t>())).mode as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_access_control_request_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_access_control_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_access_control_request_t),
            "::",
            stringify!(length)
        )
    );
}
pub mod xcb_close_down_t {
    pub type Type = u32;
    pub const XCB_CLOSE_DOWN_DESTROY_ALL: Type = 0;
    pub const XCB_CLOSE_DOWN_RETAIN_PERMANENT: Type = 1;
    pub const XCB_CLOSE_DOWN_RETAIN_TEMPORARY: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_set_close_down_mode_request_t {
    pub major_opcode: u8,
    pub mode: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_set_close_down_mode_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_set_close_down_mode_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_set_close_down_mode_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_set_close_down_mode_request_t>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_set_close_down_mode_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_close_down_mode_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_close_down_mode_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_close_down_mode_request_t>())).mode as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_close_down_mode_request_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_close_down_mode_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_close_down_mode_request_t),
            "::",
            stringify!(length)
        )
    );
}
pub mod xcb_kill_t {
    pub type Type = u32;
    pub const XCB_KILL_ALL_TEMPORARY: Type = 0;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_kill_client_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub resource: u32,
}
#[test]
fn bindgen_test_layout_xcb_kill_client_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_kill_client_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_kill_client_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_kill_client_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_kill_client_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_kill_client_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_kill_client_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_kill_client_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_kill_client_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_kill_client_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_kill_client_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_kill_client_request_t>())).resource as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_kill_client_request_t),
            "::",
            stringify!(resource)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_rotate_properties_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
    pub atoms_len: u16,
    pub delta: i16,
}
#[test]
fn bindgen_test_layout_xcb_rotate_properties_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_rotate_properties_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_rotate_properties_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_rotate_properties_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_rotate_properties_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_rotate_properties_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rotate_properties_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_rotate_properties_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rotate_properties_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_rotate_properties_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rotate_properties_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_rotate_properties_request_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rotate_properties_request_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_rotate_properties_request_t>())).atoms_len as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rotate_properties_request_t),
            "::",
            stringify!(atoms_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_rotate_properties_request_t>())).delta as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rotate_properties_request_t),
            "::",
            stringify!(delta)
        )
    );
}
pub mod xcb_screen_saver_t {
    pub type Type = u32;
    pub const XCB_SCREEN_SAVER_RESET: Type = 0;
    pub const XCB_SCREEN_SAVER_ACTIVE: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_force_screen_saver_request_t {
    pub major_opcode: u8,
    pub mode: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_force_screen_saver_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_force_screen_saver_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_force_screen_saver_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_force_screen_saver_request_t>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_force_screen_saver_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_force_screen_saver_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_force_screen_saver_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_force_screen_saver_request_t>())).mode as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_force_screen_saver_request_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_force_screen_saver_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_force_screen_saver_request_t),
            "::",
            stringify!(length)
        )
    );
}
pub mod xcb_mapping_status_t {
    pub type Type = u32;
    pub const XCB_MAPPING_STATUS_SUCCESS: Type = 0;
    pub const XCB_MAPPING_STATUS_BUSY: Type = 1;
    pub const XCB_MAPPING_STATUS_FAILURE: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_set_pointer_mapping_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_set_pointer_mapping_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_set_pointer_mapping_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_set_pointer_mapping_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_set_pointer_mapping_cookie_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_set_pointer_mapping_cookie_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_pointer_mapping_cookie_t>())).sequence as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_pointer_mapping_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_set_pointer_mapping_request_t {
    pub major_opcode: u8,
    pub map_len: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_set_pointer_mapping_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_set_pointer_mapping_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_set_pointer_mapping_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_set_pointer_mapping_request_t>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_set_pointer_mapping_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_pointer_mapping_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_pointer_mapping_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_pointer_mapping_request_t>())).map_len as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_pointer_mapping_request_t),
            "::",
            stringify!(map_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_pointer_mapping_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_pointer_mapping_request_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_set_pointer_mapping_reply_t {
    pub response_type: u8,
    pub status: u8,
    pub sequence: u16,
    pub length: u32,
}
#[test]
fn bindgen_test_layout_xcb_set_pointer_mapping_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_set_pointer_mapping_reply_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_set_pointer_mapping_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_set_pointer_mapping_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_set_pointer_mapping_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_pointer_mapping_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_pointer_mapping_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_pointer_mapping_reply_t>())).status as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_pointer_mapping_reply_t),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_pointer_mapping_reply_t>())).sequence as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_pointer_mapping_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_pointer_mapping_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_pointer_mapping_reply_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_pointer_mapping_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_pointer_mapping_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_pointer_mapping_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_pointer_mapping_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_pointer_mapping_cookie_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_pointer_mapping_cookie_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_pointer_mapping_cookie_t>())).sequence as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_mapping_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_pointer_mapping_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_get_pointer_mapping_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_pointer_mapping_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_pointer_mapping_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_pointer_mapping_request_t>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_pointer_mapping_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_pointer_mapping_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_mapping_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_pointer_mapping_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_mapping_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_pointer_mapping_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_mapping_request_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_pointer_mapping_reply_t {
    pub response_type: u8,
    pub map_len: u8,
    pub sequence: u16,
    pub length: u32,
    pub pad0: [u8; 24usize],
}
#[test]
fn bindgen_test_layout_xcb_get_pointer_mapping_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_pointer_mapping_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_get_pointer_mapping_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_pointer_mapping_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_pointer_mapping_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_pointer_mapping_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_mapping_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_pointer_mapping_reply_t>())).map_len as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_mapping_reply_t),
            "::",
            stringify!(map_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_pointer_mapping_reply_t>())).sequence as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_mapping_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_pointer_mapping_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_mapping_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_pointer_mapping_reply_t>())).pad0 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_mapping_reply_t),
            "::",
            stringify!(pad0)
        )
    );
}
pub mod xcb_map_index_t {
    pub type Type = u32;
    pub const XCB_MAP_INDEX_SHIFT: Type = 0;
    pub const XCB_MAP_INDEX_LOCK: Type = 1;
    pub const XCB_MAP_INDEX_CONTROL: Type = 2;
    pub const XCB_MAP_INDEX_1: Type = 3;
    pub const XCB_MAP_INDEX_2: Type = 4;
    pub const XCB_MAP_INDEX_3: Type = 5;
    pub const XCB_MAP_INDEX_4: Type = 6;
    pub const XCB_MAP_INDEX_5: Type = 7;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_set_modifier_mapping_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_set_modifier_mapping_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_set_modifier_mapping_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_set_modifier_mapping_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_set_modifier_mapping_cookie_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_set_modifier_mapping_cookie_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_modifier_mapping_cookie_t>())).sequence as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_modifier_mapping_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_set_modifier_mapping_request_t {
    pub major_opcode: u8,
    pub keycodes_per_modifier: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_set_modifier_mapping_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_set_modifier_mapping_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_set_modifier_mapping_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_set_modifier_mapping_request_t>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_set_modifier_mapping_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_modifier_mapping_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_modifier_mapping_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_modifier_mapping_request_t>())).keycodes_per_modifier
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_modifier_mapping_request_t),
            "::",
            stringify!(keycodes_per_modifier)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_modifier_mapping_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_modifier_mapping_request_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_set_modifier_mapping_reply_t {
    pub response_type: u8,
    pub status: u8,
    pub sequence: u16,
    pub length: u32,
}
#[test]
fn bindgen_test_layout_xcb_set_modifier_mapping_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_set_modifier_mapping_reply_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_set_modifier_mapping_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_set_modifier_mapping_reply_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_set_modifier_mapping_reply_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_modifier_mapping_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_modifier_mapping_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_modifier_mapping_reply_t>())).status as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_modifier_mapping_reply_t),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_modifier_mapping_reply_t>())).sequence as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_modifier_mapping_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_modifier_mapping_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_modifier_mapping_reply_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_modifier_mapping_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_modifier_mapping_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_modifier_mapping_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_modifier_mapping_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_modifier_mapping_cookie_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_modifier_mapping_cookie_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_modifier_mapping_cookie_t>())).sequence as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_modifier_mapping_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_modifier_mapping_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_get_modifier_mapping_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_modifier_mapping_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_modifier_mapping_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_modifier_mapping_request_t>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_modifier_mapping_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_modifier_mapping_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_modifier_mapping_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_modifier_mapping_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_modifier_mapping_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_modifier_mapping_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_modifier_mapping_request_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_modifier_mapping_reply_t {
    pub response_type: u8,
    pub keycodes_per_modifier: u8,
    pub sequence: u16,
    pub length: u32,
    pub pad0: [u8; 24usize],
}
#[test]
fn bindgen_test_layout_xcb_get_modifier_mapping_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_modifier_mapping_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_get_modifier_mapping_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_modifier_mapping_reply_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_modifier_mapping_reply_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_modifier_mapping_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_modifier_mapping_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_modifier_mapping_reply_t>())).keycodes_per_modifier
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_modifier_mapping_reply_t),
            "::",
            stringify!(keycodes_per_modifier)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_modifier_mapping_reply_t>())).sequence as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_modifier_mapping_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_modifier_mapping_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_modifier_mapping_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_modifier_mapping_reply_t>())).pad0 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_modifier_mapping_reply_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_no_operation_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_no_operation_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_no_operation_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_no_operation_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_no_operation_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_no_operation_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_no_operation_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_no_operation_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_no_operation_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_no_operation_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_no_operation_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_no_operation_request_t),
            "::",
            stringify!(length)
        )
    );
}
extern "C" {
    pub fn xcb_char2b_next(i: *mut xcb_char2b_iterator_t);
}
extern "C" {
    pub fn xcb_char2b_end(i: xcb_char2b_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_window_next(i: *mut xcb_window_iterator_t);
}
extern "C" {
    pub fn xcb_window_end(i: xcb_window_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_pixmap_next(i: *mut xcb_pixmap_iterator_t);
}
extern "C" {
    pub fn xcb_pixmap_end(i: xcb_pixmap_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_cursor_next(i: *mut xcb_cursor_iterator_t);
}
extern "C" {
    pub fn xcb_cursor_end(i: xcb_cursor_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_font_next(i: *mut xcb_font_iterator_t);
}
extern "C" {
    pub fn xcb_font_end(i: xcb_font_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_gcontext_next(i: *mut xcb_gcontext_iterator_t);
}
extern "C" {
    pub fn xcb_gcontext_end(i: xcb_gcontext_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_colormap_next(i: *mut xcb_colormap_iterator_t);
}
extern "C" {
    pub fn xcb_colormap_end(i: xcb_colormap_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_atom_next(i: *mut xcb_atom_iterator_t);
}
extern "C" {
    pub fn xcb_atom_end(i: xcb_atom_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_drawable_next(i: *mut xcb_drawable_iterator_t);
}
extern "C" {
    pub fn xcb_drawable_end(i: xcb_drawable_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_fontable_next(i: *mut xcb_fontable_iterator_t);
}
extern "C" {
    pub fn xcb_fontable_end(i: xcb_fontable_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_bool32_next(i: *mut xcb_bool32_iterator_t);
}
extern "C" {
    pub fn xcb_bool32_end(i: xcb_bool32_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_visualid_next(i: *mut xcb_visualid_iterator_t);
}
extern "C" {
    pub fn xcb_visualid_end(i: xcb_visualid_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_timestamp_next(i: *mut xcb_timestamp_iterator_t);
}
extern "C" {
    pub fn xcb_timestamp_end(i: xcb_timestamp_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_keysym_next(i: *mut xcb_keysym_iterator_t);
}
extern "C" {
    pub fn xcb_keysym_end(i: xcb_keysym_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_keycode_next(i: *mut xcb_keycode_iterator_t);
}
extern "C" {
    pub fn xcb_keycode_end(i: xcb_keycode_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_keycode32_next(i: *mut xcb_keycode32_iterator_t);
}
extern "C" {
    pub fn xcb_keycode32_end(i: xcb_keycode32_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_button_next(i: *mut xcb_button_iterator_t);
}
extern "C" {
    pub fn xcb_button_end(i: xcb_button_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_point_next(i: *mut xcb_point_iterator_t);
}
extern "C" {
    pub fn xcb_point_end(i: xcb_point_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_rectangle_next(i: *mut xcb_rectangle_iterator_t);
}
extern "C" {
    pub fn xcb_rectangle_end(i: xcb_rectangle_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_arc_next(i: *mut xcb_arc_iterator_t);
}
extern "C" {
    pub fn xcb_arc_end(i: xcb_arc_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_format_next(i: *mut xcb_format_iterator_t);
}
extern "C" {
    pub fn xcb_format_end(i: xcb_format_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_visualtype_next(i: *mut xcb_visualtype_iterator_t);
}
extern "C" {
    pub fn xcb_visualtype_end(i: xcb_visualtype_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_depth_sizeof(_buffer: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_depth_visuals(R: *const xcb_depth_t) -> *mut xcb_visualtype_t;
}
extern "C" {
    pub fn xcb_depth_visuals_length(R: *const xcb_depth_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_depth_visuals_iterator(R: *const xcb_depth_t) -> xcb_visualtype_iterator_t;
}
extern "C" {
    pub fn xcb_depth_next(i: *mut xcb_depth_iterator_t);
}
extern "C" {
    pub fn xcb_depth_end(i: xcb_depth_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_screen_sizeof(_buffer: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_screen_allowed_depths_length(R: *const xcb_screen_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_screen_allowed_depths_iterator(R: *const xcb_screen_t) -> xcb_depth_iterator_t;
}
extern "C" {
    pub fn xcb_screen_next(i: *mut xcb_screen_iterator_t);
}
extern "C" {
    pub fn xcb_screen_end(i: xcb_screen_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_setup_request_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_setup_request_authorization_protocol_name(
        R: *const xcb_setup_request_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn xcb_setup_request_authorization_protocol_name_length(
        R: *const xcb_setup_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_setup_request_authorization_protocol_name_end(
        R: *const xcb_setup_request_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_setup_request_authorization_protocol_data(
        R: *const xcb_setup_request_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn xcb_setup_request_authorization_protocol_data_length(
        R: *const xcb_setup_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_setup_request_authorization_protocol_data_end(
        R: *const xcb_setup_request_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_setup_request_next(i: *mut xcb_setup_request_iterator_t);
}
extern "C" {
    pub fn xcb_setup_request_end(i: xcb_setup_request_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_setup_failed_sizeof(_buffer: *const ::std::os::raw::c_void)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_setup_failed_reason(R: *const xcb_setup_failed_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn xcb_setup_failed_reason_length(R: *const xcb_setup_failed_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_setup_failed_reason_end(R: *const xcb_setup_failed_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_setup_failed_next(i: *mut xcb_setup_failed_iterator_t);
}
extern "C" {
    pub fn xcb_setup_failed_end(i: xcb_setup_failed_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_setup_authenticate_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_setup_authenticate_reason(
        R: *const xcb_setup_authenticate_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn xcb_setup_authenticate_reason_length(
        R: *const xcb_setup_authenticate_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_setup_authenticate_reason_end(
        R: *const xcb_setup_authenticate_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_setup_authenticate_next(i: *mut xcb_setup_authenticate_iterator_t);
}
extern "C" {
    pub fn xcb_setup_authenticate_end(
        i: xcb_setup_authenticate_iterator_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_setup_sizeof(_buffer: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_setup_vendor(R: *const xcb_setup_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn xcb_setup_vendor_length(R: *const xcb_setup_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_setup_vendor_end(R: *const xcb_setup_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_setup_pixmap_formats(R: *const xcb_setup_t) -> *mut xcb_format_t;
}
extern "C" {
    pub fn xcb_setup_pixmap_formats_length(R: *const xcb_setup_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_setup_pixmap_formats_iterator(R: *const xcb_setup_t) -> xcb_format_iterator_t;
}
extern "C" {
    pub fn xcb_setup_roots_length(R: *const xcb_setup_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_setup_roots_iterator(R: *const xcb_setup_t) -> xcb_screen_iterator_t;
}
extern "C" {
    pub fn xcb_setup_next(i: *mut xcb_setup_iterator_t);
}
extern "C" {
    pub fn xcb_setup_end(i: xcb_setup_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_client_message_data_next(i: *mut xcb_client_message_data_iterator_t);
}
extern "C" {
    pub fn xcb_client_message_data_end(
        i: xcb_client_message_data_iterator_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_create_window_value_list_serialize(
        _buffer: *mut *mut ::std::os::raw::c_void,
        value_mask: u32,
        _aux: *const xcb_create_window_value_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_create_window_value_list_unpack(
        _buffer: *const ::std::os::raw::c_void,
        value_mask: u32,
        _aux: *mut xcb_create_window_value_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_create_window_value_list_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        value_mask: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_create_window_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_create_window_checked(
        c: *mut xcb_connection_t,
        depth: u8,
        wid: xcb_window_t,
        parent: xcb_window_t,
        x: i16,
        y: i16,
        width: u16,
        height: u16,
        border_width: u16,
        _class: u16,
        visual: xcb_visualid_t,
        value_mask: u32,
        value_list: *const ::std::os::raw::c_void,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_window(
        c: *mut xcb_connection_t,
        depth: u8,
        wid: xcb_window_t,
        parent: xcb_window_t,
        x: i16,
        y: i16,
        width: u16,
        height: u16,
        border_width: u16,
        _class: u16,
        visual: xcb_visualid_t,
        value_mask: u32,
        value_list: *const ::std::os::raw::c_void,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_window_aux_checked(
        c: *mut xcb_connection_t,
        depth: u8,
        wid: xcb_window_t,
        parent: xcb_window_t,
        x: i16,
        y: i16,
        width: u16,
        height: u16,
        border_width: u16,
        _class: u16,
        visual: xcb_visualid_t,
        value_mask: u32,
        value_list: *const xcb_create_window_value_list_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_window_aux(
        c: *mut xcb_connection_t,
        depth: u8,
        wid: xcb_window_t,
        parent: xcb_window_t,
        x: i16,
        y: i16,
        width: u16,
        height: u16,
        border_width: u16,
        _class: u16,
        visual: xcb_visualid_t,
        value_mask: u32,
        value_list: *const xcb_create_window_value_list_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_window_value_list(
        R: *const xcb_create_window_request_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn xcb_change_window_attributes_value_list_serialize(
        _buffer: *mut *mut ::std::os::raw::c_void,
        value_mask: u32,
        _aux: *const xcb_change_window_attributes_value_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_change_window_attributes_value_list_unpack(
        _buffer: *const ::std::os::raw::c_void,
        value_mask: u32,
        _aux: *mut xcb_change_window_attributes_value_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_change_window_attributes_value_list_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        value_mask: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_change_window_attributes_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_change_window_attributes_checked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        value_mask: u32,
        value_list: *const ::std::os::raw::c_void,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_window_attributes(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        value_mask: u32,
        value_list: *const ::std::os::raw::c_void,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_window_attributes_aux_checked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        value_mask: u32,
        value_list: *const xcb_change_window_attributes_value_list_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_window_attributes_aux(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        value_mask: u32,
        value_list: *const xcb_change_window_attributes_value_list_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_window_attributes_value_list(
        R: *const xcb_change_window_attributes_request_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn xcb_get_window_attributes(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_get_window_attributes_cookie_t;
}
extern "C" {
    pub fn xcb_get_window_attributes_unchecked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_get_window_attributes_cookie_t;
}
extern "C" {
    pub fn xcb_get_window_attributes_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_get_window_attributes_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_get_window_attributes_reply_t;
}
extern "C" {
    pub fn xcb_destroy_window_checked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_destroy_window(c: *mut xcb_connection_t, window: xcb_window_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_destroy_subwindows_checked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_destroy_subwindows(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_save_set_checked(
        c: *mut xcb_connection_t,
        mode: u8,
        window: xcb_window_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_save_set(
        c: *mut xcb_connection_t,
        mode: u8,
        window: xcb_window_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_reparent_window_checked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        parent: xcb_window_t,
        x: i16,
        y: i16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_reparent_window(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        parent: xcb_window_t,
        x: i16,
        y: i16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_map_window_checked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_map_window(c: *mut xcb_connection_t, window: xcb_window_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_map_subwindows_checked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_map_subwindows(c: *mut xcb_connection_t, window: xcb_window_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_unmap_window_checked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_unmap_window(c: *mut xcb_connection_t, window: xcb_window_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_unmap_subwindows_checked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_unmap_subwindows(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_configure_window_value_list_serialize(
        _buffer: *mut *mut ::std::os::raw::c_void,
        value_mask: u16,
        _aux: *const xcb_configure_window_value_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_configure_window_value_list_unpack(
        _buffer: *const ::std::os::raw::c_void,
        value_mask: u16,
        _aux: *mut xcb_configure_window_value_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_configure_window_value_list_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        value_mask: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_configure_window_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_configure_window_checked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        value_mask: u16,
        value_list: *const ::std::os::raw::c_void,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_configure_window(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        value_mask: u16,
        value_list: *const ::std::os::raw::c_void,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_configure_window_aux_checked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        value_mask: u16,
        value_list: *const xcb_configure_window_value_list_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_configure_window_aux(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        value_mask: u16,
        value_list: *const xcb_configure_window_value_list_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_configure_window_value_list(
        R: *const xcb_configure_window_request_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn xcb_circulate_window_checked(
        c: *mut xcb_connection_t,
        direction: u8,
        window: xcb_window_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_circulate_window(
        c: *mut xcb_connection_t,
        direction: u8,
        window: xcb_window_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_get_geometry(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
    ) -> xcb_get_geometry_cookie_t;
}
extern "C" {
    pub fn xcb_get_geometry_unchecked(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
    ) -> xcb_get_geometry_cookie_t;
}
extern "C" {
    pub fn xcb_get_geometry_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_get_geometry_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_get_geometry_reply_t;
}
extern "C" {
    pub fn xcb_query_tree_sizeof(_buffer: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_query_tree(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_query_tree_cookie_t;
}
extern "C" {
    pub fn xcb_query_tree_unchecked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_query_tree_cookie_t;
}
extern "C" {
    pub fn xcb_query_tree_children(R: *const xcb_query_tree_reply_t) -> *mut xcb_window_t;
}
extern "C" {
    pub fn xcb_query_tree_children_length(
        R: *const xcb_query_tree_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_query_tree_children_end(R: *const xcb_query_tree_reply_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_query_tree_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_query_tree_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_query_tree_reply_t;
}
extern "C" {
    pub fn xcb_intern_atom_sizeof(_buffer: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_intern_atom(
        c: *mut xcb_connection_t,
        only_if_exists: u8,
        name_len: u16,
        name: *const ::std::os::raw::c_char,
    ) -> xcb_intern_atom_cookie_t;
}
extern "C" {
    pub fn xcb_intern_atom_unchecked(
        c: *mut xcb_connection_t,
        only_if_exists: u8,
        name_len: u16,
        name: *const ::std::os::raw::c_char,
    ) -> xcb_intern_atom_cookie_t;
}
extern "C" {
    pub fn xcb_intern_atom_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_intern_atom_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_intern_atom_reply_t;
}
extern "C" {
    pub fn xcb_get_atom_name_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_get_atom_name(
        c: *mut xcb_connection_t,
        atom: xcb_atom_t,
    ) -> xcb_get_atom_name_cookie_t;
}
extern "C" {
    pub fn xcb_get_atom_name_unchecked(
        c: *mut xcb_connection_t,
        atom: xcb_atom_t,
    ) -> xcb_get_atom_name_cookie_t;
}
extern "C" {
    pub fn xcb_get_atom_name_name(
        R: *const xcb_get_atom_name_reply_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn xcb_get_atom_name_name_length(
        R: *const xcb_get_atom_name_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_get_atom_name_name_end(
        R: *const xcb_get_atom_name_reply_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_get_atom_name_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_get_atom_name_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_get_atom_name_reply_t;
}
extern "C" {
    pub fn xcb_change_property_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_change_property_checked(
        c: *mut xcb_connection_t,
        mode: u8,
        window: xcb_window_t,
        property: xcb_atom_t,
        type_: xcb_atom_t,
        format: u8,
        data_len: u32,
        data: *const ::std::os::raw::c_void,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_property(
        c: *mut xcb_connection_t,
        mode: u8,
        window: xcb_window_t,
        property: xcb_atom_t,
        type_: xcb_atom_t,
        format: u8,
        data_len: u32,
        data: *const ::std::os::raw::c_void,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_property_data(
        R: *const xcb_change_property_request_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn xcb_change_property_data_length(
        R: *const xcb_change_property_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_change_property_data_end(
        R: *const xcb_change_property_request_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_delete_property_checked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        property: xcb_atom_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_delete_property(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        property: xcb_atom_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_get_property_sizeof(_buffer: *const ::std::os::raw::c_void)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_get_property(
        c: *mut xcb_connection_t,
        _delete: u8,
        window: xcb_window_t,
        property: xcb_atom_t,
        type_: xcb_atom_t,
        long_offset: u32,
        long_length: u32,
    ) -> xcb_get_property_cookie_t;
}
extern "C" {
    pub fn xcb_get_property_unchecked(
        c: *mut xcb_connection_t,
        _delete: u8,
        window: xcb_window_t,
        property: xcb_atom_t,
        type_: xcb_atom_t,
        long_offset: u32,
        long_length: u32,
    ) -> xcb_get_property_cookie_t;
}
extern "C" {
    pub fn xcb_get_property_value(
        R: *const xcb_get_property_reply_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn xcb_get_property_value_length(
        R: *const xcb_get_property_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_get_property_value_end(R: *const xcb_get_property_reply_t)
        -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_get_property_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_get_property_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_get_property_reply_t;
}
extern "C" {
    pub fn xcb_list_properties_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_list_properties(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_list_properties_cookie_t;
}
extern "C" {
    pub fn xcb_list_properties_unchecked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_list_properties_cookie_t;
}
extern "C" {
    pub fn xcb_list_properties_atoms(R: *const xcb_list_properties_reply_t) -> *mut xcb_atom_t;
}
extern "C" {
    pub fn xcb_list_properties_atoms_length(
        R: *const xcb_list_properties_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_list_properties_atoms_end(
        R: *const xcb_list_properties_reply_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_list_properties_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_list_properties_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_list_properties_reply_t;
}
extern "C" {
    pub fn xcb_set_selection_owner_checked(
        c: *mut xcb_connection_t,
        owner: xcb_window_t,
        selection: xcb_atom_t,
        time: xcb_timestamp_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_selection_owner(
        c: *mut xcb_connection_t,
        owner: xcb_window_t,
        selection: xcb_atom_t,
        time: xcb_timestamp_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_get_selection_owner(
        c: *mut xcb_connection_t,
        selection: xcb_atom_t,
    ) -> xcb_get_selection_owner_cookie_t;
}
extern "C" {
    pub fn xcb_get_selection_owner_unchecked(
        c: *mut xcb_connection_t,
        selection: xcb_atom_t,
    ) -> xcb_get_selection_owner_cookie_t;
}
extern "C" {
    pub fn xcb_get_selection_owner_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_get_selection_owner_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_get_selection_owner_reply_t;
}
extern "C" {
    pub fn xcb_convert_selection_checked(
        c: *mut xcb_connection_t,
        requestor: xcb_window_t,
        selection: xcb_atom_t,
        target: xcb_atom_t,
        property: xcb_atom_t,
        time: xcb_timestamp_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_convert_selection(
        c: *mut xcb_connection_t,
        requestor: xcb_window_t,
        selection: xcb_atom_t,
        target: xcb_atom_t,
        property: xcb_atom_t,
        time: xcb_timestamp_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_send_event_checked(
        c: *mut xcb_connection_t,
        propagate: u8,
        destination: xcb_window_t,
        event_mask: u32,
        event: *const ::std::os::raw::c_char,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_send_event(
        c: *mut xcb_connection_t,
        propagate: u8,
        destination: xcb_window_t,
        event_mask: u32,
        event: *const ::std::os::raw::c_char,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_grab_pointer(
        c: *mut xcb_connection_t,
        owner_events: u8,
        grab_window: xcb_window_t,
        event_mask: u16,
        pointer_mode: u8,
        keyboard_mode: u8,
        confine_to: xcb_window_t,
        cursor: xcb_cursor_t,
        time: xcb_timestamp_t,
    ) -> xcb_grab_pointer_cookie_t;
}
extern "C" {
    pub fn xcb_grab_pointer_unchecked(
        c: *mut xcb_connection_t,
        owner_events: u8,
        grab_window: xcb_window_t,
        event_mask: u16,
        pointer_mode: u8,
        keyboard_mode: u8,
        confine_to: xcb_window_t,
        cursor: xcb_cursor_t,
        time: xcb_timestamp_t,
    ) -> xcb_grab_pointer_cookie_t;
}
extern "C" {
    pub fn xcb_grab_pointer_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_grab_pointer_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_grab_pointer_reply_t;
}
extern "C" {
    pub fn xcb_ungrab_pointer_checked(
        c: *mut xcb_connection_t,
        time: xcb_timestamp_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_ungrab_pointer(c: *mut xcb_connection_t, time: xcb_timestamp_t)
        -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_grab_button_checked(
        c: *mut xcb_connection_t,
        owner_events: u8,
        grab_window: xcb_window_t,
        event_mask: u16,
        pointer_mode: u8,
        keyboard_mode: u8,
        confine_to: xcb_window_t,
        cursor: xcb_cursor_t,
        button: u8,
        modifiers: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_grab_button(
        c: *mut xcb_connection_t,
        owner_events: u8,
        grab_window: xcb_window_t,
        event_mask: u16,
        pointer_mode: u8,
        keyboard_mode: u8,
        confine_to: xcb_window_t,
        cursor: xcb_cursor_t,
        button: u8,
        modifiers: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_ungrab_button_checked(
        c: *mut xcb_connection_t,
        button: u8,
        grab_window: xcb_window_t,
        modifiers: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_ungrab_button(
        c: *mut xcb_connection_t,
        button: u8,
        grab_window: xcb_window_t,
        modifiers: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_active_pointer_grab_checked(
        c: *mut xcb_connection_t,
        cursor: xcb_cursor_t,
        time: xcb_timestamp_t,
        event_mask: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_active_pointer_grab(
        c: *mut xcb_connection_t,
        cursor: xcb_cursor_t,
        time: xcb_timestamp_t,
        event_mask: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_grab_keyboard(
        c: *mut xcb_connection_t,
        owner_events: u8,
        grab_window: xcb_window_t,
        time: xcb_timestamp_t,
        pointer_mode: u8,
        keyboard_mode: u8,
    ) -> xcb_grab_keyboard_cookie_t;
}
extern "C" {
    pub fn xcb_grab_keyboard_unchecked(
        c: *mut xcb_connection_t,
        owner_events: u8,
        grab_window: xcb_window_t,
        time: xcb_timestamp_t,
        pointer_mode: u8,
        keyboard_mode: u8,
    ) -> xcb_grab_keyboard_cookie_t;
}
extern "C" {
    pub fn xcb_grab_keyboard_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_grab_keyboard_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_grab_keyboard_reply_t;
}
extern "C" {
    pub fn xcb_ungrab_keyboard_checked(
        c: *mut xcb_connection_t,
        time: xcb_timestamp_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_ungrab_keyboard(
        c: *mut xcb_connection_t,
        time: xcb_timestamp_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_grab_key_checked(
        c: *mut xcb_connection_t,
        owner_events: u8,
        grab_window: xcb_window_t,
        modifiers: u16,
        key: xcb_keycode_t,
        pointer_mode: u8,
        keyboard_mode: u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_grab_key(
        c: *mut xcb_connection_t,
        owner_events: u8,
        grab_window: xcb_window_t,
        modifiers: u16,
        key: xcb_keycode_t,
        pointer_mode: u8,
        keyboard_mode: u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_ungrab_key_checked(
        c: *mut xcb_connection_t,
        key: xcb_keycode_t,
        grab_window: xcb_window_t,
        modifiers: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_ungrab_key(
        c: *mut xcb_connection_t,
        key: xcb_keycode_t,
        grab_window: xcb_window_t,
        modifiers: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_allow_events_checked(
        c: *mut xcb_connection_t,
        mode: u8,
        time: xcb_timestamp_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_allow_events(
        c: *mut xcb_connection_t,
        mode: u8,
        time: xcb_timestamp_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_grab_server_checked(c: *mut xcb_connection_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_grab_server(c: *mut xcb_connection_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_ungrab_server_checked(c: *mut xcb_connection_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_ungrab_server(c: *mut xcb_connection_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_query_pointer(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_query_pointer_cookie_t;
}
extern "C" {
    pub fn xcb_query_pointer_unchecked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_query_pointer_cookie_t;
}
extern "C" {
    pub fn xcb_query_pointer_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_query_pointer_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_query_pointer_reply_t;
}
extern "C" {
    pub fn xcb_timecoord_next(i: *mut xcb_timecoord_iterator_t);
}
extern "C" {
    pub fn xcb_timecoord_end(i: xcb_timecoord_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_get_motion_events_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_get_motion_events(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        start: xcb_timestamp_t,
        stop: xcb_timestamp_t,
    ) -> xcb_get_motion_events_cookie_t;
}
extern "C" {
    pub fn xcb_get_motion_events_unchecked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        start: xcb_timestamp_t,
        stop: xcb_timestamp_t,
    ) -> xcb_get_motion_events_cookie_t;
}
extern "C" {
    pub fn xcb_get_motion_events_events(
        R: *const xcb_get_motion_events_reply_t,
    ) -> *mut xcb_timecoord_t;
}
extern "C" {
    pub fn xcb_get_motion_events_events_length(
        R: *const xcb_get_motion_events_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_get_motion_events_events_iterator(
        R: *const xcb_get_motion_events_reply_t,
    ) -> xcb_timecoord_iterator_t;
}
extern "C" {
    pub fn xcb_get_motion_events_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_get_motion_events_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_get_motion_events_reply_t;
}
extern "C" {
    pub fn xcb_translate_coordinates(
        c: *mut xcb_connection_t,
        src_window: xcb_window_t,
        dst_window: xcb_window_t,
        src_x: i16,
        src_y: i16,
    ) -> xcb_translate_coordinates_cookie_t;
}
extern "C" {
    pub fn xcb_translate_coordinates_unchecked(
        c: *mut xcb_connection_t,
        src_window: xcb_window_t,
        dst_window: xcb_window_t,
        src_x: i16,
        src_y: i16,
    ) -> xcb_translate_coordinates_cookie_t;
}
extern "C" {
    pub fn xcb_translate_coordinates_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_translate_coordinates_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_translate_coordinates_reply_t;
}
extern "C" {
    pub fn xcb_warp_pointer_checked(
        c: *mut xcb_connection_t,
        src_window: xcb_window_t,
        dst_window: xcb_window_t,
        src_x: i16,
        src_y: i16,
        src_width: u16,
        src_height: u16,
        dst_x: i16,
        dst_y: i16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_warp_pointer(
        c: *mut xcb_connection_t,
        src_window: xcb_window_t,
        dst_window: xcb_window_t,
        src_x: i16,
        src_y: i16,
        src_width: u16,
        src_height: u16,
        dst_x: i16,
        dst_y: i16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_input_focus_checked(
        c: *mut xcb_connection_t,
        revert_to: u8,
        focus: xcb_window_t,
        time: xcb_timestamp_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_input_focus(
        c: *mut xcb_connection_t,
        revert_to: u8,
        focus: xcb_window_t,
        time: xcb_timestamp_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_get_input_focus(c: *mut xcb_connection_t) -> xcb_get_input_focus_cookie_t;
}
extern "C" {
    pub fn xcb_get_input_focus_unchecked(c: *mut xcb_connection_t) -> xcb_get_input_focus_cookie_t;
}
extern "C" {
    pub fn xcb_get_input_focus_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_get_input_focus_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_get_input_focus_reply_t;
}
extern "C" {
    pub fn xcb_query_keymap(c: *mut xcb_connection_t) -> xcb_query_keymap_cookie_t;
}
extern "C" {
    pub fn xcb_query_keymap_unchecked(c: *mut xcb_connection_t) -> xcb_query_keymap_cookie_t;
}
extern "C" {
    pub fn xcb_query_keymap_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_query_keymap_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_query_keymap_reply_t;
}
extern "C" {
    pub fn xcb_open_font_sizeof(_buffer: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_open_font_checked(
        c: *mut xcb_connection_t,
        fid: xcb_font_t,
        name_len: u16,
        name: *const ::std::os::raw::c_char,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_open_font(
        c: *mut xcb_connection_t,
        fid: xcb_font_t,
        name_len: u16,
        name: *const ::std::os::raw::c_char,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_open_font_name(R: *const xcb_open_font_request_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn xcb_open_font_name_length(R: *const xcb_open_font_request_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_open_font_name_end(R: *const xcb_open_font_request_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_close_font_checked(c: *mut xcb_connection_t, font: xcb_font_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_close_font(c: *mut xcb_connection_t, font: xcb_font_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_fontprop_next(i: *mut xcb_fontprop_iterator_t);
}
extern "C" {
    pub fn xcb_fontprop_end(i: xcb_fontprop_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_charinfo_next(i: *mut xcb_charinfo_iterator_t);
}
extern "C" {
    pub fn xcb_charinfo_end(i: xcb_charinfo_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_query_font_sizeof(_buffer: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_query_font(
        c: *mut xcb_connection_t,
        font: xcb_fontable_t,
    ) -> xcb_query_font_cookie_t;
}
extern "C" {
    pub fn xcb_query_font_unchecked(
        c: *mut xcb_connection_t,
        font: xcb_fontable_t,
    ) -> xcb_query_font_cookie_t;
}
extern "C" {
    pub fn xcb_query_font_properties(R: *const xcb_query_font_reply_t) -> *mut xcb_fontprop_t;
}
extern "C" {
    pub fn xcb_query_font_properties_length(
        R: *const xcb_query_font_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_query_font_properties_iterator(
        R: *const xcb_query_font_reply_t,
    ) -> xcb_fontprop_iterator_t;
}
extern "C" {
    pub fn xcb_query_font_char_infos(R: *const xcb_query_font_reply_t) -> *mut xcb_charinfo_t;
}
extern "C" {
    pub fn xcb_query_font_char_infos_length(
        R: *const xcb_query_font_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_query_font_char_infos_iterator(
        R: *const xcb_query_font_reply_t,
    ) -> xcb_charinfo_iterator_t;
}
extern "C" {
    pub fn xcb_query_font_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_query_font_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_query_font_reply_t;
}
extern "C" {
    pub fn xcb_query_text_extents_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        string_len: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_query_text_extents(
        c: *mut xcb_connection_t,
        font: xcb_fontable_t,
        string_len: u32,
        string: *const xcb_char2b_t,
    ) -> xcb_query_text_extents_cookie_t;
}
extern "C" {
    pub fn xcb_query_text_extents_unchecked(
        c: *mut xcb_connection_t,
        font: xcb_fontable_t,
        string_len: u32,
        string: *const xcb_char2b_t,
    ) -> xcb_query_text_extents_cookie_t;
}
extern "C" {
    pub fn xcb_query_text_extents_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_query_text_extents_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_query_text_extents_reply_t;
}
extern "C" {
    pub fn xcb_str_sizeof(_buffer: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_str_name(R: *const xcb_str_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn xcb_str_name_length(R: *const xcb_str_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_str_name_end(R: *const xcb_str_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_str_next(i: *mut xcb_str_iterator_t);
}
extern "C" {
    pub fn xcb_str_end(i: xcb_str_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_list_fonts_sizeof(_buffer: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_list_fonts(
        c: *mut xcb_connection_t,
        max_names: u16,
        pattern_len: u16,
        pattern: *const ::std::os::raw::c_char,
    ) -> xcb_list_fonts_cookie_t;
}
extern "C" {
    pub fn xcb_list_fonts_unchecked(
        c: *mut xcb_connection_t,
        max_names: u16,
        pattern_len: u16,
        pattern: *const ::std::os::raw::c_char,
    ) -> xcb_list_fonts_cookie_t;
}
extern "C" {
    pub fn xcb_list_fonts_names_length(R: *const xcb_list_fonts_reply_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_list_fonts_names_iterator(R: *const xcb_list_fonts_reply_t) -> xcb_str_iterator_t;
}
extern "C" {
    pub fn xcb_list_fonts_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_list_fonts_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_list_fonts_reply_t;
}
extern "C" {
    pub fn xcb_list_fonts_with_info_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_list_fonts_with_info(
        c: *mut xcb_connection_t,
        max_names: u16,
        pattern_len: u16,
        pattern: *const ::std::os::raw::c_char,
    ) -> xcb_list_fonts_with_info_cookie_t;
}
extern "C" {
    pub fn xcb_list_fonts_with_info_unchecked(
        c: *mut xcb_connection_t,
        max_names: u16,
        pattern_len: u16,
        pattern: *const ::std::os::raw::c_char,
    ) -> xcb_list_fonts_with_info_cookie_t;
}
extern "C" {
    pub fn xcb_list_fonts_with_info_properties(
        R: *const xcb_list_fonts_with_info_reply_t,
    ) -> *mut xcb_fontprop_t;
}
extern "C" {
    pub fn xcb_list_fonts_with_info_properties_length(
        R: *const xcb_list_fonts_with_info_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_list_fonts_with_info_properties_iterator(
        R: *const xcb_list_fonts_with_info_reply_t,
    ) -> xcb_fontprop_iterator_t;
}
extern "C" {
    pub fn xcb_list_fonts_with_info_name(
        R: *const xcb_list_fonts_with_info_reply_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn xcb_list_fonts_with_info_name_length(
        R: *const xcb_list_fonts_with_info_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_list_fonts_with_info_name_end(
        R: *const xcb_list_fonts_with_info_reply_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_list_fonts_with_info_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_list_fonts_with_info_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_list_fonts_with_info_reply_t;
}
extern "C" {
    pub fn xcb_set_font_path_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_set_font_path_checked(
        c: *mut xcb_connection_t,
        font_qty: u16,
        font: *const xcb_str_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_font_path(
        c: *mut xcb_connection_t,
        font_qty: u16,
        font: *const xcb_str_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_font_path_font_length(
        R: *const xcb_set_font_path_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_set_font_path_font_iterator(
        R: *const xcb_set_font_path_request_t,
    ) -> xcb_str_iterator_t;
}
extern "C" {
    pub fn xcb_get_font_path_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_get_font_path(c: *mut xcb_connection_t) -> xcb_get_font_path_cookie_t;
}
extern "C" {
    pub fn xcb_get_font_path_unchecked(c: *mut xcb_connection_t) -> xcb_get_font_path_cookie_t;
}
extern "C" {
    pub fn xcb_get_font_path_path_length(
        R: *const xcb_get_font_path_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_get_font_path_path_iterator(
        R: *const xcb_get_font_path_reply_t,
    ) -> xcb_str_iterator_t;
}
extern "C" {
    pub fn xcb_get_font_path_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_get_font_path_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_get_font_path_reply_t;
}
extern "C" {
    pub fn xcb_create_pixmap_checked(
        c: *mut xcb_connection_t,
        depth: u8,
        pid: xcb_pixmap_t,
        drawable: xcb_drawable_t,
        width: u16,
        height: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_pixmap(
        c: *mut xcb_connection_t,
        depth: u8,
        pid: xcb_pixmap_t,
        drawable: xcb_drawable_t,
        width: u16,
        height: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_free_pixmap_checked(
        c: *mut xcb_connection_t,
        pixmap: xcb_pixmap_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_free_pixmap(c: *mut xcb_connection_t, pixmap: xcb_pixmap_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_gc_value_list_serialize(
        _buffer: *mut *mut ::std::os::raw::c_void,
        value_mask: u32,
        _aux: *const xcb_create_gc_value_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_create_gc_value_list_unpack(
        _buffer: *const ::std::os::raw::c_void,
        value_mask: u32,
        _aux: *mut xcb_create_gc_value_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_create_gc_value_list_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        value_mask: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_create_gc_sizeof(_buffer: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_create_gc_checked(
        c: *mut xcb_connection_t,
        cid: xcb_gcontext_t,
        drawable: xcb_drawable_t,
        value_mask: u32,
        value_list: *const ::std::os::raw::c_void,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_gc(
        c: *mut xcb_connection_t,
        cid: xcb_gcontext_t,
        drawable: xcb_drawable_t,
        value_mask: u32,
        value_list: *const ::std::os::raw::c_void,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_gc_aux_checked(
        c: *mut xcb_connection_t,
        cid: xcb_gcontext_t,
        drawable: xcb_drawable_t,
        value_mask: u32,
        value_list: *const xcb_create_gc_value_list_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_gc_aux(
        c: *mut xcb_connection_t,
        cid: xcb_gcontext_t,
        drawable: xcb_drawable_t,
        value_mask: u32,
        value_list: *const xcb_create_gc_value_list_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_gc_value_list(
        R: *const xcb_create_gc_request_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn xcb_change_gc_value_list_serialize(
        _buffer: *mut *mut ::std::os::raw::c_void,
        value_mask: u32,
        _aux: *const xcb_change_gc_value_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_change_gc_value_list_unpack(
        _buffer: *const ::std::os::raw::c_void,
        value_mask: u32,
        _aux: *mut xcb_change_gc_value_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_change_gc_value_list_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        value_mask: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_change_gc_sizeof(_buffer: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_change_gc_checked(
        c: *mut xcb_connection_t,
        gc: xcb_gcontext_t,
        value_mask: u32,
        value_list: *const ::std::os::raw::c_void,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_gc(
        c: *mut xcb_connection_t,
        gc: xcb_gcontext_t,
        value_mask: u32,
        value_list: *const ::std::os::raw::c_void,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_gc_aux_checked(
        c: *mut xcb_connection_t,
        gc: xcb_gcontext_t,
        value_mask: u32,
        value_list: *const xcb_change_gc_value_list_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_gc_aux(
        c: *mut xcb_connection_t,
        gc: xcb_gcontext_t,
        value_mask: u32,
        value_list: *const xcb_change_gc_value_list_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_gc_value_list(
        R: *const xcb_change_gc_request_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn xcb_copy_gc_checked(
        c: *mut xcb_connection_t,
        src_gc: xcb_gcontext_t,
        dst_gc: xcb_gcontext_t,
        value_mask: u32,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_copy_gc(
        c: *mut xcb_connection_t,
        src_gc: xcb_gcontext_t,
        dst_gc: xcb_gcontext_t,
        value_mask: u32,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_dashes_sizeof(_buffer: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_set_dashes_checked(
        c: *mut xcb_connection_t,
        gc: xcb_gcontext_t,
        dash_offset: u16,
        dashes_len: u16,
        dashes: *const u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_dashes(
        c: *mut xcb_connection_t,
        gc: xcb_gcontext_t,
        dash_offset: u16,
        dashes_len: u16,
        dashes: *const u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_dashes_dashes(R: *const xcb_set_dashes_request_t) -> *mut u8;
}
extern "C" {
    pub fn xcb_set_dashes_dashes_length(
        R: *const xcb_set_dashes_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_set_dashes_dashes_end(R: *const xcb_set_dashes_request_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_set_clip_rectangles_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        rectangles_len: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_set_clip_rectangles_checked(
        c: *mut xcb_connection_t,
        ordering: u8,
        gc: xcb_gcontext_t,
        clip_x_origin: i16,
        clip_y_origin: i16,
        rectangles_len: u32,
        rectangles: *const xcb_rectangle_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_clip_rectangles(
        c: *mut xcb_connection_t,
        ordering: u8,
        gc: xcb_gcontext_t,
        clip_x_origin: i16,
        clip_y_origin: i16,
        rectangles_len: u32,
        rectangles: *const xcb_rectangle_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_clip_rectangles_rectangles(
        R: *const xcb_set_clip_rectangles_request_t,
    ) -> *mut xcb_rectangle_t;
}
extern "C" {
    pub fn xcb_set_clip_rectangles_rectangles_length(
        R: *const xcb_set_clip_rectangles_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_set_clip_rectangles_rectangles_iterator(
        R: *const xcb_set_clip_rectangles_request_t,
    ) -> xcb_rectangle_iterator_t;
}
extern "C" {
    pub fn xcb_free_gc_checked(c: *mut xcb_connection_t, gc: xcb_gcontext_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_free_gc(c: *mut xcb_connection_t, gc: xcb_gcontext_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_clear_area_checked(
        c: *mut xcb_connection_t,
        exposures: u8,
        window: xcb_window_t,
        x: i16,
        y: i16,
        width: u16,
        height: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_clear_area(
        c: *mut xcb_connection_t,
        exposures: u8,
        window: xcb_window_t,
        x: i16,
        y: i16,
        width: u16,
        height: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_copy_area_checked(
        c: *mut xcb_connection_t,
        src_drawable: xcb_drawable_t,
        dst_drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        src_x: i16,
        src_y: i16,
        dst_x: i16,
        dst_y: i16,
        width: u16,
        height: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_copy_area(
        c: *mut xcb_connection_t,
        src_drawable: xcb_drawable_t,
        dst_drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        src_x: i16,
        src_y: i16,
        dst_x: i16,
        dst_y: i16,
        width: u16,
        height: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_copy_plane_checked(
        c: *mut xcb_connection_t,
        src_drawable: xcb_drawable_t,
        dst_drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        src_x: i16,
        src_y: i16,
        dst_x: i16,
        dst_y: i16,
        width: u16,
        height: u16,
        bit_plane: u32,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_copy_plane(
        c: *mut xcb_connection_t,
        src_drawable: xcb_drawable_t,
        dst_drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        src_x: i16,
        src_y: i16,
        dst_x: i16,
        dst_y: i16,
        width: u16,
        height: u16,
        bit_plane: u32,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_point_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        points_len: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_poly_point_checked(
        c: *mut xcb_connection_t,
        coordinate_mode: u8,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        points_len: u32,
        points: *const xcb_point_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_point(
        c: *mut xcb_connection_t,
        coordinate_mode: u8,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        points_len: u32,
        points: *const xcb_point_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_point_points(R: *const xcb_poly_point_request_t) -> *mut xcb_point_t;
}
extern "C" {
    pub fn xcb_poly_point_points_length(
        R: *const xcb_poly_point_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_poly_point_points_iterator(
        R: *const xcb_poly_point_request_t,
    ) -> xcb_point_iterator_t;
}
extern "C" {
    pub fn xcb_poly_line_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        points_len: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_poly_line_checked(
        c: *mut xcb_connection_t,
        coordinate_mode: u8,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        points_len: u32,
        points: *const xcb_point_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_line(
        c: *mut xcb_connection_t,
        coordinate_mode: u8,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        points_len: u32,
        points: *const xcb_point_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_line_points(R: *const xcb_poly_line_request_t) -> *mut xcb_point_t;
}
extern "C" {
    pub fn xcb_poly_line_points_length(R: *const xcb_poly_line_request_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_poly_line_points_iterator(R: *const xcb_poly_line_request_t)
        -> xcb_point_iterator_t;
}
extern "C" {
    pub fn xcb_segment_next(i: *mut xcb_segment_iterator_t);
}
extern "C" {
    pub fn xcb_segment_end(i: xcb_segment_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_poly_segment_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        segments_len: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_poly_segment_checked(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        segments_len: u32,
        segments: *const xcb_segment_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_segment(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        segments_len: u32,
        segments: *const xcb_segment_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_segment_segments(R: *const xcb_poly_segment_request_t) -> *mut xcb_segment_t;
}
extern "C" {
    pub fn xcb_poly_segment_segments_length(
        R: *const xcb_poly_segment_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_poly_segment_segments_iterator(
        R: *const xcb_poly_segment_request_t,
    ) -> xcb_segment_iterator_t;
}
extern "C" {
    pub fn xcb_poly_rectangle_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        rectangles_len: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_poly_rectangle_checked(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        rectangles_len: u32,
        rectangles: *const xcb_rectangle_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_rectangle(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        rectangles_len: u32,
        rectangles: *const xcb_rectangle_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_rectangle_rectangles(
        R: *const xcb_poly_rectangle_request_t,
    ) -> *mut xcb_rectangle_t;
}
extern "C" {
    pub fn xcb_poly_rectangle_rectangles_length(
        R: *const xcb_poly_rectangle_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_poly_rectangle_rectangles_iterator(
        R: *const xcb_poly_rectangle_request_t,
    ) -> xcb_rectangle_iterator_t;
}
extern "C" {
    pub fn xcb_poly_arc_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        arcs_len: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_poly_arc_checked(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        arcs_len: u32,
        arcs: *const xcb_arc_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_arc(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        arcs_len: u32,
        arcs: *const xcb_arc_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_arc_arcs(R: *const xcb_poly_arc_request_t) -> *mut xcb_arc_t;
}
extern "C" {
    pub fn xcb_poly_arc_arcs_length(R: *const xcb_poly_arc_request_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_poly_arc_arcs_iterator(R: *const xcb_poly_arc_request_t) -> xcb_arc_iterator_t;
}
extern "C" {
    pub fn xcb_fill_poly_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        points_len: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_fill_poly_checked(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        shape: u8,
        coordinate_mode: u8,
        points_len: u32,
        points: *const xcb_point_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_fill_poly(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        shape: u8,
        coordinate_mode: u8,
        points_len: u32,
        points: *const xcb_point_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_fill_poly_points(R: *const xcb_fill_poly_request_t) -> *mut xcb_point_t;
}
extern "C" {
    pub fn xcb_fill_poly_points_length(R: *const xcb_fill_poly_request_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_fill_poly_points_iterator(R: *const xcb_fill_poly_request_t)
        -> xcb_point_iterator_t;
}
extern "C" {
    pub fn xcb_poly_fill_rectangle_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        rectangles_len: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_poly_fill_rectangle_checked(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        rectangles_len: u32,
        rectangles: *const xcb_rectangle_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_fill_rectangle(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        rectangles_len: u32,
        rectangles: *const xcb_rectangle_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_fill_rectangle_rectangles(
        R: *const xcb_poly_fill_rectangle_request_t,
    ) -> *mut xcb_rectangle_t;
}
extern "C" {
    pub fn xcb_poly_fill_rectangle_rectangles_length(
        R: *const xcb_poly_fill_rectangle_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_poly_fill_rectangle_rectangles_iterator(
        R: *const xcb_poly_fill_rectangle_request_t,
    ) -> xcb_rectangle_iterator_t;
}
extern "C" {
    pub fn xcb_poly_fill_arc_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        arcs_len: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_poly_fill_arc_checked(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        arcs_len: u32,
        arcs: *const xcb_arc_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_fill_arc(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        arcs_len: u32,
        arcs: *const xcb_arc_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_fill_arc_arcs(R: *const xcb_poly_fill_arc_request_t) -> *mut xcb_arc_t;
}
extern "C" {
    pub fn xcb_poly_fill_arc_arcs_length(
        R: *const xcb_poly_fill_arc_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_poly_fill_arc_arcs_iterator(
        R: *const xcb_poly_fill_arc_request_t,
    ) -> xcb_arc_iterator_t;
}
extern "C" {
    pub fn xcb_put_image_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        data_len: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_put_image_checked(
        c: *mut xcb_connection_t,
        format: u8,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        width: u16,
        height: u16,
        dst_x: i16,
        dst_y: i16,
        left_pad: u8,
        depth: u8,
        data_len: u32,
        data: *const u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_put_image(
        c: *mut xcb_connection_t,
        format: u8,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        width: u16,
        height: u16,
        dst_x: i16,
        dst_y: i16,
        left_pad: u8,
        depth: u8,
        data_len: u32,
        data: *const u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_put_image_data(R: *const xcb_put_image_request_t) -> *mut u8;
}
extern "C" {
    pub fn xcb_put_image_data_length(R: *const xcb_put_image_request_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_put_image_data_end(R: *const xcb_put_image_request_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_get_image_sizeof(_buffer: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_get_image(
        c: *mut xcb_connection_t,
        format: u8,
        drawable: xcb_drawable_t,
        x: i16,
        y: i16,
        width: u16,
        height: u16,
        plane_mask: u32,
    ) -> xcb_get_image_cookie_t;
}
extern "C" {
    pub fn xcb_get_image_unchecked(
        c: *mut xcb_connection_t,
        format: u8,
        drawable: xcb_drawable_t,
        x: i16,
        y: i16,
        width: u16,
        height: u16,
        plane_mask: u32,
    ) -> xcb_get_image_cookie_t;
}
extern "C" {
    pub fn xcb_get_image_data(R: *const xcb_get_image_reply_t) -> *mut u8;
}
extern "C" {
    pub fn xcb_get_image_data_length(R: *const xcb_get_image_reply_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_get_image_data_end(R: *const xcb_get_image_reply_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_get_image_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_get_image_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_get_image_reply_t;
}
extern "C" {
    pub fn xcb_poly_text_8_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        items_len: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_poly_text_8_checked(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        x: i16,
        y: i16,
        items_len: u32,
        items: *const u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_text_8(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        x: i16,
        y: i16,
        items_len: u32,
        items: *const u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_text_8_items(R: *const xcb_poly_text_8_request_t) -> *mut u8;
}
extern "C" {
    pub fn xcb_poly_text_8_items_length(
        R: *const xcb_poly_text_8_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_poly_text_8_items_end(R: *const xcb_poly_text_8_request_t)
        -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_poly_text_16_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        items_len: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_poly_text_16_checked(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        x: i16,
        y: i16,
        items_len: u32,
        items: *const u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_text_16(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        x: i16,
        y: i16,
        items_len: u32,
        items: *const u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_text_16_items(R: *const xcb_poly_text_16_request_t) -> *mut u8;
}
extern "C" {
    pub fn xcb_poly_text_16_items_length(
        R: *const xcb_poly_text_16_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_poly_text_16_items_end(
        R: *const xcb_poly_text_16_request_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_image_text_8_sizeof(_buffer: *const ::std::os::raw::c_void)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_image_text_8_checked(
        c: *mut xcb_connection_t,
        string_len: u8,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        x: i16,
        y: i16,
        string: *const ::std::os::raw::c_char,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_image_text_8(
        c: *mut xcb_connection_t,
        string_len: u8,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        x: i16,
        y: i16,
        string: *const ::std::os::raw::c_char,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_image_text_8_string(
        R: *const xcb_image_text_8_request_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn xcb_image_text_8_string_length(
        R: *const xcb_image_text_8_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_image_text_8_string_end(
        R: *const xcb_image_text_8_request_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_image_text_16_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_image_text_16_checked(
        c: *mut xcb_connection_t,
        string_len: u8,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        x: i16,
        y: i16,
        string: *const xcb_char2b_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_image_text_16(
        c: *mut xcb_connection_t,
        string_len: u8,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        x: i16,
        y: i16,
        string: *const xcb_char2b_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_image_text_16_string(R: *const xcb_image_text_16_request_t) -> *mut xcb_char2b_t;
}
extern "C" {
    pub fn xcb_image_text_16_string_length(
        R: *const xcb_image_text_16_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_image_text_16_string_iterator(
        R: *const xcb_image_text_16_request_t,
    ) -> xcb_char2b_iterator_t;
}
extern "C" {
    pub fn xcb_create_colormap_checked(
        c: *mut xcb_connection_t,
        alloc: u8,
        mid: xcb_colormap_t,
        window: xcb_window_t,
        visual: xcb_visualid_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_colormap(
        c: *mut xcb_connection_t,
        alloc: u8,
        mid: xcb_colormap_t,
        window: xcb_window_t,
        visual: xcb_visualid_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_free_colormap_checked(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_free_colormap(c: *mut xcb_connection_t, cmap: xcb_colormap_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_copy_colormap_and_free_checked(
        c: *mut xcb_connection_t,
        mid: xcb_colormap_t,
        src_cmap: xcb_colormap_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_copy_colormap_and_free(
        c: *mut xcb_connection_t,
        mid: xcb_colormap_t,
        src_cmap: xcb_colormap_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_install_colormap_checked(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_install_colormap(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_uninstall_colormap_checked(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_uninstall_colormap(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_list_installed_colormaps_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_list_installed_colormaps(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_list_installed_colormaps_cookie_t;
}
extern "C" {
    pub fn xcb_list_installed_colormaps_unchecked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_list_installed_colormaps_cookie_t;
}
extern "C" {
    pub fn xcb_list_installed_colormaps_cmaps(
        R: *const xcb_list_installed_colormaps_reply_t,
    ) -> *mut xcb_colormap_t;
}
extern "C" {
    pub fn xcb_list_installed_colormaps_cmaps_length(
        R: *const xcb_list_installed_colormaps_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_list_installed_colormaps_cmaps_end(
        R: *const xcb_list_installed_colormaps_reply_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_list_installed_colormaps_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_list_installed_colormaps_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_list_installed_colormaps_reply_t;
}
extern "C" {
    pub fn xcb_alloc_color(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
        red: u16,
        green: u16,
        blue: u16,
    ) -> xcb_alloc_color_cookie_t;
}
extern "C" {
    pub fn xcb_alloc_color_unchecked(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
        red: u16,
        green: u16,
        blue: u16,
    ) -> xcb_alloc_color_cookie_t;
}
extern "C" {
    pub fn xcb_alloc_color_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_alloc_color_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_alloc_color_reply_t;
}
extern "C" {
    pub fn xcb_alloc_named_color_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_alloc_named_color(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
        name_len: u16,
        name: *const ::std::os::raw::c_char,
    ) -> xcb_alloc_named_color_cookie_t;
}
extern "C" {
    pub fn xcb_alloc_named_color_unchecked(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
        name_len: u16,
        name: *const ::std::os::raw::c_char,
    ) -> xcb_alloc_named_color_cookie_t;
}
extern "C" {
    pub fn xcb_alloc_named_color_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_alloc_named_color_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_alloc_named_color_reply_t;
}
extern "C" {
    pub fn xcb_alloc_color_cells_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_alloc_color_cells(
        c: *mut xcb_connection_t,
        contiguous: u8,
        cmap: xcb_colormap_t,
        colors: u16,
        planes: u16,
    ) -> xcb_alloc_color_cells_cookie_t;
}
extern "C" {
    pub fn xcb_alloc_color_cells_unchecked(
        c: *mut xcb_connection_t,
        contiguous: u8,
        cmap: xcb_colormap_t,
        colors: u16,
        planes: u16,
    ) -> xcb_alloc_color_cells_cookie_t;
}
extern "C" {
    pub fn xcb_alloc_color_cells_pixels(R: *const xcb_alloc_color_cells_reply_t) -> *mut u32;
}
extern "C" {
    pub fn xcb_alloc_color_cells_pixels_length(
        R: *const xcb_alloc_color_cells_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_alloc_color_cells_pixels_end(
        R: *const xcb_alloc_color_cells_reply_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_alloc_color_cells_masks(R: *const xcb_alloc_color_cells_reply_t) -> *mut u32;
}
extern "C" {
    pub fn xcb_alloc_color_cells_masks_length(
        R: *const xcb_alloc_color_cells_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_alloc_color_cells_masks_end(
        R: *const xcb_alloc_color_cells_reply_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_alloc_color_cells_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_alloc_color_cells_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_alloc_color_cells_reply_t;
}
extern "C" {
    pub fn xcb_alloc_color_planes_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_alloc_color_planes(
        c: *mut xcb_connection_t,
        contiguous: u8,
        cmap: xcb_colormap_t,
        colors: u16,
        reds: u16,
        greens: u16,
        blues: u16,
    ) -> xcb_alloc_color_planes_cookie_t;
}
extern "C" {
    pub fn xcb_alloc_color_planes_unchecked(
        c: *mut xcb_connection_t,
        contiguous: u8,
        cmap: xcb_colormap_t,
        colors: u16,
        reds: u16,
        greens: u16,
        blues: u16,
    ) -> xcb_alloc_color_planes_cookie_t;
}
extern "C" {
    pub fn xcb_alloc_color_planes_pixels(R: *const xcb_alloc_color_planes_reply_t) -> *mut u32;
}
extern "C" {
    pub fn xcb_alloc_color_planes_pixels_length(
        R: *const xcb_alloc_color_planes_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_alloc_color_planes_pixels_end(
        R: *const xcb_alloc_color_planes_reply_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_alloc_color_planes_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_alloc_color_planes_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_alloc_color_planes_reply_t;
}
extern "C" {
    pub fn xcb_free_colors_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        pixels_len: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_free_colors_checked(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
        plane_mask: u32,
        pixels_len: u32,
        pixels: *const u32,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_free_colors(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
        plane_mask: u32,
        pixels_len: u32,
        pixels: *const u32,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_free_colors_pixels(R: *const xcb_free_colors_request_t) -> *mut u32;
}
extern "C" {
    pub fn xcb_free_colors_pixels_length(
        R: *const xcb_free_colors_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_free_colors_pixels_end(
        R: *const xcb_free_colors_request_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_coloritem_next(i: *mut xcb_coloritem_iterator_t);
}
extern "C" {
    pub fn xcb_coloritem_end(i: xcb_coloritem_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_store_colors_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        items_len: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_store_colors_checked(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
        items_len: u32,
        items: *const xcb_coloritem_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_store_colors(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
        items_len: u32,
        items: *const xcb_coloritem_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_store_colors_items(R: *const xcb_store_colors_request_t) -> *mut xcb_coloritem_t;
}
extern "C" {
    pub fn xcb_store_colors_items_length(
        R: *const xcb_store_colors_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_store_colors_items_iterator(
        R: *const xcb_store_colors_request_t,
    ) -> xcb_coloritem_iterator_t;
}
extern "C" {
    pub fn xcb_store_named_color_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_store_named_color_checked(
        c: *mut xcb_connection_t,
        flags: u8,
        cmap: xcb_colormap_t,
        pixel: u32,
        name_len: u16,
        name: *const ::std::os::raw::c_char,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_store_named_color(
        c: *mut xcb_connection_t,
        flags: u8,
        cmap: xcb_colormap_t,
        pixel: u32,
        name_len: u16,
        name: *const ::std::os::raw::c_char,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_store_named_color_name(
        R: *const xcb_store_named_color_request_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn xcb_store_named_color_name_length(
        R: *const xcb_store_named_color_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_store_named_color_name_end(
        R: *const xcb_store_named_color_request_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_rgb_next(i: *mut xcb_rgb_iterator_t);
}
extern "C" {
    pub fn xcb_rgb_end(i: xcb_rgb_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_query_colors_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        pixels_len: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_query_colors(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
        pixels_len: u32,
        pixels: *const u32,
    ) -> xcb_query_colors_cookie_t;
}
extern "C" {
    pub fn xcb_query_colors_unchecked(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
        pixels_len: u32,
        pixels: *const u32,
    ) -> xcb_query_colors_cookie_t;
}
extern "C" {
    pub fn xcb_query_colors_colors(R: *const xcb_query_colors_reply_t) -> *mut xcb_rgb_t;
}
extern "C" {
    pub fn xcb_query_colors_colors_length(
        R: *const xcb_query_colors_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_query_colors_colors_iterator(
        R: *const xcb_query_colors_reply_t,
    ) -> xcb_rgb_iterator_t;
}
extern "C" {
    pub fn xcb_query_colors_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_query_colors_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_query_colors_reply_t;
}
extern "C" {
    pub fn xcb_lookup_color_sizeof(_buffer: *const ::std::os::raw::c_void)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_lookup_color(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
        name_len: u16,
        name: *const ::std::os::raw::c_char,
    ) -> xcb_lookup_color_cookie_t;
}
extern "C" {
    pub fn xcb_lookup_color_unchecked(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
        name_len: u16,
        name: *const ::std::os::raw::c_char,
    ) -> xcb_lookup_color_cookie_t;
}
extern "C" {
    pub fn xcb_lookup_color_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_lookup_color_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_lookup_color_reply_t;
}
extern "C" {
    pub fn xcb_create_cursor_checked(
        c: *mut xcb_connection_t,
        cid: xcb_cursor_t,
        source: xcb_pixmap_t,
        mask: xcb_pixmap_t,
        fore_red: u16,
        fore_green: u16,
        fore_blue: u16,
        back_red: u16,
        back_green: u16,
        back_blue: u16,
        x: u16,
        y: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_cursor(
        c: *mut xcb_connection_t,
        cid: xcb_cursor_t,
        source: xcb_pixmap_t,
        mask: xcb_pixmap_t,
        fore_red: u16,
        fore_green: u16,
        fore_blue: u16,
        back_red: u16,
        back_green: u16,
        back_blue: u16,
        x: u16,
        y: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_glyph_cursor_checked(
        c: *mut xcb_connection_t,
        cid: xcb_cursor_t,
        source_font: xcb_font_t,
        mask_font: xcb_font_t,
        source_char: u16,
        mask_char: u16,
        fore_red: u16,
        fore_green: u16,
        fore_blue: u16,
        back_red: u16,
        back_green: u16,
        back_blue: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_glyph_cursor(
        c: *mut xcb_connection_t,
        cid: xcb_cursor_t,
        source_font: xcb_font_t,
        mask_font: xcb_font_t,
        source_char: u16,
        mask_char: u16,
        fore_red: u16,
        fore_green: u16,
        fore_blue: u16,
        back_red: u16,
        back_green: u16,
        back_blue: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_free_cursor_checked(
        c: *mut xcb_connection_t,
        cursor: xcb_cursor_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_free_cursor(c: *mut xcb_connection_t, cursor: xcb_cursor_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_recolor_cursor_checked(
        c: *mut xcb_connection_t,
        cursor: xcb_cursor_t,
        fore_red: u16,
        fore_green: u16,
        fore_blue: u16,
        back_red: u16,
        back_green: u16,
        back_blue: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_recolor_cursor(
        c: *mut xcb_connection_t,
        cursor: xcb_cursor_t,
        fore_red: u16,
        fore_green: u16,
        fore_blue: u16,
        back_red: u16,
        back_green: u16,
        back_blue: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_query_best_size(
        c: *mut xcb_connection_t,
        _class: u8,
        drawable: xcb_drawable_t,
        width: u16,
        height: u16,
    ) -> xcb_query_best_size_cookie_t;
}
extern "C" {
    pub fn xcb_query_best_size_unchecked(
        c: *mut xcb_connection_t,
        _class: u8,
        drawable: xcb_drawable_t,
        width: u16,
        height: u16,
    ) -> xcb_query_best_size_cookie_t;
}
extern "C" {
    pub fn xcb_query_best_size_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_query_best_size_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_query_best_size_reply_t;
}
extern "C" {
    pub fn xcb_query_extension_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_query_extension(
        c: *mut xcb_connection_t,
        name_len: u16,
        name: *const ::std::os::raw::c_char,
    ) -> xcb_query_extension_cookie_t;
}
extern "C" {
    pub fn xcb_query_extension_unchecked(
        c: *mut xcb_connection_t,
        name_len: u16,
        name: *const ::std::os::raw::c_char,
    ) -> xcb_query_extension_cookie_t;
}
extern "C" {
    pub fn xcb_query_extension_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_query_extension_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_query_extension_reply_t;
}
extern "C" {
    pub fn xcb_list_extensions_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_list_extensions(c: *mut xcb_connection_t) -> xcb_list_extensions_cookie_t;
}
extern "C" {
    pub fn xcb_list_extensions_unchecked(c: *mut xcb_connection_t) -> xcb_list_extensions_cookie_t;
}
extern "C" {
    pub fn xcb_list_extensions_names_length(
        R: *const xcb_list_extensions_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_list_extensions_names_iterator(
        R: *const xcb_list_extensions_reply_t,
    ) -> xcb_str_iterator_t;
}
extern "C" {
    pub fn xcb_list_extensions_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_list_extensions_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_list_extensions_reply_t;
}
extern "C" {
    pub fn xcb_change_keyboard_mapping_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_change_keyboard_mapping_checked(
        c: *mut xcb_connection_t,
        keycode_count: u8,
        first_keycode: xcb_keycode_t,
        keysyms_per_keycode: u8,
        keysyms: *const xcb_keysym_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_keyboard_mapping(
        c: *mut xcb_connection_t,
        keycode_count: u8,
        first_keycode: xcb_keycode_t,
        keysyms_per_keycode: u8,
        keysyms: *const xcb_keysym_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_keyboard_mapping_keysyms(
        R: *const xcb_change_keyboard_mapping_request_t,
    ) -> *mut xcb_keysym_t;
}
extern "C" {
    pub fn xcb_change_keyboard_mapping_keysyms_length(
        R: *const xcb_change_keyboard_mapping_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_change_keyboard_mapping_keysyms_end(
        R: *const xcb_change_keyboard_mapping_request_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_get_keyboard_mapping_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_get_keyboard_mapping(
        c: *mut xcb_connection_t,
        first_keycode: xcb_keycode_t,
        count: u8,
    ) -> xcb_get_keyboard_mapping_cookie_t;
}
extern "C" {
    pub fn xcb_get_keyboard_mapping_unchecked(
        c: *mut xcb_connection_t,
        first_keycode: xcb_keycode_t,
        count: u8,
    ) -> xcb_get_keyboard_mapping_cookie_t;
}
extern "C" {
    pub fn xcb_get_keyboard_mapping_keysyms(
        R: *const xcb_get_keyboard_mapping_reply_t,
    ) -> *mut xcb_keysym_t;
}
extern "C" {
    pub fn xcb_get_keyboard_mapping_keysyms_length(
        R: *const xcb_get_keyboard_mapping_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_get_keyboard_mapping_keysyms_end(
        R: *const xcb_get_keyboard_mapping_reply_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_get_keyboard_mapping_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_get_keyboard_mapping_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_get_keyboard_mapping_reply_t;
}
extern "C" {
    pub fn xcb_change_keyboard_control_value_list_serialize(
        _buffer: *mut *mut ::std::os::raw::c_void,
        value_mask: u32,
        _aux: *const xcb_change_keyboard_control_value_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_change_keyboard_control_value_list_unpack(
        _buffer: *const ::std::os::raw::c_void,
        value_mask: u32,
        _aux: *mut xcb_change_keyboard_control_value_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_change_keyboard_control_value_list_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        value_mask: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_change_keyboard_control_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_change_keyboard_control_checked(
        c: *mut xcb_connection_t,
        value_mask: u32,
        value_list: *const ::std::os::raw::c_void,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_keyboard_control(
        c: *mut xcb_connection_t,
        value_mask: u32,
        value_list: *const ::std::os::raw::c_void,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_keyboard_control_aux_checked(
        c: *mut xcb_connection_t,
        value_mask: u32,
        value_list: *const xcb_change_keyboard_control_value_list_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_keyboard_control_aux(
        c: *mut xcb_connection_t,
        value_mask: u32,
        value_list: *const xcb_change_keyboard_control_value_list_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_keyboard_control_value_list(
        R: *const xcb_change_keyboard_control_request_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn xcb_get_keyboard_control(c: *mut xcb_connection_t) -> xcb_get_keyboard_control_cookie_t;
}
extern "C" {
    pub fn xcb_get_keyboard_control_unchecked(
        c: *mut xcb_connection_t,
    ) -> xcb_get_keyboard_control_cookie_t;
}
extern "C" {
    pub fn xcb_get_keyboard_control_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_get_keyboard_control_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_get_keyboard_control_reply_t;
}
extern "C" {
    pub fn xcb_bell_checked(c: *mut xcb_connection_t, percent: i8) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_bell(c: *mut xcb_connection_t, percent: i8) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_pointer_control_checked(
        c: *mut xcb_connection_t,
        acceleration_numerator: i16,
        acceleration_denominator: i16,
        threshold: i16,
        do_acceleration: u8,
        do_threshold: u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_pointer_control(
        c: *mut xcb_connection_t,
        acceleration_numerator: i16,
        acceleration_denominator: i16,
        threshold: i16,
        do_acceleration: u8,
        do_threshold: u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_get_pointer_control(c: *mut xcb_connection_t) -> xcb_get_pointer_control_cookie_t;
}
extern "C" {
    pub fn xcb_get_pointer_control_unchecked(
        c: *mut xcb_connection_t,
    ) -> xcb_get_pointer_control_cookie_t;
}
extern "C" {
    pub fn xcb_get_pointer_control_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_get_pointer_control_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_get_pointer_control_reply_t;
}
extern "C" {
    pub fn xcb_set_screen_saver_checked(
        c: *mut xcb_connection_t,
        timeout: i16,
        interval: i16,
        prefer_blanking: u8,
        allow_exposures: u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_screen_saver(
        c: *mut xcb_connection_t,
        timeout: i16,
        interval: i16,
        prefer_blanking: u8,
        allow_exposures: u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_get_screen_saver(c: *mut xcb_connection_t) -> xcb_get_screen_saver_cookie_t;
}
extern "C" {
    pub fn xcb_get_screen_saver_unchecked(
        c: *mut xcb_connection_t,
    ) -> xcb_get_screen_saver_cookie_t;
}
extern "C" {
    pub fn xcb_get_screen_saver_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_get_screen_saver_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_get_screen_saver_reply_t;
}
extern "C" {
    pub fn xcb_change_hosts_sizeof(_buffer: *const ::std::os::raw::c_void)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_change_hosts_checked(
        c: *mut xcb_connection_t,
        mode: u8,
        family: u8,
        address_len: u16,
        address: *const u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_hosts(
        c: *mut xcb_connection_t,
        mode: u8,
        family: u8,
        address_len: u16,
        address: *const u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_hosts_address(R: *const xcb_change_hosts_request_t) -> *mut u8;
}
extern "C" {
    pub fn xcb_change_hosts_address_length(
        R: *const xcb_change_hosts_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_change_hosts_address_end(
        R: *const xcb_change_hosts_request_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_host_sizeof(_buffer: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_host_address(R: *const xcb_host_t) -> *mut u8;
}
extern "C" {
    pub fn xcb_host_address_length(R: *const xcb_host_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_host_address_end(R: *const xcb_host_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_host_next(i: *mut xcb_host_iterator_t);
}
extern "C" {
    pub fn xcb_host_end(i: xcb_host_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_list_hosts_sizeof(_buffer: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_list_hosts(c: *mut xcb_connection_t) -> xcb_list_hosts_cookie_t;
}
extern "C" {
    pub fn xcb_list_hosts_unchecked(c: *mut xcb_connection_t) -> xcb_list_hosts_cookie_t;
}
extern "C" {
    pub fn xcb_list_hosts_hosts_length(R: *const xcb_list_hosts_reply_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_list_hosts_hosts_iterator(R: *const xcb_list_hosts_reply_t) -> xcb_host_iterator_t;
}
extern "C" {
    pub fn xcb_list_hosts_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_list_hosts_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_list_hosts_reply_t;
}
extern "C" {
    pub fn xcb_set_access_control_checked(c: *mut xcb_connection_t, mode: u8) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_access_control(c: *mut xcb_connection_t, mode: u8) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_close_down_mode_checked(c: *mut xcb_connection_t, mode: u8)
        -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_close_down_mode(c: *mut xcb_connection_t, mode: u8) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_kill_client_checked(c: *mut xcb_connection_t, resource: u32) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_kill_client(c: *mut xcb_connection_t, resource: u32) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_rotate_properties_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_rotate_properties_checked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        atoms_len: u16,
        delta: i16,
        atoms: *const xcb_atom_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_rotate_properties(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        atoms_len: u16,
        delta: i16,
        atoms: *const xcb_atom_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_rotate_properties_atoms(
        R: *const xcb_rotate_properties_request_t,
    ) -> *mut xcb_atom_t;
}
extern "C" {
    pub fn xcb_rotate_properties_atoms_length(
        R: *const xcb_rotate_properties_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_rotate_properties_atoms_end(
        R: *const xcb_rotate_properties_request_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_force_screen_saver_checked(c: *mut xcb_connection_t, mode: u8) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_force_screen_saver(c: *mut xcb_connection_t, mode: u8) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_pointer_mapping_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_set_pointer_mapping(
        c: *mut xcb_connection_t,
        map_len: u8,
        map: *const u8,
    ) -> xcb_set_pointer_mapping_cookie_t;
}
extern "C" {
    pub fn xcb_set_pointer_mapping_unchecked(
        c: *mut xcb_connection_t,
        map_len: u8,
        map: *const u8,
    ) -> xcb_set_pointer_mapping_cookie_t;
}
extern "C" {
    pub fn xcb_set_pointer_mapping_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_set_pointer_mapping_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_set_pointer_mapping_reply_t;
}
extern "C" {
    pub fn xcb_get_pointer_mapping_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_get_pointer_mapping(c: *mut xcb_connection_t) -> xcb_get_pointer_mapping_cookie_t;
}
extern "C" {
    pub fn xcb_get_pointer_mapping_unchecked(
        c: *mut xcb_connection_t,
    ) -> xcb_get_pointer_mapping_cookie_t;
}
extern "C" {
    pub fn xcb_get_pointer_mapping_map(R: *const xcb_get_pointer_mapping_reply_t) -> *mut u8;
}
extern "C" {
    pub fn xcb_get_pointer_mapping_map_length(
        R: *const xcb_get_pointer_mapping_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_get_pointer_mapping_map_end(
        R: *const xcb_get_pointer_mapping_reply_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_get_pointer_mapping_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_get_pointer_mapping_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_get_pointer_mapping_reply_t;
}
extern "C" {
    pub fn xcb_set_modifier_mapping_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_set_modifier_mapping(
        c: *mut xcb_connection_t,
        keycodes_per_modifier: u8,
        keycodes: *const xcb_keycode_t,
    ) -> xcb_set_modifier_mapping_cookie_t;
}
extern "C" {
    pub fn xcb_set_modifier_mapping_unchecked(
        c: *mut xcb_connection_t,
        keycodes_per_modifier: u8,
        keycodes: *const xcb_keycode_t,
    ) -> xcb_set_modifier_mapping_cookie_t;
}
extern "C" {
    pub fn xcb_set_modifier_mapping_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_set_modifier_mapping_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_set_modifier_mapping_reply_t;
}
extern "C" {
    pub fn xcb_get_modifier_mapping_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_get_modifier_mapping(c: *mut xcb_connection_t) -> xcb_get_modifier_mapping_cookie_t;
}
extern "C" {
    pub fn xcb_get_modifier_mapping_unchecked(
        c: *mut xcb_connection_t,
    ) -> xcb_get_modifier_mapping_cookie_t;
}
extern "C" {
    pub fn xcb_get_modifier_mapping_keycodes(
        R: *const xcb_get_modifier_mapping_reply_t,
    ) -> *mut xcb_keycode_t;
}
extern "C" {
    pub fn xcb_get_modifier_mapping_keycodes_length(
        R: *const xcb_get_modifier_mapping_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_get_modifier_mapping_keycodes_end(
        R: *const xcb_get_modifier_mapping_reply_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_get_modifier_mapping_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_get_modifier_mapping_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_get_modifier_mapping_reply_t;
}
extern "C" {
    pub fn xcb_no_operation_checked(c: *mut xcb_connection_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_no_operation(c: *mut xcb_connection_t) -> xcb_void_cookie_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_auth_info_t {
    pub namelen: ::std::os::raw::c_int,
    pub name: *mut ::std::os::raw::c_char,
    pub datalen: ::std::os::raw::c_int,
    pub data: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_xcb_auth_info_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_auth_info_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_auth_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_auth_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_auth_info_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_auth_info_t>())).namelen as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_auth_info_t),
            "::",
            stringify!(namelen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_auth_info_t>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_auth_info_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_auth_info_t>())).datalen as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_auth_info_t),
            "::",
            stringify!(datalen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_auth_info_t>())).data as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_auth_info_t),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    pub fn xcb_flush(c: *mut xcb_connection_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_get_maximum_request_length(c: *mut xcb_connection_t) -> u32;
}
extern "C" {
    pub fn xcb_prefetch_maximum_request_length(c: *mut xcb_connection_t);
}
extern "C" {
    pub fn xcb_wait_for_event(c: *mut xcb_connection_t) -> *mut xcb_generic_event_t;
}
extern "C" {
    pub fn xcb_poll_for_event(c: *mut xcb_connection_t) -> *mut xcb_generic_event_t;
}
extern "C" {
    pub fn xcb_poll_for_queued_event(c: *mut xcb_connection_t) -> *mut xcb_generic_event_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_special_event {
    _unused: [u8; 0],
}
pub type xcb_special_event_t = xcb_special_event;
extern "C" {
    pub fn xcb_poll_for_special_event(
        c: *mut xcb_connection_t,
        se: *mut xcb_special_event_t,
    ) -> *mut xcb_generic_event_t;
}
extern "C" {
    pub fn xcb_wait_for_special_event(
        c: *mut xcb_connection_t,
        se: *mut xcb_special_event_t,
    ) -> *mut xcb_generic_event_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_extension_t {
    _unused: [u8; 0],
}
extern "C" {
    pub fn xcb_register_for_special_xge(
        c: *mut xcb_connection_t,
        ext: *mut xcb_extension_t,
        eid: u32,
        stamp: *mut u32,
    ) -> *mut xcb_special_event_t;
}
extern "C" {
    pub fn xcb_unregister_for_special_event(c: *mut xcb_connection_t, se: *mut xcb_special_event_t);
}
extern "C" {
    pub fn xcb_request_check(
        c: *mut xcb_connection_t,
        cookie: xcb_void_cookie_t,
    ) -> *mut xcb_generic_error_t;
}
extern "C" {
    pub fn xcb_discard_reply(c: *mut xcb_connection_t, sequence: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn xcb_discard_reply64(c: *mut xcb_connection_t, sequence: u64);
}
extern "C" {
    pub fn xcb_get_extension_data(
        c: *mut xcb_connection_t,
        ext: *mut xcb_extension_t,
    ) -> *const xcb_query_extension_reply_t;
}
extern "C" {
    pub fn xcb_prefetch_extension_data(c: *mut xcb_connection_t, ext: *mut xcb_extension_t);
}
extern "C" {
    pub fn xcb_get_setup(c: *mut xcb_connection_t) -> *const xcb_setup_t;
}
extern "C" {
    pub fn xcb_get_file_descriptor(c: *mut xcb_connection_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_connection_has_error(c: *mut xcb_connection_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_connect_to_fd(
        fd: ::std::os::raw::c_int,
        auth_info: *mut xcb_auth_info_t,
    ) -> *mut xcb_connection_t;
}
extern "C" {
    pub fn xcb_disconnect(c: *mut xcb_connection_t);
}
extern "C" {
    pub fn xcb_parse_display(
        name: *const ::std::os::raw::c_char,
        host: *mut *mut ::std::os::raw::c_char,
        display: *mut ::std::os::raw::c_int,
        screen: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_connect(
        displayname: *const ::std::os::raw::c_char,
        screenp: *mut ::std::os::raw::c_int,
    ) -> *mut xcb_connection_t;
}
extern "C" {
    pub fn xcb_connect_to_display_with_auth_info(
        display: *const ::std::os::raw::c_char,
        auth: *mut xcb_auth_info_t,
        screen: *mut ::std::os::raw::c_int,
    ) -> *mut xcb_connection_t;
}
extern "C" {
    pub fn xcb_generate_id(c: *mut xcb_connection_t) -> u32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_xwm {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_xwayland_cursor {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_gtk_primary_selection_device_manager {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_xwayland {
    pub pid: pid_t,
    pub client: *mut wl_client,
    pub sigusr1_source: *mut wl_event_source,
    pub xwm: *mut wlr_xwm,
    pub cursor: *mut wlr_xwayland_cursor,
    pub wm_fd: [::std::os::raw::c_int; 2usize],
    pub wl_fd: [::std::os::raw::c_int; 2usize],
    pub server_start: time_t,
    pub display: ::std::os::raw::c_int,
    pub display_name: [::std::os::raw::c_char; 16usize],
    pub x_fd: [::std::os::raw::c_int; 2usize],
    pub x_fd_read_event: [*mut wl_event_source; 2usize],
    pub lazy: bool,
    pub wl_display: *mut wl_display,
    pub compositor: *mut wlr_compositor,
    pub seat: *mut wlr_seat,
    pub events: wlr_xwayland__bindgen_ty_1,
    #[doc = " Add a custom event handler to xwayland. Return 1 if the event was"]
    #[doc = " handled or 0 to use the default wlr-xwayland handler. wlr-xwayland will"]
    #[doc = " free the event."]
    pub user_event_handler: ::std::option::Option<
        unsafe extern "C" fn(
            xwm: *mut wlr_xwm,
            event: *mut xcb_generic_event_t,
        ) -> ::std::os::raw::c_int,
    >,
    pub client_destroy: wl_listener,
    pub display_destroy: wl_listener,
    pub seat_destroy: wl_listener,
    pub data: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_xwayland__bindgen_ty_1 {
    pub ready: wl_signal,
    pub new_surface: wl_signal,
}
#[test]
fn bindgen_test_layout_wlr_xwayland__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wlr_xwayland__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(wlr_xwayland__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_xwayland__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_xwayland__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland__bindgen_ty_1>())).ready as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland__bindgen_ty_1),
            "::",
            stringify!(ready)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland__bindgen_ty_1>())).new_surface as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland__bindgen_ty_1),
            "::",
            stringify!(new_surface)
        )
    );
}
#[test]
fn bindgen_test_layout_wlr_xwayland() {
    assert_eq!(
        ::std::mem::size_of::<wlr_xwayland>(),
        264usize,
        concat!("Size of: ", stringify!(wlr_xwayland))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_xwayland>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_xwayland))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xwayland>())).pid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xwayland>())).client as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland),
            "::",
            stringify!(client)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xwayland>())).sigusr1_source as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland),
            "::",
            stringify!(sigusr1_source)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xwayland>())).xwm as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland),
            "::",
            stringify!(xwm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xwayland>())).cursor as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland),
            "::",
            stringify!(cursor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xwayland>())).wm_fd as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland),
            "::",
            stringify!(wm_fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xwayland>())).wl_fd as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland),
            "::",
            stringify!(wl_fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xwayland>())).server_start as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland),
            "::",
            stringify!(server_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xwayland>())).display as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xwayland>())).display_name as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland),
            "::",
            stringify!(display_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xwayland>())).x_fd as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland),
            "::",
            stringify!(x_fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xwayland>())).x_fd_read_event as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland),
            "::",
            stringify!(x_fd_read_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xwayland>())).lazy as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland),
            "::",
            stringify!(lazy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xwayland>())).wl_display as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland),
            "::",
            stringify!(wl_display)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xwayland>())).compositor as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland),
            "::",
            stringify!(compositor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xwayland>())).seat as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland),
            "::",
            stringify!(seat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xwayland>())).events as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xwayland>())).user_event_handler as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland),
            "::",
            stringify!(user_event_handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xwayland>())).client_destroy as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland),
            "::",
            stringify!(client_destroy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xwayland>())).display_destroy as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland),
            "::",
            stringify!(display_destroy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xwayland>())).seat_destroy as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland),
            "::",
            stringify!(seat_destroy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xwayland>())).data as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland),
            "::",
            stringify!(data)
        )
    );
}
pub mod wlr_xwayland_surface_decorations {
    pub type Type = u32;
    pub const WLR_XWAYLAND_SURFACE_DECORATIONS_ALL: Type = 0;
    pub const WLR_XWAYLAND_SURFACE_DECORATIONS_NO_BORDER: Type = 1;
    pub const WLR_XWAYLAND_SURFACE_DECORATIONS_NO_TITLE: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_xwayland_surface_hints {
    pub flags: u32,
    pub input: u32,
    pub initial_state: i32,
    pub icon_pixmap: xcb_pixmap_t,
    pub icon_window: xcb_window_t,
    pub icon_x: i32,
    pub icon_y: i32,
    pub icon_mask: xcb_pixmap_t,
    pub window_group: xcb_window_t,
}
#[test]
fn bindgen_test_layout_wlr_xwayland_surface_hints() {
    assert_eq!(
        ::std::mem::size_of::<wlr_xwayland_surface_hints>(),
        36usize,
        concat!("Size of: ", stringify!(wlr_xwayland_surface_hints))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_xwayland_surface_hints>(),
        4usize,
        concat!("Alignment of ", stringify!(wlr_xwayland_surface_hints))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface_hints>())).flags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface_hints),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface_hints>())).input as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface_hints),
            "::",
            stringify!(input)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface_hints>())).initial_state as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface_hints),
            "::",
            stringify!(initial_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface_hints>())).icon_pixmap as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface_hints),
            "::",
            stringify!(icon_pixmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface_hints>())).icon_window as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface_hints),
            "::",
            stringify!(icon_window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface_hints>())).icon_x as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface_hints),
            "::",
            stringify!(icon_x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface_hints>())).icon_y as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface_hints),
            "::",
            stringify!(icon_y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface_hints>())).icon_mask as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface_hints),
            "::",
            stringify!(icon_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface_hints>())).window_group as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface_hints),
            "::",
            stringify!(window_group)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_xwayland_surface_size_hints {
    pub flags: u32,
    pub x: i32,
    pub y: i32,
    pub width: i32,
    pub height: i32,
    pub min_width: i32,
    pub min_height: i32,
    pub max_width: i32,
    pub max_height: i32,
    pub width_inc: i32,
    pub height_inc: i32,
    pub base_width: i32,
    pub base_height: i32,
    pub min_aspect_num: i32,
    pub min_aspect_den: i32,
    pub max_aspect_num: i32,
    pub max_aspect_den: i32,
    pub win_gravity: u32,
}
#[test]
fn bindgen_test_layout_wlr_xwayland_surface_size_hints() {
    assert_eq!(
        ::std::mem::size_of::<wlr_xwayland_surface_size_hints>(),
        72usize,
        concat!("Size of: ", stringify!(wlr_xwayland_surface_size_hints))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_xwayland_surface_size_hints>(),
        4usize,
        concat!("Alignment of ", stringify!(wlr_xwayland_surface_size_hints))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface_size_hints>())).flags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface_size_hints),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface_size_hints>())).x as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface_size_hints),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface_size_hints>())).y as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface_size_hints),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface_size_hints>())).width as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface_size_hints),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface_size_hints>())).height as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface_size_hints),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface_size_hints>())).min_width as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface_size_hints),
            "::",
            stringify!(min_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface_size_hints>())).min_height as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface_size_hints),
            "::",
            stringify!(min_height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface_size_hints>())).max_width as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface_size_hints),
            "::",
            stringify!(max_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface_size_hints>())).max_height as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface_size_hints),
            "::",
            stringify!(max_height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface_size_hints>())).width_inc as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface_size_hints),
            "::",
            stringify!(width_inc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface_size_hints>())).height_inc as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface_size_hints),
            "::",
            stringify!(height_inc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface_size_hints>())).base_width as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface_size_hints),
            "::",
            stringify!(base_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface_size_hints>())).base_height as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface_size_hints),
            "::",
            stringify!(base_height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface_size_hints>())).min_aspect_num as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface_size_hints),
            "::",
            stringify!(min_aspect_num)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface_size_hints>())).min_aspect_den as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface_size_hints),
            "::",
            stringify!(min_aspect_den)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface_size_hints>())).max_aspect_num as *const _
                as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface_size_hints),
            "::",
            stringify!(max_aspect_num)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface_size_hints>())).max_aspect_den as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface_size_hints),
            "::",
            stringify!(max_aspect_den)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface_size_hints>())).win_gravity as *const _
                as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface_size_hints),
            "::",
            stringify!(win_gravity)
        )
    );
}
#[doc = " An Xwayland user interface component. It has an absolute position in"]
#[doc = " layout-local coordinates."]
#[doc = ""]
#[doc = " When a surface is ready to be displayed, the `map` event is emitted. When a"]
#[doc = " surface should no longer be displayed, the `unmap` event is emitted. The"]
#[doc = " `unmap` event is guaranteed to be emitted before the `destroy` event if the"]
#[doc = " view is destroyed when mapped."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_xwayland_surface {
    pub window_id: xcb_window_t,
    pub xwm: *mut wlr_xwm,
    pub surface_id: u32,
    pub link: wl_list,
    pub unpaired_link: wl_list,
    pub surface: *mut wlr_surface,
    pub x: i16,
    pub y: i16,
    pub width: u16,
    pub height: u16,
    pub saved_width: u16,
    pub saved_height: u16,
    pub override_redirect: bool,
    pub mapped: bool,
    pub title: *mut ::std::os::raw::c_char,
    pub class: *mut ::std::os::raw::c_char,
    pub instance: *mut ::std::os::raw::c_char,
    pub role: *mut ::std::os::raw::c_char,
    pub pid: pid_t,
    pub has_utf8_title: bool,
    pub children: wl_list,
    pub parent: *mut wlr_xwayland_surface,
    pub parent_link: wl_list,
    pub window_type: *mut xcb_atom_t,
    pub window_type_len: usize,
    pub protocols: *mut xcb_atom_t,
    pub protocols_len: usize,
    pub decorations: u32,
    pub hints: *mut wlr_xwayland_surface_hints,
    pub hints_urgency: u32,
    pub size_hints: *mut wlr_xwayland_surface_size_hints,
    pub pinging: bool,
    pub ping_timer: *mut wl_event_source,
    pub modal: bool,
    pub fullscreen: bool,
    pub maximized_vert: bool,
    pub maximized_horz: bool,
    pub has_alpha: bool,
    pub events: wlr_xwayland_surface__bindgen_ty_1,
    pub surface_destroy: wl_listener,
    pub data: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_xwayland_surface__bindgen_ty_1 {
    pub destroy: wl_signal,
    pub request_configure: wl_signal,
    pub request_move: wl_signal,
    pub request_resize: wl_signal,
    pub request_maximize: wl_signal,
    pub request_fullscreen: wl_signal,
    pub request_activate: wl_signal,
    pub map: wl_signal,
    pub unmap: wl_signal,
    pub set_title: wl_signal,
    pub set_class: wl_signal,
    pub set_role: wl_signal,
    pub set_parent: wl_signal,
    pub set_pid: wl_signal,
    pub set_window_type: wl_signal,
    pub set_hints: wl_signal,
    pub set_decorations: wl_signal,
    pub set_override_redirect: wl_signal,
    pub ping_timeout: wl_signal,
}
#[test]
fn bindgen_test_layout_wlr_xwayland_surface__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wlr_xwayland_surface__bindgen_ty_1>(),
        304usize,
        concat!("Size of: ", stringify!(wlr_xwayland_surface__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_xwayland_surface__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(wlr_xwayland_surface__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface__bindgen_ty_1>())).destroy as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface__bindgen_ty_1),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface__bindgen_ty_1>())).request_configure
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface__bindgen_ty_1),
            "::",
            stringify!(request_configure)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface__bindgen_ty_1>())).request_move as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface__bindgen_ty_1),
            "::",
            stringify!(request_move)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface__bindgen_ty_1>())).request_resize
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface__bindgen_ty_1),
            "::",
            stringify!(request_resize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface__bindgen_ty_1>())).request_maximize
                as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface__bindgen_ty_1),
            "::",
            stringify!(request_maximize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface__bindgen_ty_1>())).request_fullscreen
                as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface__bindgen_ty_1),
            "::",
            stringify!(request_fullscreen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface__bindgen_ty_1>())).request_activate
                as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface__bindgen_ty_1),
            "::",
            stringify!(request_activate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface__bindgen_ty_1>())).map as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface__bindgen_ty_1),
            "::",
            stringify!(map)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface__bindgen_ty_1>())).unmap as *const _
                as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface__bindgen_ty_1),
            "::",
            stringify!(unmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface__bindgen_ty_1>())).set_title as *const _
                as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface__bindgen_ty_1),
            "::",
            stringify!(set_title)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface__bindgen_ty_1>())).set_class as *const _
                as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface__bindgen_ty_1),
            "::",
            stringify!(set_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface__bindgen_ty_1>())).set_role as *const _
                as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface__bindgen_ty_1),
            "::",
            stringify!(set_role)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface__bindgen_ty_1>())).set_parent as *const _
                as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface__bindgen_ty_1),
            "::",
            stringify!(set_parent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface__bindgen_ty_1>())).set_pid as *const _
                as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface__bindgen_ty_1),
            "::",
            stringify!(set_pid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface__bindgen_ty_1>())).set_window_type
                as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface__bindgen_ty_1),
            "::",
            stringify!(set_window_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface__bindgen_ty_1>())).set_hints as *const _
                as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface__bindgen_ty_1),
            "::",
            stringify!(set_hints)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface__bindgen_ty_1>())).set_decorations
                as *const _ as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface__bindgen_ty_1),
            "::",
            stringify!(set_decorations)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface__bindgen_ty_1>())).set_override_redirect
                as *const _ as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface__bindgen_ty_1),
            "::",
            stringify!(set_override_redirect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface__bindgen_ty_1>())).ping_timeout as *const _
                as usize
        },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface__bindgen_ty_1),
            "::",
            stringify!(ping_timeout)
        )
    );
}
#[test]
fn bindgen_test_layout_wlr_xwayland_surface() {
    assert_eq!(
        ::std::mem::size_of::<wlr_xwayland_surface>(),
        584usize,
        concat!("Size of: ", stringify!(wlr_xwayland_surface))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_xwayland_surface>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_xwayland_surface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xwayland_surface>())).window_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface),
            "::",
            stringify!(window_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xwayland_surface>())).xwm as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface),
            "::",
            stringify!(xwm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xwayland_surface>())).surface_id as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface),
            "::",
            stringify!(surface_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xwayland_surface>())).link as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface),
            "::",
            stringify!(link)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface>())).unpaired_link as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface),
            "::",
            stringify!(unpaired_link)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xwayland_surface>())).surface as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface),
            "::",
            stringify!(surface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xwayland_surface>())).x as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xwayland_surface>())).y as *const _ as usize },
        66usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xwayland_surface>())).width as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xwayland_surface>())).height as *const _ as usize },
        70usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface>())).saved_width as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface),
            "::",
            stringify!(saved_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface>())).saved_height as *const _ as usize
        },
        74usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface),
            "::",
            stringify!(saved_height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface>())).override_redirect as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface),
            "::",
            stringify!(override_redirect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xwayland_surface>())).mapped as *const _ as usize },
        77usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface),
            "::",
            stringify!(mapped)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xwayland_surface>())).title as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface),
            "::",
            stringify!(title)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xwayland_surface>())).class as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface),
            "::",
            stringify!(class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xwayland_surface>())).instance as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface),
            "::",
            stringify!(instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xwayland_surface>())).role as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface),
            "::",
            stringify!(role)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xwayland_surface>())).pid as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface>())).has_utf8_title as *const _ as usize
        },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface),
            "::",
            stringify!(has_utf8_title)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xwayland_surface>())).children as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface),
            "::",
            stringify!(children)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xwayland_surface>())).parent as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface>())).parent_link as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface),
            "::",
            stringify!(parent_link)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface>())).window_type as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface),
            "::",
            stringify!(window_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface>())).window_type_len as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface),
            "::",
            stringify!(window_type_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xwayland_surface>())).protocols as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface),
            "::",
            stringify!(protocols)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface>())).protocols_len as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface),
            "::",
            stringify!(protocols_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface>())).decorations as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface),
            "::",
            stringify!(decorations)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xwayland_surface>())).hints as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface),
            "::",
            stringify!(hints)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface>())).hints_urgency as *const _ as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface),
            "::",
            stringify!(hints_urgency)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xwayland_surface>())).size_hints as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface),
            "::",
            stringify!(size_hints)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xwayland_surface>())).pinging as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface),
            "::",
            stringify!(pinging)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xwayland_surface>())).ping_timer as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface),
            "::",
            stringify!(ping_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xwayland_surface>())).modal as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface),
            "::",
            stringify!(modal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xwayland_surface>())).fullscreen as *const _ as usize },
        241usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface),
            "::",
            stringify!(fullscreen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface>())).maximized_vert as *const _ as usize
        },
        242usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface),
            "::",
            stringify!(maximized_vert)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface>())).maximized_horz as *const _ as usize
        },
        243usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface),
            "::",
            stringify!(maximized_horz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xwayland_surface>())).has_alpha as *const _ as usize },
        244usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface),
            "::",
            stringify!(has_alpha)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xwayland_surface>())).events as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface>())).surface_destroy as *const _ as usize
        },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface),
            "::",
            stringify!(surface_destroy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xwayland_surface>())).data as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_xwayland_surface_configure_event {
    pub surface: *mut wlr_xwayland_surface,
    pub x: i16,
    pub y: i16,
    pub width: u16,
    pub height: u16,
}
#[test]
fn bindgen_test_layout_wlr_xwayland_surface_configure_event() {
    assert_eq!(
        ::std::mem::size_of::<wlr_xwayland_surface_configure_event>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(wlr_xwayland_surface_configure_event)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_xwayland_surface_configure_event>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(wlr_xwayland_surface_configure_event)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface_configure_event>())).surface as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface_configure_event),
            "::",
            stringify!(surface)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface_configure_event>())).x as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface_configure_event),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface_configure_event>())).y as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface_configure_event),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface_configure_event>())).width as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface_configure_event),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_surface_configure_event>())).height as *const _
                as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_surface_configure_event),
            "::",
            stringify!(height)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_xwayland_move_event {
    pub surface: *mut wlr_xwayland_surface,
}
#[test]
fn bindgen_test_layout_wlr_xwayland_move_event() {
    assert_eq!(
        ::std::mem::size_of::<wlr_xwayland_move_event>(),
        8usize,
        concat!("Size of: ", stringify!(wlr_xwayland_move_event))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_xwayland_move_event>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_xwayland_move_event))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xwayland_move_event>())).surface as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_move_event),
            "::",
            stringify!(surface)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wlr_xwayland_resize_event {
    pub surface: *mut wlr_xwayland_surface,
    pub edges: u32,
}
#[test]
fn bindgen_test_layout_wlr_xwayland_resize_event() {
    assert_eq!(
        ::std::mem::size_of::<wlr_xwayland_resize_event>(),
        16usize,
        concat!("Size of: ", stringify!(wlr_xwayland_resize_event))
    );
    assert_eq!(
        ::std::mem::align_of::<wlr_xwayland_resize_event>(),
        8usize,
        concat!("Alignment of ", stringify!(wlr_xwayland_resize_event))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wlr_xwayland_resize_event>())).surface as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_resize_event),
            "::",
            stringify!(surface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wlr_xwayland_resize_event>())).edges as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wlr_xwayland_resize_event),
            "::",
            stringify!(edges)
        )
    );
}
extern "C" {
    #[doc = " Create an Xwayland server."]
    #[doc = ""]
    #[doc = " The server supports a lazy mode in which Xwayland is only started when a"]
    #[doc = " client tries to connect."]
    #[doc = ""]
    #[doc = " Note: wlr_xwayland will setup a global SIGUSR1 handler on the compositor"]
    #[doc = " process."]
    pub fn wlr_xwayland_create(
        wl_display: *mut wl_display,
        compositor: *mut wlr_compositor,
        lazy: bool,
    ) -> *mut wlr_xwayland;
}
extern "C" {
    pub fn wlr_xwayland_destroy(wlr_xwayland: *mut wlr_xwayland);
}
extern "C" {
    pub fn wlr_xwayland_set_cursor(
        wlr_xwayland: *mut wlr_xwayland,
        pixels: *mut u8,
        stride: u32,
        width: u32,
        height: u32,
        hotspot_x: i32,
        hotspot_y: i32,
    );
}
extern "C" {
    pub fn wlr_xwayland_surface_activate(surface: *mut wlr_xwayland_surface, activated: bool);
}
extern "C" {
    pub fn wlr_xwayland_surface_configure(
        surface: *mut wlr_xwayland_surface,
        x: i16,
        y: i16,
        width: u16,
        height: u16,
    );
}
extern "C" {
    pub fn wlr_xwayland_surface_close(surface: *mut wlr_xwayland_surface);
}
extern "C" {
    pub fn wlr_xwayland_surface_set_maximized(surface: *mut wlr_xwayland_surface, maximized: bool);
}
extern "C" {
    pub fn wlr_xwayland_surface_set_fullscreen(
        surface: *mut wlr_xwayland_surface,
        fullscreen: bool,
    );
}
extern "C" {
    pub fn wlr_xwayland_set_seat(xwayland: *mut wlr_xwayland, seat: *mut wlr_seat);
}
extern "C" {
    pub fn wlr_surface_is_xwayland_surface(surface: *mut wlr_surface) -> bool;
}
extern "C" {
    pub fn wlr_xwayland_surface_from_wlr_surface(
        surface: *mut wlr_surface,
    ) -> *mut wlr_xwayland_surface;
}
extern "C" {
    pub fn wlr_xwayland_surface_ping(surface: *mut wlr_xwayland_surface);
}
extern "C" {
    #[doc = " Metric to guess if an OR window should \"receive\" focus"]
    #[doc = ""]
    #[doc = " In the pure X setups, window managers usually straight up ignore override"]
    #[doc = " redirect windows, and never touch them. (we have to handle them for mapping)"]
    #[doc = ""]
    #[doc = " When such a window wants to receive keyboard input (e.g. rofi/dzen) it will"]
    #[doc = " use mechanics we don't support (sniffing/grabbing input)."]
    #[doc = " [Sadly this is unrelated to xwayland-keyboard-grab]"]
    #[doc = ""]
    #[doc = " To still support these windows, while keeping general OR semantics as is, we"]
    #[doc = " need to hand a subset of windows focus."]
    #[doc = " The dirty truth is, we need to hand focus to any Xwayland window, though"]
    #[doc = " pretending this window has focus makes it easier to handle unmap."]
    #[doc = ""]
    #[doc = " This function provides a handy metric based on the window type to guess if"]
    #[doc = " the OR window wants focus."]
    #[doc = " It's probably not perfect, nor exactly intended but works in practice."]
    #[doc = ""]
    #[doc = " Returns: true if the window should receive focus"]
    #[doc = "          false if it should be ignored"]
    pub fn wlr_xwayland_or_surface_wants_focus(surface: *const wlr_xwayland_surface) -> bool;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
